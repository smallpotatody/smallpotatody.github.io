<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小土豆</title>
  
  <subtitle>-博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://smallpotatody.github.io/"/>
  <updated>2019-09-20T01:05:33.388Z</updated>
  <id>https://smallpotatody.github.io/</id>
  
  <author>
    <name>smallpotato</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>给国内访问Github加速</title>
    <link href="https://smallpotatody.github.io/2019/09/20/%E7%BB%99%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AEGithub%E5%8A%A0%E9%80%9F/"/>
    <id>https://smallpotatody.github.io/2019/09/20/给国内访问Github加速/</id>
    <published>2019-09-20T01:01:25.000Z</published>
    <updated>2019-09-20T01:05:33.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="给国内访问Github加速"><a href="#给国内访问Github加速" class="headerlink" title="给国内访问Github加速"></a>给国内访问Github加速</h1><ol><li>获取GitHub官方CDN地址</li></ol><p><a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDMwMDQzNC02ZTcxNWIxMDM2MjlkYTcxLnBuZw?x-oss-process=image/format,png" alt></p><p>分别查询三个链接的DNS解析地址</p><ul><li><p>github.com</p></li><li><p>assets-cdn.github.com</p></li><li><p>github.global.ssl.fastly.net</p></li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDMwMDQzNC04OWRjODdmOGZjMDQ4ZjFiLnBuZw?x-oss-process=image/format,png" alt></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDMwMDQzNC0yZGMzYmE4ZjVmM2M5NTlhLnBuZw?x-oss-process=image/format,png" alt></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDMwMDQzNC0zZTBlN2U4NTllOGY0ODQyLnBuZw?x-oss-process=image/format,png" alt></p><p>记录查询到的IP地址</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDMwMDQzNC1jNjFhYTYyOThjZjYyMjY5LnBuZw?x-oss-process=image/format,png" alt></p><ol start="2"><li><p>修改系统Hosts文件</p><ul><li><p>打开系统hosts文件(需管理员权限)。</p></li><li><p>路径：C:\Windows\System32\drivers\etc\hosts</p></li></ul><p>在末尾添加三行记录并保存。(需管理员权限，注意IP地址与域名间需留有空格)</p></li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDMwMDQzNC1hNTk2ZDAwZTU3Yjc5OWZiLnBuZw?x-oss-process=image/format,png" alt></p><ol start="3"><li><p>刷新系统DNS缓存</p><p>打开powershell（管理员身份）</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDMwMDQzNC03YjBkYmQ5YzMzOWIzZWU3LnBuZw?x-oss-process=image/format,png" alt></p><p>输入命令<code>ipconfig /flushdns</code>手动刷新系统DNS缓存</p></li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDMwMDQzNC0yMzJmNTNkODhlODQ2ZDU2LnBuZw?x-oss-process=image/format,png" alt></p><p>到此就结束了对国内访问GitHub提速了，现在去试试吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;给国内访问Github加速&quot;&gt;&lt;a href=&quot;#给国内访问Github加速&quot; class=&quot;headerlink&quot; title=&quot;给国内访问Github加速&quot;&gt;&lt;/a&gt;给国内访问Github加速&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;获取GitHub官方CDN地址&lt;/li&gt;
      
    
    </summary>
    
      <category term="GitHub" scheme="https://smallpotatody.github.io/categories/GitHub/"/>
    
    
      <category term="software" scheme="https://smallpotatody.github.io/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式学习</title>
    <link href="https://smallpotatody.github.io/2019/07/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://smallpotatody.github.io/2019/07/19/嵌入式学习/</id>
    <published>2019-07-19T08:53:03.000Z</published>
    <updated>2019-08-09T12:47:43.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux部分"><a href="#Linux部分" class="headerlink" title="Linux部分"></a>Linux部分</h1><p>由于前面已经学习了Linux，所以在这里只做简单的补充；</p><h2 id="vi编辑器三种模式"><a href="#vi编辑器三种模式" class="headerlink" title="vi编辑器三种模式"></a>vi编辑器三种模式</h2><p>​    命令行模式：</p><p>​        用户在用vi编辑时文件时，最初进入的该模式。课以进行复制、粘贴等操作。</p><p>​    插入模式：</p><p>​        进行文件编辑，按ESC键可以回到命令行模式。</p><p>​    底行模式：</p><p>​        光标位于屏幕底行。可以进行文件的保存、退出、查找、替换、列出行号等。</p><h2 id="Vi光标命令"><a href="#Vi光标命令" class="headerlink" title="Vi光标命令"></a>Vi光标命令</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>h</td><td>方向键，向左移动光标一个字符的位置，相当于键”←”</td></tr><tr><td>j</td><td>方向键，向左移动光标一个字符的位置，相当于键“↓”</td></tr><tr><td>k</td><td>方向键，向左移动光标一个字符的位置，相当于键“↑”</td></tr><tr><td>l</td><td>方向键，向左移动光标一个字符的位置，相当于键“→”</td></tr><tr><td>:N</td><td>y移动光标到第N行</td></tr><tr><td>1G</td><td>移动光标到文件的第1行</td></tr><tr><td>G</td><td>移动光标到文件的最后一行</td></tr></tbody></table><h2 id="Vi的查找命令"><a href="#Vi的查找命令" class="headerlink" title="Vi的查找命令"></a>Vi的查找命令</h2><p>/string 查找字符串</p><p>​    n继续查找</p><p>​    N方向继续查找</p><p>​    支持正则表达式</p><h2 id="Vi替换命令"><a href="#Vi替换命令" class="headerlink" title="Vi替换命令"></a>Vi替换命令</h2><p>利用<code>:s</code>命令可以实现字符串的替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:s/str1/str2/             #s当前行</span><br><span class="line">:s/str1/str2/g            #g全部替换</span><br><span class="line">:.,$s/str1/str2/g         #.,$从该行到末尾</span><br><span class="line">:1,$s/str1/str2/g         #1,$从第一行到最后一行（全部）</span><br><span class="line">:%s/str1/str2/g           #%全部</span><br><span class="line">:n1,n2s/str1/str2/g       #从n1到n2行</span><br></pre></td></tr></table></figure><h2 id="Vi复制和剪切命令"><a href="#Vi复制和剪切命令" class="headerlink" title="Vi复制和剪切命令"></a>Vi复制和剪切命令</h2><p>y0：将光标至行首的字符考入剪贴板</p><p>y$：将光标至行尾的字符考入剪贴板</p><p>d0：将光标至行首的字符剪切入剪贴板</p><p>d$：将光标至行尾的字符剪切入剪贴板</p><p>:n1,n2y：块复制</p><p>:n1,n2d：块剪切</p><h1 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h1><h2 id="冯-诺依曼模型"><a href="#冯-诺依曼模型" class="headerlink" title="冯 . 诺依曼模型"></a>冯 . 诺依曼模型</h2><p>​    计算机硬件由五部分组成：输入、输出、存储器、运算器、控制器</p><p>​    存储程序的思想：系统的运行过程就是按照一定的顺序不断执行存储器中的程序指令的过程。</p><h2 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h2><p>​    主存储器即内存。程序中待处理的数据和处理的结构都存储在内存中。</p><p>​    外存储器是用来长期保存数据的大容量存储器。</p><p>​    寄存器是CPU内部的高速存储器，速度快，数目少。</p><h2 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h2><p>​    广义上讲，为了实现一个特定的目标而预先设计的一组可操作的工作步骤，称之为一个程序。</p><p>​    程序就是系统可以识别的一组有序的指令（二进制）。储存在磁盘上，被加载到内存中执行。</p><h1 id="程序设计语言的发展"><a href="#程序设计语言的发展" class="headerlink" title="程序设计语言的发展"></a>程序设计语言的发展</h1><h2 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h2><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><h1 id="程序设计步骤"><a href="#程序设计步骤" class="headerlink" title="程序设计步骤"></a>程序设计步骤</h1><p><img src="/2019/07/19/嵌入式学习/1.png" alt></p><h1 id="计算机数据表示"><a href="#计算机数据表示" class="headerlink" title="计算机数据表示"></a>计算机数据表示</h1><p>​    送入计算机的数字、字母、符号等信息必须转换成0、1组合的数据形式才能被计算机识别。</p><p>​    能够进行算术运算得到明确数值概念的信息称为计算机数值数据，其余的信息成为非数值数据。</p><h2 id="数值数据的表示"><a href="#数值数据的表示" class="headerlink" title="数值数据的表示"></a>数值数据的表示</h2><p>​    十进制、二进制、十六进制、八进制</p><p>​    基数和各数位的权</p><h2 id="非数值数据表示"><a href="#非数值数据表示" class="headerlink" title="非数值数据表示"></a>非数值数据表示</h2><p>​    非数值数据包括文字、符号、图像、语言和逻辑信息等，也都是以0、1形式存在。</p><p>​    字符数据在机器内也被变换成二进制编码的形式。国际上普遍采用的一种编码是美国国家信息交换标准代码，简称为ASCII码。</p><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>​    <code>man ASCII</code></p><p><img src="/2019/07/19/嵌入式学习/2.png" alt></p><h1 id="程序的编译和调试"><a href="#程序的编译和调试" class="headerlink" title="程序的编译和调试"></a>程序的编译和调试</h1><h2 id="gcc编译器"><a href="#gcc编译器" class="headerlink" title="gcc编译器"></a>gcc编译器</h2><p>gcc（GNU compiler）是GNU推出的多平台编译器，可将C、C++源程序编译连接成可执行文件，支持以下后缀：</p><table><thead><tr><th>.c</th><th>c语言源代码</th></tr></thead><tbody><tr><td>.h</td><td>程序所包含的头文件</td></tr><tr><td>.i</td><td>已经预处理过的C源代码文件</td></tr><tr><td>.s</td><td>汇编语言源代码文件</td></tr><tr><td>.o</td><td>编译后的目标文件</td></tr></tbody></table><p><code>gcc -o hello hello.c</code>或<code>gcc hello.c -o hell</code></p><p>​    -Wall 查看警告</p><p>​    -o 输出可执行文件</p><p>​    -c 只要求编译器输出目标代码（.o文件），而不必输出可执行文件</p><p>​    -g 用于调试</p><p>​    ./hell 查看输出结果(执行)        </p><p><img src="/2019/07/19/嵌入式学习/3.png" alt></p><h2 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h2><p>​    利用<code>_FILE_</code>,<code>_LINE_</code>,<code>_FUNCTION_</code>实现代码跟踪调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%s,%s,%d\n&quot;,__FILE__,__FUNCTION__,__LINE__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C语言基础"><a href="#C语言基础" class="headerlink" title="C语言基础"></a>C语言基础</h2><p>一个程序应当包含两个部分：</p><p>​    对数据的描述。在程序中要指定数据的类型和数据的组织形式，即数据结构</p><p>​    对操作的描述。即操作步骤，也就是算法</p><p>算法的基本概念：</p><p>​    做任何事都有一定的步骤。步骤要按照一定的顺序进行，缺一不可，次序也不能错。广义的说，为解决一个问题而采取的方法和步骤就称之为算法。</p><hr><p>由于以前学过C语言，现在只是来复习和拓展一下。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><img src="/2019/07/19/嵌入式学习/4.png" alt></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>逻辑类型。只有两个量true和false，表示逻辑真值和逻辑假植。</p><p>整数类型。包括char，short，int和long。</p><p>浮点类型。包括float和double。</p><p>void类型。主要用于说明不返回的函数或指针。</p><p>bool类型。非零（true），零（false）。需要加头文件<code>&lt;stdbool.h&gt;</code>。</p><p>char类型。使用char数据类型的变量需要特别注意，防止数据超出值域。</p><p><code>&lt;limits.h&gt;</code></p><table><thead><tr><th>类型名称           长度（字节）</th><th>值域</th></tr></thead><tbody><tr><td>char                   1</td><td>-128~127或0~255（使用/J编译选项）</td></tr><tr><td>signed char        1</td><td>-128~127</td></tr><tr><td>unsigned char     1</td><td>0~255</td></tr></tbody></table><p>short类型</p><table><thead><tr><th>类型名称</th><th>长度（字节）</th><th>值域</th></tr></thead><tbody><tr><td>short（signed short）</td><td>2</td><td>-32768~32767</td></tr><tr><td>unsigned short</td><td>2</td><td>0~65535</td></tr></tbody></table><p>int类型</p><table><thead><tr><th>类型名称</th><th>长度（字节）</th><th>值域</th></tr></thead><tbody><tr><td>int（signed int）</td><td>4</td><td>-2147483648~2147483647</td></tr><tr><td>unsigned int</td><td>4</td><td>0~4294967295</td></tr></tbody></table><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><h2 id="整型常量"><a href="#整型常量" class="headerlink" title="整型常量"></a>整型常量</h2><p>​    常量是指在程序运行期间其数值不发生变化的数据。整型常量通常称为整数。</p><p>​    整数可以是十进制、八进制、和十六进制数。</p><h2 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h2><p>​    浮点常量又称为实数，一般含有小数部分。</p><p>​    在C语言中，实数只有十进制的实数，分为单精度和双精度。实数表示有两种方法，即一般形式和指数形式。</p><h2 id="指数常量"><a href="#指数常量" class="headerlink" title="指数常量"></a>指数常量</h2><p>​    指数形式的实数一般是由尾数部分、字母e或E和指数部分组成。</p><h2 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h2><p>​    字符常量是指一个单一字符，其表示是由两个单引号包括的一个字符。</p><p>​    在C语言中，字符常量具有数值。字符常量的值就是字符的ASCII码值。</p><p>​    可以把字符常量看做一个字节的正整数。</p><p><img src="/2019/07/19/嵌入式学习/5.png" alt></p><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>​    所谓字符串常量是指用双引号括起来的一串字符来表示的数据。（字符串以\0结尾,像”3”与’3’,’\0’相同）。</p><p><img src="/2019/07/19/嵌入式学习/6.png" alt></p><h2 id="标识常量"><a href="#标识常量" class="headerlink" title="标识常量"></a>标识常量</h2><p>​    所谓标识常量是指用标识符代替常量使用的一种常量，其名称通常是一个标识符。</p><p><code>#define &lt;表示常量名称&gt; &lt;常量&gt;</code></p><p><img src="/2019/07/19/嵌入式学习/7.png" alt></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>一个水分子的质量约为3.0*10-23g，1夸脱水大约有950g，编写一个程序，要求输入水的夸脱数，然后显示这么多水中包含多少水分子？</p><p><img src="/2019/07/19/嵌入式学习/8.png" alt></p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量的基础"><a href="#变量的基础" class="headerlink" title="变量的基础"></a>变量的基础</h2><p>​    变量在程序中用变量名表示。变量名由用户根据其用途任意命名。</p><p>​    变量名由字母、数字、下划线组成，不能以数字开头，不能和C的关键字重名。 </p><p>​    在程序运行时，变量占据存储空间的大小由其数据类型决定。</p><p>​    变量在内存空间中的首地址，称为变量的地址。</p><p><img src="/2019/07/19/嵌入式学习/8_1.png" alt></p><h2 id="变量的说明"><a href="#变量的说明" class="headerlink" title="变量的说明"></a>变量的说明</h2><p>​    变量在程序中使用时,必须预先说明它们的存储类型和数据类型。</p><p>​    变量说明的一般形式是：</p><p>​       <code>&lt;存储类型&gt;    &lt;数据类型 &gt;    &lt;变量名&gt;</code> ； </p><p>​    &lt;存储类型&gt;是关键词auto、register、static和extern</p><p>​    &lt;数据类型&gt;可以是基本数据类型，也可以是自定义的数据类型    </p><h2 id="变量的存储类型"><a href="#变量的存储类型" class="headerlink" title="变量的存储类型"></a>变量的存储类型</h2><p>​    auto说明的变量只能在某个程序范围内使用，通常在函数体内或函数中的复合语句里。（默认是随机值）</p><p>​    在函数体的某程序段内说明auto存储类型的变量时可以省略关键字auto。</p><p>​    register称为寄存器型，register变量是想将变量放入CPU的寄存器中，这样可以加快程序的运行速度。如申请不到就使用一般内存，同auto ;</p><p>​    register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不能用“&amp;”来获取register变量的地址。</p><p>​    由于寄存器的数量有限，真正起作用的register修饰符的数目和类型都依赖于运行程序的机器。在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度。因为被占用的寄存器不能再用于其它目的；或者变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销。</p><h2 id="变量的存储类型static"><a href="#变量的存储类型static" class="headerlink" title="变量的存储类型static"></a>变量的存储类型static</h2><p>​    static变量称为静态存储类型的变量，既可以在函数体内，也可在函数体外说明。(默认是0）</p><p>局部变量使用static修饰,有以下特点:</p><p>​    在内存中以固定地址存放的，而不是以堆栈方式存放</p><p>​    只要程序没结束，就不会随着说明它的程序段的结束而消失，它下次再调用该函数，该存储类型的变量不再重新说明，而且还保留上次调用存入的数值</p><p><img src="/2019/07/19/嵌入式学习/9.png" alt></p><p><img src="/2019/07/19/嵌入式学习/10.png" alt></p><h2 id="变量的存储类型extern"><a href="#变量的存储类型extern" class="headerlink" title="变量的存储类型extern"></a>变量的存储类型extern</h2><p>​    当变量在一个文件中的函数体外说明，所有其他文件中的函数或程序段都可引用这个变量。</p><p>​    extern称为外部参照引用型，使用extern说明的变量是想引用在其它文件中函数体外部说明的变量。</p><p>​    static修饰的全部变量，其它文件无法使用</p><p><img src="/2019/07/19/嵌入式学习/11.png" alt></p><hr><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>​    C提供的算术运算符：+,-,*,/,%,++</p><p><img src="/2019/07/19/嵌入式学习/12.png" alt></p><p><img src="/2019/07/19/嵌入式学习/12_1.png" alt></p><p><strong>注意：float或double不能取余</strong></p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p><img src="/2019/07/19/嵌入式学习/13.png" alt></p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><img src="/2019/07/19/嵌入式学习/14.png" alt></p><p><img src="/2019/07/19/嵌入式学习/14_1.png" alt></p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><img src="/2019/07/19/嵌入式学习/15.png" alt></p><p>位移位运算的一般形式:         </p><p>​    <code>&lt;运算量&gt; &lt;运算符&gt; &lt;表达式&gt;</code>其中:</p><p>​        &lt;运算量&gt; 必须为整型结果数值；</p><p>​        &lt;运算符&gt;为左移位（&lt;&lt;）或 右移位（&gt;&gt;）运算符；</p><p>​        &lt;表达式&gt; 也必须为整型结果数值。</p><p><img src="/2019/07/19/嵌入式学习/16.png" alt></p><p><img src="/2019/07/19/嵌入式学习/17.png" alt></p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>​    赋值运算符为“=”，其运算的一般形式如下：</p><p>​        <code>&lt;左值表达式&gt; = &lt;右值表达式&gt;</code></p><p>​    赋值复合运算符其运算的一般形式如下: </p><p>​        <code>&lt;变量&gt;  &lt;操作符&gt;=  &lt;表达式&gt;</code></p><p><img src="/2019/07/19/嵌入式学习/18.png" alt></p><h2 id="C语言的特殊运算符"><a href="#C语言的特殊运算符" class="headerlink" title="C语言的特殊运算符"></a>C语言的特殊运算符</h2><h3 id="条件运算符”-”"><a href="#条件运算符”-”" class="headerlink" title="条件运算符”? :”"></a>条件运算符”? :”</h3><p>​    是三目运算符, 其运算的一般形式是:     </p><p>​        <code>&lt;表达式1&gt;  ?  &lt;表达式2&gt;  :  &lt;表达式3&gt;</code></p><p><img src="/2019/07/19/嵌入式学习/19.png" alt></p><h3 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h3><pre><code>运算的一般形式:sizeof(&lt;类型或变量名&gt;)  **注意：它只针对数据类型，而不针对变量！**   </code></pre><h2 id="C运算符的优先级"><a href="#C运算符的优先级" class="headerlink" title="C运算符的优先级"></a>C运算符的优先级</h2><p><img src="/2019/07/19/嵌入式学习/20.png" alt></p><p><img src="/2019/07/19/嵌入式学习/21.png" alt></p><hr><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h2><p>​    C语言中无I/O语句，I/O操作由函数实现</p><p>​        <code>#include&lt;stdio.h&gt;</code></p><h2 id="字符输出函数"><a href="#字符输出函数" class="headerlink" title="字符输出函数"></a>字符输出函数</h2><p>​        格式：<code>putchar（c）</code></p><p>​        参数：c为字符常量、变量或表达式</p><p>​        功能：把字符c输出到显示器上</p><p>​        返值：正常，为显示的代码值</p><p><img src="/2019/07/19/嵌入式学习/22.png" alt></p><h2 id="格式输出函数"><a href="#格式输出函数" class="headerlink" title="格式输出函数"></a>格式输出函数</h2><p>​        格式：<code>printf(&quot;格式控制串&quot; ，输出表)</code></p><p>​            功能：按指定格式向显示器输出数据</p><p>​            输出表：要输出的数据</p><p>​            格式控制串：包含两种信息</p><p>​                格式shuoming：%[修饰符]格式字符，用于指定输出格式</p><p>​                普通字符：原样输出</p><p><img src="/2019/07/19/嵌入式学习/23.png" alt></p><h2 id="输出函数格式字符m-n"><a href="#输出函数格式字符m-n" class="headerlink" title="输出函数格式字符m.n"></a>输出函数格式字符<code>m.n</code></h2><p>​        m输出数据域宽度，数据长度&lt;m，左补空格；否则按实际输出</p><p>​        .n对实数，指定小数点后位数（四舍五入）；对字符串，指定实际输出位数</p><p><img src="/2019/07/19/嵌入式学习/24.png" alt></p><p><img src="/2019/07/19/嵌入式学习/25.png" alt></p><h2 id="字符输入函数"><a href="#字符输入函数" class="headerlink" title="字符输入函数"></a>字符输入函数</h2><p>字符数输入函数getchar</p><p>​    格式：<code>getchar()</code></p><p>​    功能：从键盘读一字符</p><p>​    返值：正常，返回读取的代码值；出错或结束键盘输入，返回-1</p><p><img src="/2019/07/19/嵌入式学习/26.png" alt></p><h2 id="格式输入函数"><a href="#格式输入函数" class="headerlink" title="格式输入函数"></a>格式输入函数</h2><p>格式：<code>scanf(&quot;格式控制串&quot;,地址表)</code></p><p>功能：按指定格式从键盘读入数据，存入地址表</p><p>存储单元中，并按回车键结束</p><p>返值：正常，返回输入数据个数</p><p>地址表：变量的地址，常用取地址运算符&amp;</p><p><strong>注意：用”%c”格式符时，空格和转义字符作为有效字符输入</strong></p><p>输入数据时，遇到以下情况认为该数据结束：</p><ul><li><p>遇空格、TAB、回车</p></li><li><p>遇非法输入</p></li><li>遇宽度结束</li></ul><h2 id="字符串输入函数"><a href="#字符串输入函数" class="headerlink" title="字符串输入函数"></a>字符串输入函数</h2><p>字符串输入函数gets</p><p>​    格式：char <em>gets(char </em>s)</p><p>​    功能：从键盘输入一个以回车结束的字符串放入字符，数组中，并自动加入’\0’.</p><p>​    说明：输入串长度应小于字符数组维数；与scanf函数不同，gets函数并不以空格作为字符串输入结束的标志。</p><h2 id="字符串输出函数"><a href="#字符串输出函数" class="headerlink" title="字符串输出函数"></a>字符串输出函数</h2><p>字符串输出函数puts</p><p>​    格式：int puts(const char *s)</p><p>​    功能：向显示器输出字符串（输出完，换行）</p><p>​    说明：字符数组必须以’\0’结束</p><hr><p>输入函数留下的“垃圾”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int x;</span><br><span class="line">char y;</span><br><span class="line"></span><br><span class="line">scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">scanf(&quot;%c&quot;, &amp;y);</span><br><span class="line"></span><br><span class="line">printf(&quot;x=%d, y=%c\n&quot;, x, y);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行上面程序时，容易输入一个数字，再按回车就结束了对y的输入</p><p>结果：</p><p>​    <img src="/2019/07/19/嵌入式学习/27.png" alt></p><p>处理垃圾方法：</p><p>​    1. 用getchar()清除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int x;</span><br><span class="line">char y;</span><br><span class="line"></span><br><span class="line">scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">getchar();</span><br><span class="line">y = getchar();</span><br><span class="line"></span><br><span class="line">printf(&quot;x=%d, y:%d, y=%c\n&quot;, x, y, y);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2019/07/19/嵌入式学习/28.png" alt></p><p>第一个scanf后的getchar就把”回车”给接收了，字符y就从另外一个getchar获得，也就是回车后再次输入的字符。</p><p>​    2. 用格式串中空格或”%*c”</p><p><img src="/2019/07/19/嵌入式学习/29.png" alt></p><p><img src="/2019/07/19/嵌入式学习/30.png" alt></p><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><p><img src="/2019/07/19/嵌入式学习/31.png" alt></p><h2 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h2><p>​    if语句概述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(表达式)</span><br><span class="line">语句块1</span><br><span class="line">else</span><br><span class="line">语句块2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">float score;</span><br><span class="line">printf(&quot;Please input your score:&quot;);</span><br><span class="line">scanf(&quot;%f&quot;, &amp;score);</span><br><span class="line"></span><br><span class="line">if(score &lt; 0 || score &gt; 100)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;error\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">if(score &gt;= 90)</span><br><span class="line">printf(&quot;A\n&quot;);</span><br><span class="line">else&#123;</span><br><span class="line">if(score &gt;= 70)</span><br><span class="line">printf(&quot;B\n&quot;);</span><br><span class="line">else&#123;</span><br><span class="line">if(score &gt;= 60)</span><br><span class="line">printf(&quot;C\n&quot;);</span><br><span class="line">else</span><br><span class="line">printf(&quot;D\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><p><img src="/2019/07/19/嵌入式学习/32.png" alt></p><p>注意：</p><p>​    语句块：当有若干条语句时，必须用{…}括起来</p><p>​    表达式：</p><ul><li>一般情况下为逻辑表达式或关系表达式</li><li>也可以是任意类型（包括整形、实型、字符型、指针类型）</li></ul><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>switch语句的基本格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)</span><br><span class="line">&#123;</span><br><span class="line">    case 常量表达式1:语句块1;</span><br><span class="line">    break;</span><br><span class="line">    case 常量表达式2:语句块2;</span><br><span class="line">    break;</span><br><span class="line">    case 常量表达式3:语句块3;</span><br><span class="line">    break;</span><br><span class="line">    ...</span><br><span class="line">    default:语句块n+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch语句的使用：</p><p>​    每个常量表达式的值必须各不相同，否则将会出现矛盾。</p><p>​    当表达式的值与case后面的常量表达式值相等时，就执行此case后面的语句。</p><p>​    switch中表达式可以是整形、字符型表达式或枚举。</p><p>​    case常量只起语句标号的作用。</p><p>​    break语句用于强行跳出switch体，一般每个case后面应有一个break语句，default分支的break可以省略。</p><p>​    多个case可以执行一组语句。</p><p><img src="/2019/07/19/嵌入式学习/33.png" alt></p><hr><h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p>当函数有很多个出口，使用goto把这些出口集中到一处是很方便的，特别是函数中有许多重复的清理工作的时候。</p><p>原因：</p><ul><li>无条件跳转易于理解</li><li>可以减少嵌套</li><li>可以避免那种忘记更新某一个出口点的问题</li><li>算是帮助编译器做了代码优化</li></ul><p><img src="/2019/07/19/嵌入式学习/34.png" alt></p><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p>基本形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(表达式)&#123;</span><br><span class="line">    statments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/07/19/嵌入式学习/35.png" alt></p><h2 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h2><p>基本形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    statments;</span><br><span class="line">&#125;while(表达式);</span><br></pre></td></tr></table></figure><p><img src="/2019/07/19/嵌入式学习/36.png" alt></p><h2 id="打印出水仙花"><a href="#打印出水仙花" class="headerlink" title="打印出水仙花"></a>打印出水仙花</h2><p><img src="/2019/07/19/嵌入式学习/37.png" alt></p><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p>一般形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(表达式1;表达式2;表达式3)</span><br><span class="line">&#123;statements;&#125;</span><br></pre></td></tr></table></figure><p>执行过程：</p><ol><li>先求解表达式1；</li><li>求解表达式2，若为真，则执行循环体，然后执行表达式3，再判断；若为假，则执行退出。</li></ol><p>for语句构成循环</p><p>​    表达式1可以省略，但循环之前应该给循环变量赋值</p><p>​    表达式2可省略，将陷入死循环</p><p>​    表达式3可以省略，但在循环体中增加是循环变量改变的语句</p><p><img src="/2019/07/19/嵌入式学习/38.png" alt></p><h2 id="for循环99乘法表"><a href="#for循环99乘法表" class="headerlink" title="for循环99乘法表"></a>for循环99乘法表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int j;</span><br><span class="line">for(i=1; i&lt;=9;i++)&#123;</span><br><span class="line">for(j=i;j&lt;=9;j++)&#123;</span><br><span class="line">printf(&quot;%d x %d=%2d  &quot;, i, j, i*j);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/07/19/嵌入式学习/39.png" alt></p><p><img src="/2019/07/19/嵌入式学习/40.png" alt></p><h1 id="辅助控制语句"><a href="#辅助控制语句" class="headerlink" title="辅助控制语句"></a>辅助控制语句</h1><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><p>用于从循环体内跳出循环体，即提前结束循环。</p><p>break语句只能用在循环语句和switch语句中。</p><p><img src="/2019/07/19/嵌入式学习/41.png" alt></p><h2 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h2><p>结束本次循环，接着判定下一次是否执行循环</p><p>continue与break的区别：</p><p>​    continue直结束本次循环，而break终止本层循环</p><p><img src="/2019/07/19/嵌入式学习/42.png" alt></p><h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p>return语句的一般形式：return(表达式)</p><p>主要用于终止包含它的函数的执行</p><p>若终止的为主函数，则程序结束</p><h1 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>​    构造数据类型之一</p><p>​    数组是具有一定顺序关系的若干个变量的集合，组成数组的各个变量称为数组的元素。</p><p>​    数组中各元素的数据类型要求相同，用数组名和下标确定。数组可以是一维的，也可以是多维的。</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>定义：所谓一维数组是指只有一个下标的数组，它在计算机的内存中是连续存储的。</p><p>C语言中，一维数组的说明一般形式：</p><p><code>&lt;存储类型&gt; &lt;数据类型&gt; &lt;数组名&gt; [&lt;表达式&gt;]</code></p><p>数组名表示内存首地址，是地址常量sizeof（数组名）是数组占用的总内村空间；编译时分配连续内存，内存字节数=数组维数*sizeof(元素数据类型)；</p><p><strong>注意事项：</strong></p><p>C语言对数组不作越界检查，使用时要注意</p><p>关于用变量定义数组维数</p><h2 id="一维数组的引用"><a href="#一维数组的引用" class="headerlink" title="一维数组的引用"></a>一维数组的引用</h2><p>​    数组必须先定义，后使用</p><p>​    只能逐个引用数组元素，不能一次引用整个数组</p><p>​    数组元素表示形式：数组名[下标]</p><p>​    其中：下标可以是常量或整型表达式</p><h2 id="一维数组的初始化"><a href="#一维数组的初始化" class="headerlink" title="一维数组的初始化"></a>一维数组的初始化</h2><p>初始化方式：在定义数组时，为数组元素赋初值</p><p>说明：</p><p>​    数组不初始化，其元素值为随机数</p><p>​    对static数组元素不赋初值，系统会自动赋以0值</p><p>​    只给部分数组元素赋初值 </p><h2 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h2><p>定义方式：（声明时列数不能省略，行数可以）</p><p>​    <code>数据类型　数组名[常量表达式][常量表达式]；</code></p><p>元素的个数=行数*列数</p><p>数组元素的存放顺序：</p><p>​    0 :<code>a[0][0]</code></p><p>​    1:<code>a[0][1]</code></p><p>​    2:<code>a[1][0]</code></p><p>​    3:<code>a[1][1]</code></p><p>原因:内存是一维的</p><p>二维数组：按行序优先</p><h2 id="二维数组元素的引用"><a href="#二维数组元素的引用" class="headerlink" title="二维数组元素的引用"></a>二维数组元素的引用</h2><p>形式：<code>数组名[下标][下标]</code></p><p>二维数组元素的初始化</p><p>​    分行初始化</p><p>​    按元素排列顺序初始化</p><hr><p>查找一个三行四列的最大值和行号以及列号<img src="/2019/07/19/嵌入式学习/43.png" alt></p><p>杨辉三角的前10行</p><p><img src="/2019/07/19/嵌入式学习/44.png" alt>t</p><h1 id="字符数组和字符串"><a href="#字符数组和字符串" class="headerlink" title="字符数组和字符串"></a>字符数组和字符串</h1><h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><p>字符数组是元素的数据类型为字符类型的数组</p><p>字符数组</p><p>​    逐个字符赋值</p><p>​    用字符串常量</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>Ｃ语言中无字符串常量，用字符数组处理字符串，字符串结束标志’\0’;</p><h2 id="输入一个字符串，让其逆序输出"><a href="#输入一个字符串，让其逆序输出" class="headerlink" title="输入一个字符串，让其逆序输出"></a>输入一个字符串，让其逆序输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#define N 20</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> char arr[N] = &#123;0&#125;;</span><br><span class="line"> int i, n;</span><br><span class="line"></span><br><span class="line"> printf(&quot;Please input a string:&quot;);</span><br><span class="line"> gets(arr);</span><br><span class="line"> n = sizeof(arr) / sizeof(char);</span><br><span class="line"></span><br><span class="line"> for(i=n-1;i &gt;= 0;i--)&#123;</span><br><span class="line"> putchar(arr[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> putchar(&apos;\n&apos;);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14300434-195c0d6954ad31e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h1><p>C库中实现了很多字符串处理函数</p><p><code>#include&lt;string.h&gt;</code></p><p>几个常见的字符串处理函数</p><p>求字符串长度的函数strlen</p><p>字符串拷贝函数strcpy</p><p>字符串连接函数strcat</p><p>字符串比较函数strcmp</p><h2 id="字符串长度函数strlen"><a href="#字符串长度函数strlen" class="headerlink" title="字符串长度函数strlen"></a>字符串长度函数strlen</h2><p><code>格式：strlen(字符数组)</code></p><p>功能：计算字符串长度</p><p>返值：返回字符串实际长度，不包括’\0’在内</p><p>\xhh表示十六进制数代表的符号</p><p>\ddd表示８进制</p><p><code>n =sizeof(arr) / sizeof(char)</code></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-04b2ad8b02415036.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>区别</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-2b9e06ce8d973478.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="字符串拷贝函数strcpy"><a href="#字符串拷贝函数strcpy" class="headerlink" title="字符串拷贝函数strcpy"></a>字符串拷贝函数strcpy</h2><p><code>格式：strcpy(字符数组１,字符串２)</code></p><p>功能：将字符串２，拷贝到字符数组１中去</p><p>返值：返回字符数组１的首地址</p><p>说明：</p><p>-字符数组１必须足够大</p><p>-拷贝时’\0’一同拷贝</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-5a2ef218c5bfa836.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="字符串连接函数strcat"><a href="#字符串连接函数strcat" class="headerlink" title="字符串连接函数strcat"></a>字符串连接函数strcat</h2><p><code>格式：strcat(字符数组１,字符数组２)</code></p><p>功能：把字符数组２连到字符数组１后面</p><p>返值：返回字符数组１的首地址</p><p>说明：</p><p>-字符数组１必须足够大</p><p>-连接前，两串均以’\0’结束；连接后，串１的’\0’取消，新串最后加’\0’</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-c7890d90b6e1e6b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-f1abf3188e05aab6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-d0acebe0169e240c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="字符串比较函数strcmp"><a href="#字符串比较函数strcmp" class="headerlink" title="字符串比较函数strcmp"></a>字符串比较函数strcmp</h2><p><code>格式：strcmp(字符串１,字符串２)</code></p><p>功能：比较两个字符串</p><p>比较规则：对两串从左向右逐个字符比较（ＡＳＣＩＩ码），直到遇到不同字符或’\0’结束</p><p>返值：返回int型整数</p><p>a. 若字符串１&lt;　字符串２，返回负整数</p><p>b. 若字符串１&gt;　字符串２，返回正整数</p><p>c. 若字符串１== 　字符串２，返回零</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-5213ab56be347b65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-cbf96728863baaf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-45a21250f8641542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strncpy(p,p1,n)　复制指定长度字符串</span><br><span class="line">atrncat(p,p1,n)　附加指定长度字符串</span><br><span class="line">strcasecmp　　忽略大小写比较字符串</span><br><span class="line">strncmp(p,p1,n)　比较指定长度字符串</span><br><span class="line">strchr(p,c)　　在字符串中查找指定字符</span><br><span class="line">strstr(p,p1)　　查找字符串</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14300434-f4f4f41d94c380e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isalpha()　检查是否为字母字符</span><br><span class="line">isupper()　检查是否为大写字母字符</span><br><span class="line">islower()　检查是否为小写字母字符</span><br><span class="line">isdigit()　检查是否为数字</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14300434-97de0afcc6a965ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>Ｃ程序设计中使用指针的作用：</p><p>使程序简洁、紧凑、高效</p><p>有效地表示复杂的数据结构</p><p>动态分配内存</p><p>得到多于一个的函数返回值１</p><p>在Ｃ语言中，内存单元的地址称为指针，专门用来存放地址的变量，称为指针变量</p><h2 id="地址和变量"><a href="#地址和变量" class="headerlink" title="地址和变量"></a>地址和变量</h2><p>在计算机内存中，每一个字节单元，都有一个编号，称为地址。</p><p>变量是对程序中数据存储空间的抽象。</p><h2 id="指针变量的说明"><a href="#指针变量的说明" class="headerlink" title="指针变量的说明"></a>指针变量的说明</h2><p>一般形式：</p><p><code>&lt;存储类型&gt; &lt;数据类型&gt; *&lt;指针变量名&gt;;</code></p><p>指针初始化：指针在说明的同时，也可以被赋予初值，称为指针的初始化。</p><p>指针的存储类型是指针变量本身的存储类型。</p><p>指针说明时指定的数据类型不是指针变量本身的数据类型，而是指针目标的数据类型。简称为指针的数据类型。</p><p>指针指向的内存区域中的数据称为指针的目标</p><p>如果它指向的区域是程序中的一个变量的内存空间，则这个变量称为指针的目标变量（指针的目标）。</p><p>如果ｐ为一个指针，那么它的内容是地址量；*p是指针指向的对象，它的内容是数据；＆p是指针变量占用的存储区域的地址，是个常量。</p><p>指针的赋值运算指的是通过赋值运算符向指针变量送一个地址值</p><p>向一个指针变量赋值时，送的值必须是地址常量或指针变量，不能是普通的整数（除了赋零以外）<br><img src="https://upload-images.jianshu.io/upload_images/14300434-d8ed0f6dd4d84755.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="指针赋值运算常见的有以下几种形式"><a href="#指针赋值运算常见的有以下几种形式" class="headerlink" title="指针赋值运算常见的有以下几种形式"></a>指针赋值运算常见的有以下几种形式</h2><p>把一个普通变量的地址赋给一个具有相同数据类型的指针。</p><p>把一个已有地址值的指针变量赋给具有相同数据类型的另一个指针变量。</p><p>把一个数组的地址赋给具有相同数据类型的指针。</p><h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><p>指针运算是以指针变量所存放的地址量作为运算量的实质就是地址的计算。</p><p>指针运算的实质是地址的计算。</p><p>指针运算的种类是有限的，它只能进行赋值运算】算术运算和关系运算</p><h2 id="指针运算-1"><a href="#指针运算-1" class="headerlink" title="指针运算"></a>指针运算</h2><p>指针的算术运算：</p><table><thead><tr><th>运算符</th><th>计算形式</th><th>意义</th></tr></thead><tbody><tr><td>+</td><td>px+n</td><td>指针向地址大的方向移动ｎ个数据</td></tr><tr><td>-</td><td>px-n</td><td>指针向地址小的方向移动ｎ个数据</td></tr><tr><td>++</td><td>px++</td><td>指针向地址大的方向移动1个数据</td></tr><tr><td>–</td><td>px–</td><td>指针向地址小的方向移动１个数据</td></tr><tr><td>-</td><td>px-py</td><td>两个指针之间相隔数据元素的个数</td></tr></tbody></table><p><strong>注意：</strong></p><p>不同数据类型的两个指针实际加减整数运算是无意义的</p><p>px+n表示的实际位置的地址量是：</p><p>(px) + sizeof(px的类型) *n</p><p>px-n表示的实际位置的地址量是：</p><p>(px) - sizeof(px的类型) *n</p><h2 id="两指针相减运算"><a href="#两指针相减运算" class="headerlink" title="两指针相减运算"></a>两指针相减运算</h2><p>px-py运算的结果是两指针指向的地址位置之间相隔数据的个数，因此两指针相减不是两指针持有地址值相减的结果。</p><p>s两指针相减的结果值不是地址量，而是一个整数值，表示两指针之间相隔数据的个数。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-929a38cb8b3dc3a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="指针的关系运算"><a href="#指针的关系运算" class="headerlink" title="指针的关系运算"></a>指针的关系运算</h2><table><thead><tr><th>运算符</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td><td>px &gt; py</td></tr><tr><td>&lt;</td><td>小于</td><td>px &lt; py</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>px &gt;= py</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>px &lt;= py</td></tr><tr><td>!=</td><td>不等于</td><td>px != py</td></tr><tr><td>==</td><td>等于</td><td>px == py</td></tr></tbody></table><p>两指针之间的关系运算表示它们指向的地址位置之间的关系。指向地址大的指针大于指向地址小的指针。</p><p>指针与一般整数变量之间的关系运算没有意义。但可以和零进行等于或不等于的关系运算，判断指针是否为空。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-b80a632fcd86fb85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="https://upload-images.jianshu.io/upload_images/14300434-0da93dbd12d34c21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><p>在Ｃ语言中，数组的指针是指数组在内存中的起始地址，数组元素的地址是指数组元素在内存中的起始地址</p><p>一维数组的数组名为一维数组的指针（起始地址）</p><p>设置指针变量px的地址值等于数组指针ｘ（即指针变量px指向数组的首元素）</p><p><strong>注意：</strong></p><p>指针变量和数组在访问数组中元素时，一定条件下其使用方法具有相同的形式，因为指针变量和数组名都是地址量；但指针变量和数组的指针（或叫数组名）在本质上不同，指针变量是地址</p><p>变量，而数组的指针是地址常量。</p><h2 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h2><p>多维数组就是具有两个或两个以上下标的数组，在Ｃ语言中，二维数组的元素连续存储，按行优先存</p><p>可以把我二维数组看作由多个一维数组组成</p><p>二维数组名代表数组的起始地址，数组名加１，是移动一行元素。因此，二维数组名常被称为行地址。</p><p>行指针（数组指针）</p><p>存储行地址的指针变量，叫做行指针变量。</p><p><code>&lt;存储类型&gt; &lt;数据类型&gt; (*&lt;指针变量名&gt;)[表达式]</code></p><p>方括号中的常量表达式表示指针加１，移动几个数据。</p><p>当用行指针操作二维数组时，表达式一般写成１行的元素个数，即列数。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-30883f561fc1c893.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="字符指针与字符串"><a href="#字符指针与字符串" class="headerlink" title="字符指针与字符串"></a>字符指针与字符串</h2><p>Ｃ语言通过使用字符数组来处理字符串</p><p>通常，我们把ｃｈａｒ数据类型的指针变量称为字符指针变量。字符指针变量与字符数组有着密切关系，它也被用来处理字符串。</p><p>初始化字符指针是把内存中字符串的首地址赋予指针，并不是把该字符串复制到指针中</p><p>在Ｃ编程中，当一个字符指针指向一个字符串常量时，不能秀爱指针指针指向的对象的值</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-4a3e085b613711ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>练习：不用任何字符串函数，编程实现字符串连接函数的功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> char ch[30] = &quot;hello world&quot;;</span><br><span class="line"> char *q, *p = &quot;hello world&quot;;</span><br><span class="line"> int i = 0;</span><br><span class="line"> q = p;</span><br><span class="line"> while(*(ch+i) != &apos;\0&apos;)&#123;</span><br><span class="line"> i++;</span><br><span class="line"> &#125;</span><br><span class="line"> while(*p != &apos;\0&apos;)&#123;</span><br><span class="line"> *(ch+i) = *p;</span><br><span class="line"> i++;</span><br><span class="line"> p++;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> *(ch+i) = *p;</span><br><span class="line"> p = q;</span><br><span class="line"> puts(ch);</span><br><span class="line"> puts(p);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="https://upload-images.jianshu.io/upload_images/14300434-aea3348a23be5d87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>所谓指针数组是指</p><p>由若干个具有相同存储类型和数据类型的指针变量构成集合</p><p>形式：<code>&lt;存储类型&gt; &lt;数据类型&gt; *&lt;指针数组名&gt;[大小]</code></p><p>指针数组名表示该数组指针数组的起始地址</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-90f47ae01c014b25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-cbceb2faea4c47cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-f8cc70a09aaf5580.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h2><p>多级指针的定义：</p><p>把一个指向指针变量的指针变量，称为多级指针变量</p><p>对于指向处理数据的指针变量称为一级指针变量，简称一级指针，而把指向一级指针变量的指针变量称为二级指针变量，简称二级指针</p><p>二级指针变量的说明形式如下</p><p><code>&lt;存储类型&gt; &lt;数据类型&gt; **&lt;指针名&gt;;</code></p><h2 id="多级指针的运算"><a href="#多级指针的运算" class="headerlink" title="多级指针的运算"></a>多级指针的运算</h2><p>指针变量加１，是向地址大的方向移动一个目标数据。多级指针运算也是以其目标变量为单位进行偏移。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-e29ff5424e181457.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int a[] = &#123;3, 6, 9&#125;;</span><br><span class="line"> int *p[2] = &#123;&amp;a[0], &amp;a[1]&#125;;</span><br><span class="line"> int **q;</span><br><span class="line"> q = p;</span><br><span class="line"> printf(&quot;%d %d\n&quot;, a[0], a[1]);</span><br><span class="line"> printf(&quot;%d %d\n&quot;, *p[0], *p[1]);</span><br><span class="line"> printf(&quot;%d %d %d\n&quot;, a[0], *p[0], **q);</span><br><span class="line"> printf(&quot;%d %d %d\n&quot;, a[1], *p[1], **(q+1));</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-2e06b81ce9d659bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="void-指针"><a href="#void-指针" class="headerlink" title="void 指针"></a>void 指针</h2><p>void指针是一种不确定数据类型的指针变量，它可以通过强制类型转换让该变量指向任何数据类型的变量</p><p>一般形式：<code>void *&lt;指针变量名称&gt;;</code></p><p>对于void指针，在没有强制类型转换之前，不能进行任何指针的算术运算</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-2c713ddbca72ece8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="const变量"><a href="#const变量" class="headerlink" title="const变量"></a>const变量</h2><p>一般形式：<code>const &lt;数据类型&gt; 变量名 = [&lt;表达式&gt;];</code></p><p>常量化变量是为了使得变量的值不能修改</p><p>变量有const修饰时，若想用指针间接访问变量，指针也要有const修饰。</p><p>常量化指针目标是限制通过指针改变其目标的数值，但&lt;指针变量&gt;存储的地址值可以修改</p><h2 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h2><p>形式：<code>const &lt;数据类型&gt; *&lt;指针变量名称&gt;[= &lt;指针运算表达式&gt;]</code></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-52e3fd062496890b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="函数的基本用法"><a href="#函数的基本用法" class="headerlink" title="函数的基本用法"></a>函数的基本用法</h2><p>函数是一个完成特定功能的代码模块，其程序代码独立，通常要求有返回值，也可以是空值。</p><p>一般形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;数据类型&gt; &lt;函数名称&gt;(&lt;形式参数说明&gt;)</span><br><span class="line">&#123;</span><br><span class="line"> 语句序列;</span><br><span class="line"> return[(&lt;表达式&gt;)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&lt;数据类型&gt;是整个函数的返回值类型。return[(&lt;表达式&gt;)]语句中表达式的值，要和函数的&lt;数据类型&gt;保持一致。如无返回值应该写为void型</p><p>&lt;形式参数说明&gt;是逗号”,”分隔的多个变量的说明形式</p><p>大括号对{&lt;语句序列&gt;}，称为函数体；&lt;语句序列&gt;是大于等于零个语句构成的</p><p>函数的说明就是指函数原型，其中&lt;形式参数说明&gt;可以缺省说明的变量名称，但类型不能缺省</p><p>函数的使用也叫函数的调用，形式：</p><p><code>函数名称(&lt;实际参数&gt;)</code>，实参就是在使用函数时，调用函数传递给被调用函数的数据。需要确切的数据</p><p>函数调用可以作为一个运算量出现在表达式中，也可以单独形成一个语句。对于无返回值的函数来讲，只能形成一个函数调用语句。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-51d2d07720397846.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>练习定义求x的ｎ次方值的函数？</p><p>源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">float Caculate(int n, float x)</span><br><span class="line">&#123;</span><br><span class="line"> float s=1;</span><br><span class="line"> int i=0;</span><br><span class="line"> while(i &lt; n)&#123;</span><br><span class="line"> s *=x;</span><br><span class="line"> i++;</span><br><span class="line"> &#125;</span><br><span class="line"> return s;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"> int a;</span><br><span class="line"> float b, s;</span><br><span class="line"> scanf(&quot;%f&quot;, &amp;b);</span><br><span class="line"> scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line"> s = Caculate(a,b);</span><br><span class="line"> printf(&quot;%f\n&quot;, s);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-4f2c7bdbf1d5c656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="C语言控制语句"><a href="#C语言控制语句" class="headerlink" title="C语言控制语句"></a>C语言控制语句</h1><h2 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h2><p>函数之间的参数传递方式：</p><ul><li><p>全局变量</p></li><li><p>复制传递方式</p></li><li><p>地址传递方式</p></li></ul><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>全局变量就是在函数体外说明的变量，在程序中的每个函数里都是可见的</p><p>全局变量一经定以后就会在程序的任何地方可见。函数调用的位置不同，程序的执行结果可能会受到影响。不建议使用。</p><h2 id="复制传递方式"><a href="#复制传递方式" class="headerlink" title="复制传递方式"></a>复制传递方式</h2><p>调用函数将实参传递给被调用函数，被调用函数将创建同类型的形参并用实参初始化</p><p>形参是新开辟的存储空间，因此，在函数中改变形参的值，不会影响到实参</p><h2 id="地址传递方式"><a href="#地址传递方式" class="headerlink" title="地址传递方式"></a>地址传递方式</h2><p>按地址传递，实参为变量的地址，而形参为同类型的指针</p><p>被调用函数中对形参的操作，将直接改变实参的值（被调用函数对指针的目标操作，相当于对实参本身的操作）</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-690ef0d871f0211c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>编写一个函数，统计字符串中小写字母的个数，并把字符串中的小写字母转化成大写字母<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int str_fun(char *p);</span><br><span class="line">int main(int argc, char argv[])</span><br><span class="line">&#123;</span><br><span class="line"> char s[] = &quot;ghjkkh3459hj&quot;;</span><br><span class="line"> int n;</span><br><span class="line"> n = str_fun(s);</span><br><span class="line"> printf(&quot;%d %s\n&quot;, n, s);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line">int str_fun(char *p)</span><br><span class="line">&#123;</span><br><span class="line"> int c = 0;</span><br><span class="line"> while(*p)&#123;</span><br><span class="line"> if(*p &lt;= &apos;z&apos; &amp;&amp; *p &gt;= &apos;a&apos;)&#123;</span><br><span class="line"> c++;</span><br><span class="line"> *p -= 32;</span><br><span class="line"> &#125;</span><br><span class="line"> p++;</span><br><span class="line"> &#125;</span><br><span class="line"> return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-0a153202c4b28709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="数组在函数间传参"><a href="#数组在函数间传参" class="headerlink" title="数组在函数间传参"></a>数组在函数间传参</h2><p>全局数组传递方式</p><p>复制传递方式</p><p>实参为数组的指针，形参为数组名（本质是一个指针变量）</p><p>地址传递方式</p><p>实参为数组的指针，形参为同类型的指针变量</p><h2 id="编写函数，计算一个一维整型数组的所有元素的和"><a href="#编写函数，计算一个一维整型数组的所有元素的和" class="headerlink" title="编写函数，计算一个一维整型数组的所有元素的和"></a>编写函数，计算一个一维整型数组的所有元素的和</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int array_sum(int data[], int n);</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int a[] = &#123;1, 3, 7, 9&#125;;</span><br><span class="line"> int sum = 0;</span><br><span class="line"> int n;</span><br><span class="line"> n = sizeof(a) / sizeof(int);</span><br><span class="line"> sum = array_sum(a, n);</span><br><span class="line"> printf(&quot;%d\n&quot;, sum);</span><br><span class="line"> return 0; </span><br><span class="line">&#125;</span><br><span class="line">int array_sum(int data[], int n)</span><br><span class="line">&#123;</span><br><span class="line"> int ret = 0;</span><br><span class="line"> int i;</span><br><span class="line"> for(i = 0;i &lt; n;i++)&#123;</span><br><span class="line"> ret +=data[i];</span><br><span class="line"> &#125;</span><br><span class="line"> return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-57e8fc1c5aec3129.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="删除字符串中空格"><a href="#删除字符串中空格" class="headerlink" title="删除字符串中空格"></a>删除字符串中空格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void del_space(char *str);</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> char s[] = &quot;h  el       h&quot;;</span><br><span class="line"> puts(s);</span><br><span class="line"> del_space(s);</span><br><span class="line"> puts(s);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void del_space(char *str)</span><br><span class="line">&#123;</span><br><span class="line"> char *s2;</span><br><span class="line"> s2 = str;</span><br><span class="line"> while(*str)&#123;</span><br><span class="line"> if(*str ==&apos; &apos;)&#123;</span><br><span class="line"> str++;</span><br><span class="line"> &#125;</span><br><span class="line"> else&#123;</span><br><span class="line"> *s2 = *str;</span><br><span class="line"> str++;</span><br><span class="line"> s2++;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> *s2 = &apos;\0&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-11b6eb006aaa5536.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h1><p>指针函数是指一个函数的返回值为地址量的函数</p><p>一般形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;数据类型&gt; * &lt;函数名称&gt;(&lt;参数说明&gt;)&#123;</span><br><span class="line"> 语句序列;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回值：全局变量的地址/static变量的地址/字符串常量的地址</p><h2 id="编写一个指针函数删除字符串空格"><a href="#编写一个指针函数删除字符串空格" class="headerlink" title="编写一个指针函数删除字符串空格"></a>编写一个指针函数删除字符串空格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">char *del_space(char *s);</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> char *r; </span><br><span class="line"> char str[] = &quot;how are you &quot;;</span><br><span class="line"> r = del_space(str);</span><br><span class="line"></span><br><span class="line"> puts(str);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char  *del_space(char *s) </span><br><span class="line">&#123;</span><br><span class="line"> char *p = s;</span><br><span class="line"> char *r = s;</span><br><span class="line"></span><br><span class="line"> while(*s)&#123;</span><br><span class="line"> if(*s ==&apos; &apos;)&#123;</span><br><span class="line"> s++;</span><br><span class="line"> &#125; </span><br><span class="line"> else&#123;</span><br><span class="line"> *p = *s; </span><br><span class="line"> s++;</span><br><span class="line"> p++;</span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> *p = &apos;\0&apos;;</span><br><span class="line"> return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-544823fad343254f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="编写一个指针函数，实现字符串连接"><a href="#编写一个指针函数，实现字符串连接" class="headerlink" title="编写一个指针函数，实现字符串连接"></a>编写一个指针函数，实现字符串连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">char *pstrcat(char *dest, const char *src);</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> char dest[30] = &quot;ghhhhhb&quot;;</span><br><span class="line"> char src[] = &quot;ljghg&quot;;</span><br><span class="line"> strcat(dest, src);</span><br><span class="line"> puts(strcat(dest, src));</span><br><span class="line"> puts(dest);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *pstrcat(char *dest, const char *src)</span><br><span class="line">&#123;</span><br><span class="line"> char *r = dest;</span><br><span class="line"> while(*dest)&#123;</span><br><span class="line"> dest++;</span><br><span class="line"> &#125;</span><br><span class="line"> while(*src)&#123;</span><br><span class="line"> *dest = *src;</span><br><span class="line"> dest++;</span><br><span class="line"> src++;</span><br><span class="line"> &#125;</span><br><span class="line"> *dest = &apos;\0&apos;;</span><br><span class="line"> return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-efc97fd61b343cee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="用函数指针来编写将一个整形转换成字符串"><a href="#用函数指针来编写将一个整形转换成字符串" class="headerlink" title="用函数指针来编写将一个整形转换成字符串"></a>用函数指针来编写将一个整形转换成字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">char *itoa(int n);</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int n;</span><br><span class="line"> char *s;</span><br><span class="line"> printf(&quot;input:&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line"> s = itoa(n);</span><br><span class="line"> puts(s);</span><br><span class="line"></span><br><span class="line"> return 0; </span><br><span class="line">&#125;</span><br><span class="line">char *itoa(int n)</span><br><span class="line">&#123;</span><br><span class="line"> int r, i = 0, j;</span><br><span class="line"> static char p[30];</span><br><span class="line"> while(n)&#123;</span><br><span class="line"> r = n % 10;</span><br><span class="line"> n /= 10;</span><br><span class="line"> p[i] = r + &apos;0&apos;;</span><br><span class="line"> i++;</span><br><span class="line"> &#125; </span><br><span class="line"> p[i] = &apos;\0&apos;;</span><br><span class="line"> j = i-1;</span><br><span class="line"> i = 0;</span><br><span class="line"> while(i &lt; j)&#123;</span><br><span class="line"> r = p[i];</span><br><span class="line"> p[i] = p[j];</span><br><span class="line"> p[j] = r;</span><br><span class="line"> i++;</span><br><span class="line"> j--;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-c445862a6ac497f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>递归函数是指一个函数的函数体中直接调用了该函数自身</p><p>递归函数调用的执行过程分为两个阶段：</p><p>递归阶段：从原问题出发，按递归公式递推从未知到已知，最终达到递归终止条件</p><p>回归阶段：按递归终止条件求出结果，逆向逐步代入递归公式，回归原问题求解</p><h2 id="编写一个递归函数n的阶乘"><a href="#编写一个递归函数n的阶乘" class="headerlink" title="编写一个递归函数ｎ的阶乘"></a>编写一个递归函数ｎ的阶乘</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int fun(int n);</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int n;</span><br><span class="line"> int s=0;</span><br><span class="line"></span><br><span class="line"> printf(&quot;Please input n:&quot;);</span><br><span class="line"> scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line"> s = fun(n);</span><br><span class="line"> printf(&quot;%d\n&quot;, s);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line">int fun(int n)</span><br><span class="line">&#123;</span><br><span class="line"> if( n==0 || n==1)&#123;</span><br><span class="line"> return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> return n * fun(n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-c2952957317b07c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="写一个递归函数，计算斐波拉契数列"><a href="#写一个递归函数，计算斐波拉契数列" class="headerlink" title="写一个递归函数，计算斐波拉契数列"></a>写一个递归函数，计算斐波拉契数列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int fun(int n);</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int n = 0;</span><br><span class="line"> while(n &lt;= 10)&#123;</span><br><span class="line"> printf(&quot;%d &quot;, fun(n));</span><br><span class="line"> n++;</span><br><span class="line"> &#125;</span><br><span class="line"> printf(&quot;\n&quot;);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line">int fun(int n)</span><br><span class="line">&#123;</span><br><span class="line"> if( n==0 || n==1)&#123;</span><br><span class="line"> return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> return fun(n-2) + fun(n-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-10a0b715c9b25826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针用来存放函数的地址，这个地址是一个函数的入口地址</p><p>函数名代表了函数的入口地址</p><p>函数指针变变量说明的一般形式如下：</p><p><code>&lt;数据类型&gt; (*&lt;函数指针名称&gt;) (&lt;参数说明列表&gt;);</code></p><p>&lt;数据类型&gt;是函数指针指向的函数的返回值类型</p><p>&lt;参数说明列表&gt;应该与函数指针所指向函数的形参说明保持一致</p><p>(<code>*</code>&lt;函数指针名称&gt;)中，<code>*</code>说明为指针()不可缺省，表明为函数的指针</p><h2 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h2><p>函数指针数组是一个保存若干个函数名的数组</p><p>一般形式：</p><p><code>&lt;数据类型&gt; (*&lt;函数指针数组名称&gt;) [&lt;大小&gt;])(&lt;参数说明列表&gt;)</code></p><h2 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">int compare(const void *, const void *);</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int s[] = &#123;89, 23, 4, 7, 23, 3&#125;;</span><br><span class="line"> int n, i;</span><br><span class="line"> n = sizeof(s) / sizeof(int);</span><br><span class="line"> qsort(s, n, sizeof(int), compare);</span><br><span class="line"> for(i=0;i&lt;n;i++)</span><br><span class="line"> printf(&quot;%d &quot;, s[i]);</span><br><span class="line"> puts(&quot;&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line">int compare(const void *p, const void *q)</span><br><span class="line">&#123; </span><br><span class="line"> return (*(int *)p - *(int *)q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="https://upload-images.jianshu.io/upload_images/14300434-a8ae416e4e7f23f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="unix的起源"><a href="#unix的起源" class="headerlink" title="unix的起源"></a>unix的起源</h2><p>1969年，由KenThompson在AT&amp;T贝尔实验室发现的。使用的是汇编语言。</p><p>1970年，KenThompson和DennisRitchie使用Ｃ语言对整个系统进行加工和编写，使得Unix能够很容易的移植到其他硬件的计算机上。</p><h2 id="GNU-amp-GPL"><a href="#GNU-amp-GPL" class="headerlink" title="GNU&amp;GPL"></a>GNU&amp;GPL</h2><p>GNU由Richard Stallman在１９８４年创建</p><p>GPL:General Public License</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>LInux是一种操作系统</p><p>1991年，芬兰赫尔幸基大学的学生Linus Torvals 为了能在家里的PC机上使用与学校一样的操作系统，开始编写了类UNIX。</p><h2 id="Linux发行版本"><a href="#Linux发行版本" class="headerlink" title="Linux发行版本"></a>Linux发行版本</h2><p>Solaris,debian,redhat,ubuntu,SUSE,deepin等多个版本。deepin是国产深度操作系统。在国内用做服务器的大部分是redhat,centos,桌面版多半是ubuntu,零基础推荐深度系统（deepin）。</p><h2 id="Linux体系结构"><a href="#Linux体系结构" class="headerlink" title="Linux体系结构"></a>Linux体系结构</h2><p>Linux操作系统的组件</p><ul><li><p>Linux内核</p></li><li><p>Shell</p></li><li><p>文件系统</p></li><li><p>实用程序</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14300434-7a433fbe4b751e54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br><img src="https://upload-images.jianshu.io/upload_images/14300434-135141390a686d42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="选择命令终端窗口"><a href="#选择命令终端窗口" class="headerlink" title="选择命令终端窗口"></a>选择命令终端窗口</h2><p>目前，在桌面环境下的命令终端仿真器程序有很多，它们各有特色，都拥有各自的用户群。目前流行的终端窗口有：Xterm、Gnome-terminal、Konsole、Rxvt等。</p><p>Ubuntu默认安装的命令终端有Gnome-terminal、Xterm。</p><h2 id="流行的两种软件包管理机制"><a href="#流行的两种软件包管理机制" class="headerlink" title="流行的两种软件包管理机制"></a>流行的两种软件包管理机制</h2><p>Debian Linux首先提出的“软件包”的管理机制———Deb软件包</p><p>将用用程序的二进制文件、配置文档、main/info帮助页面等文件合并打包在一个文件中，用户使用软件包管理器直接操作软件包，完成获取、安装、卸载、查询等操作。</p><p>Redhat Linux基于这个理念推出了自己的软件包管理机制———Rpm软件包</p><p>随着Linux操作系统规模的不断扩大，系统中软件包间复杂的依赖关系，导致Linux用户麻烦不断。</p><p>Debian Linux开发出了APT软件管理器</p><ul><li><p>检查和修复软件包依赖关系</p></li><li><p>利用Internet网络帮助用户主动获取软件包</p></li></ul><p>APT工具再次促进了Deb软件包更为广泛地使用，成为Debian Linux的亮点。</p><h2 id="软件包类型"><a href="#软件包类型" class="headerlink" title="软件包类型"></a>软件包类型</h2><p>ubuntu有两种类型的软件包：</p><ul><li><p>二进制软件包（deb）</p></li><li><p>源码包（deb-src）</p></li></ul><p>二进制软件包：它包含可执行文件、库文件、配置文件、man/info页面、版权声明和其它文档。</p><p>源码包：包含软件源代码、版本修改说明、构建指令以及编译工具等。先由tar工具归档为.tar.gz文件，然后再打包成.dsc文件。</p><p>在linux上无法根据后缀名来判断文件类型，使用file命令查看文件类型。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-4f0ad98c02f75e8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="软件包的命名"><a href="#软件包的命名" class="headerlink" title="软件包的命名"></a>软件包的命名</h2><p><code>Filename_Version-Reversion_Architecture.deb</code></p><p><code>软件包名称_软件版本-修改版本_体系架构</code></p><h2 id="dpkg命令"><a href="#dpkg命令" class="headerlink" title="dpkg命令"></a>dpkg命令</h2><p><code>dpkg -i 软件包名称.deb</code></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-i</td><td>安装一个在本地文件系统上存在的Debian软件包</td></tr><tr><td>-r</td><td>移除一个已经安装的软件包</td></tr><tr><td>-P</td><td>移除已安装软件包及配置文件</td></tr><tr><td>-L</td><td>列出安装的软件包清单</td></tr><tr><td>-s</td><td>显示软件包的安装状态</td></tr></tbody></table><p><img src="https://upload-images.jianshu.io/upload_images/14300434-c66ea284121fb8a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="APT工作原理"><a href="#APT工作原理" class="headerlink" title="APT工作原理"></a>APT工作原理</h2><p>Ubuntu采用集中式的软件仓库机制，将各式各样的软件包分门别类地存放在软件仓库中，进行有效地组织和管理。然后，将软件仓库置于许多的镜像服务器中，并保持基本一致。镜像服务器就是用户软件园(reposity)。</p><p>在ubuntu系统中，使用软件源配置文件/etc/apt/sources.list列出最合适访问的镜像站点地址。</p><p>软件源配置文件只是告知ubuntu系统可以访问的镜像站点地址。但那些镜像站点拥有什么软件源并不清楚。为这些软件资源列一个清单（建立索引文件），以便本地主机查询。这就是APT软件包管理器的工作原理。</p><h2 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h2><p>根据软件包的开发组织对该软件的支持程度，以及遵从的开源程度，划分为四类：</p><ul><li><p>核心：官方维护的开源软件</p></li><li><p>公共：社区维护的开源文件</p></li><li><p>受限：官方维护的非开源文件</p></li><li><p>多元化：非官方维护的非开源软件</p></li></ul><h2 id="刷新软件源"><a href="#刷新软件源" class="headerlink" title="刷新软件源"></a>刷新软件源</h2><p>修改了配置文件——/etc/apt/sources.list,目的只是告知软件源镜像站点的地址。但那些所指向的镜像站点所具有的软件资源并不清楚，需要将这些资源列个清单，以便本地主机知晓可以申请哪些资源。</p><p>使用”apt-get update”命令会扫面每个软件源服务器，并为该服务器所具有软件包资源建立索引文件，存放在本地的/var/lib/apt/lists/目录中。</p><table><thead><tr><th>子命令</th><th>描述</th></tr></thead><tbody><tr><td>update</td><td>下载更新软件包列表信息</td></tr><tr><td>upgrade</td><td>将系统中所有软件包升级到最新的版本</td></tr><tr><td>install</td><td>下载所需软件包并进行安装配置</td></tr><tr><td>remove</td><td>卸载软件包</td></tr><tr><td>autoremove</td><td>将不满足依赖关系的软件包自动卸载</td></tr><tr><td>source</td><td>下载源码包</td></tr><tr><td>build-dep</td><td>为源码包构建所需的编译环境</td></tr><tr><td>dist-upgrade</td><td>发布版升级</td></tr><tr><td>clean</td><td>删除缓存区中所有已下载的包文件</td></tr></tbody></table><h2 id="修复软件包依赖关系"><a href="#修复软件包依赖关系" class="headerlink" title="修复软件包依赖关系"></a>修复软件包依赖关系</h2><p>由于故障而中断软件安装过程，可能会造成关联的软件只有部分安装之后，用户就会发现该软件既不能重装又不能删除。</p><p><code>apt-get check</code>检查软件包依赖关系</p><p><code>apt-get -f install</code>修复依赖关系</p><p>在处理依赖关系上，apt-get会自动下载并安装具有依赖关系的软件包，但不会处理与安装软件包存在推荐和建议关系的软件包。</p><h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><p>使用<code>#apt-get install</code>下载软件包分为四步：在使用时无需考虑软件包的版本、优先级、依赖关系等。</p><ol><li><p>扫描本地存放的软件包更新列表　　<code>#apt-get update</code></p></li><li><p>进行软件包依赖关系检查，找到支持该软件正常运行的所有软件包</p></li><li><p>从软件源所指的镜像站点中下载相关软件包</p></li><li><p>解压软件包，并自动完成应用程序的安装和配置</p></li></ol><h2 id="重新安装软件包"><a href="#重新安装软件包" class="headerlink" title="重新安装软件包"></a>重新安装软件包</h2><p><code>#apt-get install 软件包名称 --reinstall</code></p><h2 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h2><p>不完全卸载</p><p><code>apt-get remove 软件包名称</code>会关注那些与被删除的软件包相关的其他软件包，删除一个软件包时，将会连带删除与该软件包有依赖关系的软件包。</p><p>完全卸载</p><p><code>apt-get --purge remove 软件包名称</code>命令在卸载软件包的同时，还删除该软件包所使用的配置文件。</p><h2 id="查询软件包描述信息"><a href="#查询软件包描述信息" class="headerlink" title="查询软件包描述信息"></a>查询软件包描述信息</h2><p>使用<code>#apt-cache show 软件包名称</code>命令获取指定软件包的详细信息，包括软件包安装状态、优先级、适用架构、版本、存在依赖关系的软件包，以及功能描述。该命令可以同时显现多个软件包的详细信息。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-78f75c604a418585.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="获取软件包安装状态"><a href="#获取软件包安装状态" class="headerlink" title="获取软件包安装状态"></a>获取软件包安装状态</h2><p>使用“apt-cache policy 软件包名称”可以获取软件包当前的安装状态</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-03b256aa89fdf006.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h2><p>英文单词shell可直译为“贝壳”。“贝壳”是动物作为外在保护的一种工具。Linux中的shell就是Linux内核的一个外层保护工具，并负责完成用户与内核之间的交互。<br><img src="https://upload-images.jianshu.io/upload_images/14300434-0b403bd3bb508612.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>命令是用户向系统内核发出控制请求，与之交互的文本流。</p><p>shell是一个命令行解释器，将用户命令解析为操作系统所能理解的指令，实现用户与操作系统的交互。</p><p>当需要重复执行若干命令，可以将这些命令集合起来，加入一定的控制语句，编辑成为shell脚本文件，交给shell批量执行。</p><h2 id="选择shell"><a href="#选择shell" class="headerlink" title="选择shell"></a>选择shell</h2><p>目前流行的shell主要有几种：</p><ul><li><p>Bourne Shell（简称sh）</p></li><li><p>C Shell（简称csh）</p></li><li><p>Korn Shell（简称ksh）</p></li><li><p>Bourne Again Shell：能够提供环境变量以配置用户shell环境，支持历史记录，内置算术功能，支持通配符表达式，将常用命令内置简化。</p></li></ul><h2 id="shell命令格式"><a href="#shell命令格式" class="headerlink" title="shell命令格式"></a>shell命令格式</h2><p><code>username@hostname:direction$</code></p><p>username：用户名，显示当前登录用户的账户名；</p><p>hostname：主机名，显示登录主机名；</p><p>direction：目录名，显示当前所处的路径，当在根目录下显示”/“，当前在用户主目录下显示为“~”；</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-f30ccd6a165ab18e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>一条命令的三要素之间用空格隔开；</p><p>若将多个命令在一行书写，用分号（;）将命令隔开；</p><p>如果一条命令不能在一行书写完，在行尾使用反斜杠（\）标明该条命令结束；</p><h2 id="使用Tab键补全命令"><a href="#使用Tab键补全命令" class="headerlink" title="使用Tab键补全命令"></a>使用Tab键补全命令</h2><h2 id="查询命令历史"><a href="#查询命令历史" class="headerlink" title="查询命令历史"></a>查询命令历史</h2><p><code>history [numberline]</code></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-0c2f3d07bdc52764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>显然history只能记录有限条的历史命令，默认保留500条命令</p><p>Bash Shell 将历史命令容量保存在环境变量HISTSIZE中。</p><p><code>echo $HISTSIZE</code>显示历史命令容量</p><p><code>HISTSIZE=number</code>修改历史命令容量</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-6f5af2fbee98c62b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>当需要命令处理一组文件，用户不必一一输入文件名，可以使用shell通配符。</p><table><thead><tr><th>通配符</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>*</td><td>匹配任意长度的字符串</td><td>1*.txt代表12.txt,1344.txt等</td></tr><tr><td>？</td><td>匹配一个长度的字符</td><td>1?.txt代表12.txt ,13.txt等</td></tr><tr><td>[…]</td><td>匹配其中指定的一个字符</td><td>1[ort].txt代表1o.txt,1r.txt,1t.txt</td></tr><tr><td>[-]</td><td>匹配指定的一个字符范围</td><td>1[a-z].txt代表1a.txt,1b.txt到1z.txt</td></tr><tr><td>[^…]</td><td>除了其中指定的字符，均可匹配</td><td><code>1[^otr].txt</code>除了1r.txt,1o.txt,1t.txt外</td></tr></tbody></table><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道可以把一系列命令连接起来，意味着第一个命令的输出将作为第二个命令的输入，通过管道传递给第二个命令，第二个命令的输出又将作为第三个命令的输入，以此类推。就像通过使用“|”符连成一个管道。</p><h2 id="输入-输出重定向"><a href="#输入-输出重定向" class="headerlink" title="输入/输出重定向"></a>输入/输出重定向</h2><p>输入/输出重定向是改变shell命令或程序的标准输入/输出目标，重新定向到新的目标。</p><p>linux中默认的标准输入定义为键盘，标准输出定义为终端窗口。</p><p>用户可以为当前操作改变输入或输出，迫使某个特定命令的输入或输出来源为外部文件。</p><table><thead><tr><th>重定向符</th><th>含义</th></tr></thead><tbody><tr><td>&gt;file</td><td>将file文件重定向为输出源，新建模式</td></tr><tr><td>&gt;&gt;file</td><td>将file文件重定向为输出源，追加模式</td></tr><tr><td>&lt;file</td><td>将file文件重定向为输入源</td></tr><tr><td>2&gt;/&amp;&gt;</td><td>将由命令产生的错误信息输入到文件中</td></tr></tbody></table><h2 id="命令置换"><a href="#命令置换" class="headerlink" title="命令置换"></a>命令置换</h2><p>命令置换是将一个命令的输出作为另一个命令的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 `command2`</span><br></pre></td></tr></table></figure></p><p>其中，命令２的输出将作为命令１的参数。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-07307d31b5edf266.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>echo命令用于在标准输出———显示器上显示一段文字，一般起到提示作用。echo命令的一般语法格式：<code>echo [-n] information</code></p><p>选项-n表示输出文字后不换行。提示信息字符串可以加引号，也可以不加。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-1d60e561c09e5712.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="etc-passwd文件"><a href="#etc-passwd文件" class="headerlink" title="/etc/passwd文件"></a>/etc/passwd文件</h2><p>/etc/passwd文件是系统能够识别的用户清单。当用户登录时，系统查询这个文件，确定用户的  UID并验证用户口令</p><h2 id="etc-group文件"><a href="#etc-group文件" class="headerlink" title="/etc/group文件"></a>/etc/group文件</h2><p>包含了UNIX组的名称和每个组中成员列表</p><p>每一行代表一个组，包含４个字段；</p><h2 id="adduser配置文件"><a href="#adduser配置文件" class="headerlink" title="adduser配置文件"></a>adduser配置文件</h2><p>/etc/adduser.conf</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-ac4b4fdb7f872ec1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><p>将所有行程以树状图显示，树状图将会以pid（如果有指定）或是以init这个基本进程为根，如果有指定使用者id，则树状图会只显示该使用者所拥有的进程。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-9782040f5af1cb7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="文件系统类型"><a href="#文件系统类型" class="headerlink" title="文件系统类型"></a>文件系统类型</h2><p>磁盘文件类型：指本地主机中实际可以访问到的文件系统</p><p>网络文件系统：是可以远程访问的文件系统</p><p>专有/虚拟文件系统：不驻留在磁盘上的文件系统</p><p>目前Ext4是Linux系统广泛使用的一种文件格式。在Ext3基础上，对有效性保护、数据完整性、数据访问速度、向下兼容性等方面做了改进。</p><p>最大特点是日志文件系统：可将整个磁盘的写入动作完整地记录在磁盘的某个区域上，以便在必要时回溯追踪。</p><h2 id="SCSI与IDE设备命名"><a href="#SCSI与IDE设备命名" class="headerlink" title="SCSI与IDE设备命名"></a>SCSI与IDE设备命名</h2><p>sata硬盘的设备名称是“/dev/sda”</p><p>IDE硬盘的设备名称是“/dev/hda”</p><p>如果很在意系统的高性能和稳定性，应该使用SCSI硬盘</p><h2 id="Linux分区的命名方式"><a href="#Linux分区的命名方式" class="headerlink" title="Linux分区的命名方式"></a>Linux分区的命名方式</h2><p>字母和数字相结合</p><p>前两个字母表示设备类型</p><ul><li><p>hd 代表IDE硬盘</p></li><li><p>sd 代表SCSI或SATA硬盘</p></li></ul><p>第三个字母说明具体的设备</p><p>ａ表示第一个硬盘</p><p>ｂ表示第二个硬盘<br><img src="https://upload-images.jianshu.io/upload_images/14300434-242c9b8bde9a3989.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a>交换分区</h2><p>将内存中的内容写入硬盘或从硬盘中读出，称为内存交换</p><p>交换分区最小必须等于计算机的内存</p><p>可以创建多于一个的交换分区</p><p>尽量把交换分区放在硬盘分区的起始位置</p><h2 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h2><p>硬链接：是利用Linux中为每个文件分配的物理编号————inode建立链接。因此，硬链接不能跨越文件系统</p><p>软链接：是利用文件的路径名建立链接。通常建立软链接使用绝对路径而不是相对路径，以最大限度增加可移植性。</p><p>需要注意的是，如果是修改硬链接的目标文件名，链接依然有效；如果修改软链接的目标文件名，则链接将断开；对于一个已存在的链接文件执行移动或删除操作，有可能导致链接的断开。假如删除目标文件后，重新创建一个同名文件，软链接将恢复，硬链接不再有效，因为文件的inode已经改变。</p><h2 id="配置IP地址"><a href="#配置IP地址" class="headerlink" title="配置IP地址"></a>配置IP地址</h2><p>配置IP地址的方法有两种：</p><ul><li><p>配置静态IP：在主机进入网络之前，事先为主机设置固定的IP地址；</p></li><li><p>配置动态IP：选择DHCP网络服务，在主机进入网络之后，动态随机获取IP地址。</p></li></ul><h2 id="动态IP地址获取"><a href="#动态IP地址获取" class="headerlink" title="动态IP地址获取"></a>动态IP地址获取</h2><p><code>sudo dhclient</code></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-c2158d7e545db60d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="动态IP的获取过程"><a href="#动态IP的获取过程" class="headerlink" title="动态IP的获取过程"></a>动态IP的获取过程</h2><ul><li><p>客户端寻找DHCP服务器</p></li><li><p>服务器提供可分配的IP地址</p></li><li><p>客户端接受IP地址租借</p></li><li><p>服务器确认租借IP</p></li></ul><h2 id="网络重启"><a href="#网络重启" class="headerlink" title="网络重启"></a>网络重启</h2><p><code>sudo /etc/init.d/networking restart</code></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-16c2e32c3a836343.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="IP地址存放地点"><a href="#IP地址存放地点" class="headerlink" title="IP地址存放地点"></a>IP地址存放地点</h2><p>interfaces配置文件：/etc/network/interfaces</p><h2 id="DNS客户端配置文件"><a href="#DNS客户端配置文件" class="headerlink" title="DNS客户端配置文件"></a>DNS客户端配置文件</h2><p>resolv.conf配置文件：/etc/resolv.conf中<br><img src="https://upload-images.jianshu.io/upload_images/14300434-64b02c27ba3cfdbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="shell脚本的本质"><a href="#shell脚本的本质" class="headerlink" title="shell脚本的本质"></a>shell脚本的本质</h2><p>shell脚本语言是解释型语言</p><p>shell脚本的本质：shell命令的有序集合</p><h2 id="shell编程的基本过程"><a href="#shell编程的基本过程" class="headerlink" title="shell编程的基本过程"></a>shell编程的基本过程</h2><ol><li><p>建立shell文件——包含任意多行操作系统命令或shell命令的文本文件；</p></li><li><p>赋予shell文件执行权限——用chmod命令修改权限；</p></li><li><p>执行shell文件——直接在命令行上调用shell程序；</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/14300434-20ae39674dc608e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><p>shell允许用户建立变量存储数据，但不支持数据类型（整形、字符、浮点型），将任何赋给变量的值都解释为一串字符</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-5ed39ba130fbb972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>Bourne Shell有如下四种变量：</p><ul><li><p>用户自定义变量</p></li><li><p>位置变量即命令行参数</p></li><li><p>预定义变量</p></li><li><p>环境变量</p></li></ul><h2 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h2><p>在shell编程中通常使用全大写变量，方便识别</p><p><code>$COUNT=1</code></p><p>变量调用：在变量前加$</p><p><code>$echo $HOME</code></p><p>使用unset命令删除变量的赋值</p><p><code>$unset COUNT</code></p><h2 id="shell程序和语句"><a href="#shell程序和语句" class="headerlink" title="shell程序和语句"></a>shell程序和语句</h2><p>shell程序由零或多条shell语句构成。shell语句包括三大类：说明性语句、功能性语句和结构性语句</p><p>说明性语句：以＃号开始到该行结束，不被解释执行</p><p>功能性语句：任意shell命令、用户程序或其它shell程序</p><p>结构性语句：条件测试语句、多路分支语句、循环语句、循环控制语句等</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-b748d7559babf59d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h2><p>算术运算命令expr主要用于进行简单的整数运算，包括加＋、减－、乘<code>\*</code>、除/、求模％等操作。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-0f186b5a709984f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="test语句"><a href="#test语句" class="headerlink" title="test语句"></a>test语句</h2><p>test语句可测试三种对象：字符串　整数　文件属性</p><p>每种测试对象都有若干测试操作符</p><h2 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h2><table><thead><tr><th>s1 = s2</th><th>测试两个字符串的内容是否完全一样</th></tr></thead><tbody><tr><td>s1 != s2</td><td>测试两个字符串的内容是否有差异</td></tr><tr><td>-z s1</td><td>测试s1字符串的长度是否为０</td></tr><tr><td>-n s1</td><td>测试s1字符串的长度是否不为0</td></tr></tbody></table><h2 id="整数测试"><a href="#整数测试" class="headerlink" title="整数测试"></a>整数测试</h2><table><thead><tr><th>a -eq b</th><th>测试ａ与ｂ是否相等</th></tr></thead><tbody><tr><td>a -ne b</td><td>测试ａ与ｂ是否不相等</td></tr><tr><td>a -gt b</td><td>测试ａ是否大于ｂ</td></tr><tr><td>a -ge b</td><td>测试ａ是否大于等于ｂ</td></tr><tr><td>a -lt b</td><td>测试ａ是否小于ｂ</td></tr><tr><td>a -le b</td><td>测试ａ是否小于等于ｂ</td></tr></tbody></table><h2 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h2><table><thead><tr><th>-d name</th><th>测试name是否为一个目录</th></tr></thead><tbody><tr><td>-e name</td><td>测试一个文件是否存在</td></tr><tr><td>-f name</td><td>测试name是否为普通文件</td></tr><tr><td>-L name</td><td>测试name是否为符号链接</td></tr><tr><td>-r name</td><td>测试name文件是否存在且为可读</td></tr><tr><td>-w name</td><td>测试name文件是否存在且为可写</td></tr><tr><td>-x name</td><td>测试name文件是否存在且为可执行</td></tr><tr><td>-s name</td><td>测试name文件是否存在且其长度不为０</td></tr><tr><td>f1 -nt f2</td><td>测试文件f1是否比文件f2更新</td></tr><tr><td>f1 -ot f2</td><td>测试文件f1是否比文件f2更旧</td></tr></tbody></table><p><img src="https://upload-images.jianshu.io/upload_images/14300434-22c35cc468d5a78d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-77b76e08d5078bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="结构性语句"><a href="#结构性语句" class="headerlink" title="结构性语句"></a>结构性语句</h2><p>结构性语句主要根据程序的运行状态、输入数据、变量的取值、控制信号以及运行时间等因素来控制程序的运行流程。</p><p>主要包括：条件测试语句、多路分支语句、循环语句、循环控制语句和后台执行语句等。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if         [ 表达式]</span><br><span class="line"> then     命令表</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>如果表达式为真，则执行命令表中的命令；否则执行fi后面的语句。if和fi是条件语句的括号语句，必须成对使用；命令表中的命令可以是一条，也可以是多条。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-29064abade861589.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if　表达式</span><br><span class="line">then  命令表１</span><br><span class="line">else    命令表２</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>如果表达式为真，则执行命令表１中的命令，再退出if语句；否则执行命令表２中的语句，再退出if语句。</p><h2 id="多路分支语句"><a href="#多路分支语句" class="headerlink" title="多路分支语句"></a>多路分支语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case　字符串变量　in</span><br><span class="line"> 模式１)</span><br><span class="line"> 命令表１</span><br><span class="line"> ;;</span><br><span class="line"> 模式２ | 模式３)</span><br><span class="line"> 命令表２</span><br><span class="line"> ;;</span><br><span class="line"> .......</span><br><span class="line"> 模式n)</span><br><span class="line"> 命令表n</span><br><span class="line"> ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14300434-2a1de53636e7ff1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="编写一个shell脚本来判断成绩的等级"><a href="#编写一个shell脚本来判断成绩的等级" class="headerlink" title="编写一个shell脚本来判断成绩的等级"></a>编写一个shell脚本来判断成绩的等级</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo -n &quot;Please input score:&quot;</span><br><span class="line">read S</span><br><span class="line">if [ $S -lt 0 -o $S -gt 100 ]</span><br><span class="line">then</span><br><span class="line"> echo &quot;not in [0-100]&quot;</span><br><span class="line"> exit</span><br><span class="line">fi</span><br><span class="line">G=`expr $S / 10`</span><br><span class="line">case $G in</span><br><span class="line"> 9|10)</span><br><span class="line"> echo &quot;$S A&quot;</span><br><span class="line"> ;;</span><br><span class="line"> 6|7|8)</span><br><span class="line"> echo &quot;$S B&quot;</span><br><span class="line"> ;;</span><br><span class="line"> *)</span><br><span class="line"> echo &quot;$S C&quot;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-03f1b4cbc3677080.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="循环语句for"><a href="#循环语句for" class="headerlink" title="循环语句for"></a>循环语句for</h2><p>当循环次数已知或确定时，使用for循环语句来多次执行一条或一组命令。循环体由语句括号do和done来限定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for　　变量名　　in　　单词表</span><br><span class="line">do</span><br><span class="line"> 命令表</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>变量依次取单词表中的各个单词，每取一次单词，就执行一次循环体中的命令，循环次数由单词表中的单词数确定。命令表中的命令可以是一条，也可以是由分号或换行符分开的多条。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">sum=0</span><br><span class="line">for i in `seq 1 100`</span><br><span class="line">do</span><br><span class="line"> sum=`expr $sum + $i`</span><br><span class="line">done</span><br><span class="line">echo $sum</span><br><span class="line"></span><br><span class="line">for ((i=1;i&lt;=10;i++))</span><br><span class="line">do</span><br><span class="line"> echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-ccc2973b4b5a3013.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while　　命令或表达式</span><br><span class="line">do</span><br><span class="line"> 命令表</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>while语句首先测试其后的命令或表达式的值，如果为真，就执行一次循环体中的命令，然后再测试该命令或表达式的值，执行循环体，直到该命令或表达式为假时退出循环。</p><p>while语句的退出状态为命令表中被执行的最后一条命令的退出状态。</p><h2 id="shell函数调用"><a href="#shell函数调用" class="headerlink" title="shell函数调用"></a>shell函数调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value_name=`function_name [arg1 arg2 ... ]`</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function_name [arg1 arg2 .. ]</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure><p>函数变量作用域</p><p>全局作用域：在脚本的其他任何地方都能够访问该变量</p><p>局部作用域：只能在声明变量的作用域内访问。</p><p>声明局部变量的格式：</p><p><code>Local variable_name =value</code></p><h2 id="GNU工具"><a href="#GNU工具" class="headerlink" title="GNU工具"></a>GNU工具</h2><p>编译工具：把一个源程序编译为一个可执行程序</p><p>调试工具：能对执行程序进行源码或汇编级调试</p><p>软件工程工具：用于协助多人开发或大型软件项目的管理</p><p>其他工具：用于把多个目标文件链接成可执行文件的链接器，或者用作格式转换的工具</p><h2 id="GCC简介"><a href="#GCC简介" class="headerlink" title="GCC简介"></a>GCC简介</h2><p>全称为GNU CC,GNU项目中符合ANSI C标准的编译系统</p><p>编译如C、C++、Object C、Java、Fortran、Pascal、Modula-3和Ada等多种语言</p><p>GCC是可以在多种硬体平台上编译出可执行程序的超级编译器，其执行效率与一般的编译器相比平均效率要高20%~30%</p><p>一个交叉平台编译器，适合在嵌入式领域的开发编译</p><h2 id="编译器的主要组件"><a href="#编译器的主要组件" class="headerlink" title="编译器的主要组件"></a>编译器的主要组件</h2><p>分析器</p><p>汇编器</p><p>链接器</p><p>标准C库</p><h2 id="GCC的基本用法和选项"><a href="#GCC的基本用法和选项" class="headerlink" title="GCC的基本用法和选项"></a>GCC的基本用法和选项</h2><table><thead><tr><th>-c</th><th>只编译，不连接成为可执行文件.c到.o</th></tr></thead><tbody><tr><td>-o</td><td>确定输出文件的名称</td></tr><tr><td>-g</td><td>产生符号调试工具（gdb）</td></tr><tr><td>-O</td><td>对程序进行优化编译、连接</td></tr><tr><td>-O2</td><td>比-o更好的优化编译、连接</td></tr><tr><td>-I dirname</td><td>将dirname所指出的目录加入到程序头文件目录列表中，是在预编译过程中使用的参数</td></tr><tr><td>-L dirname</td><td>将dirname所指出的目录加入到程序函数档案库文件的目录列表中，是在链接过程中使用的参数。</td></tr></tbody></table><h2 id="GCC的错误"><a href="#GCC的错误" class="headerlink" title="GCC的错误"></a>GCC的错误</h2><ol><li><p>语法错误（syntex error）</p></li><li><p>头文件错误（Can no find include file head.h）</p></li><li><p>档案库错误（ld: -lm: No such file or directory）</p></li><li><p>未定义符号（Undefined symbol）</p></li></ol><h2 id="GCC编译过程"><a href="#GCC编译过程" class="headerlink" title="GCC编译过程"></a>GCC编译过程</h2><ol><li><p>预处理（Pre-Processing）</p></li><li><p>编译（Compiling）</p></li><li><p>汇编（Assembling）</p></li><li><p>链接（Linking）</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/14300434-7ade2aac04d5cf05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-0020d51961e20fae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="生成预处理代码"><a href="#生成预处理代码" class="headerlink" title="生成预处理代码"></a>生成预处理代码</h2><p><code>$gcc -E test.c -o test.i</code></p><h2 id="生成汇编代码"><a href="#生成汇编代码" class="headerlink" title="生成汇编代码"></a>生成汇编代码</h2><p><code>$gcc -S test.i -o test.s</code></p><h2 id="生成目标代码"><a href="#生成目标代码" class="headerlink" title="生成目标代码"></a>生成目标代码</h2><p><code>$gcc -c test.s -o test.o</code></p><p><code>$as test.s -o test.o</code></p><h2 id="生成可执行程序"><a href="#生成可执行程序" class="headerlink" title="生成可执行程序"></a>生成可执行程序</h2><p>将目标程序链接库资源，生成可执行程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc test.s -o test</span><br><span class="line">./test</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-17f056635958024f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="调试器——gdb"><a href="#调试器——gdb" class="headerlink" title="调试器——gdb"></a>调试器——gdb</h2><p>首先使用gcc对test.c进行编译，注意一定要加选项‘-g’</p><p><code>$gcc -g test.c -o test</code></p><p><code>gdb test</code></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-bc5bed8506214121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><table><thead><tr><th>(gdb) l</th><th>查看文件</th></tr></thead><tbody><tr><td>(gdb) b 6</td><td>设置断点</td></tr><tr><td>(gdb) info b</td><td>查看断点情况</td></tr><tr><td>(gdb) r</td><td>运行代码</td></tr><tr><td>(gdb) p n</td><td>查看变量值</td></tr><tr><td>(gdb) n /(gdb) s</td><td>单步运行</td></tr><tr><td>(gdb) c</td><td>恢复程序运行</td></tr><tr><td>(gdb) help [command]</td><td>帮助</td></tr></tbody></table><h2 id="Gdb的使用切记点"><a href="#Gdb的使用切记点" class="headerlink" title="Gdb的使用切记点"></a>Gdb的使用切记点</h2><p>在gcc编译选项中一定要加入’-g’</p><p>只有在代码处于“运行”或“暂停”状态时才能查看变量值</p><p>设置断点后程序在指定行之前停止</p><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>编译器根据条件真假决定是否编译相关的代码</p><p>常见的条件编译有两种方法</p><ul><li><p>根据宏是否定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef &lt;macro&gt;</span><br><span class="line">......</span><br><span class="line">#else</span><br><span class="line">......</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li><li><p>根据宏的值</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if &lt;macro&gt;</span><br><span class="line">......</span><br><span class="line">#else</span><br><span class="line">......</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14300434-49da35dcefac2666.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>在实际的处理对象中，有许多信息是由多个不同类型的数据组合在一起进行描述，而且这些不同类型的数据是互相联系组成了一个有机的整体。此时，就要用到一种新的构造类型数据——结构体（structure），简称结构。</p><p>结构体的使用为处理复杂数据结构（如动态数据结构）提供了有效手段，而且，它们为函数间传递不同类型的数据提供了方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct　结构体名</span><br><span class="line">&#123;</span><br><span class="line">数据类型　成员名1;</span><br><span class="line">数据类型　成员名2;</span><br><span class="line">：</span><br><span class="line">数据类型　成员名n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在大括号中的内容也称为“成员列表”或“域表”。</p><p>其中，每个成员的命名规则与变量名相同；</p><p>数据类型可以是基本变量类型和数组类型，或者是一个结构体类型；</p><p>用分号“;”作为结束符。整个结构的定义也用分号作为结束符</p><p>结构体类型中的成员名可以与程序变量名相同，二者并不代表同一对象，编译程序可以自动化对它们进行分区。</p><ol><li><p>结构体类型是用户自行构造的。</p></li><li><p>它由若干不同的基本数据类型的数据构成。</p></li><li><p>它属于Ｃ语言的一种数据类型，与整型、实型相当。因此，定义它时不分配空间，只有它定义变量时才分配空间。</p></li></ol><p><strong>结构体类型变量的定义方法</strong></p><p>先定义结构体类型再定义变量名，这是Ｃ语言中定义结构体类型变量最常见的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct　 结构体名</span><br><span class="line">&#123;</span><br><span class="line"> 成员列表;</span><br><span class="line">&#125;;</span><br><span class="line">struct 结构体名 变量名;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14300434-a60526ced4fa150e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>在定义类型的同时定义变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名</span><br><span class="line">&#123;</span><br><span class="line"> 成员列表;</span><br><span class="line">&#125;变量名;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14300434-f9e2a82a06cc0dbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>直接定义结构体类型变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line"> 成员列表;</span><br><span class="line">&#125;变量名;</span><br></pre></td></tr></table></figure><p>大小</p><p>一个结构体变量占用内存空间的实际大小，也可以利用sizeof求出。它的运算表达式为:<code>sizeof(运算量)</code>//求出给定的运算量占用内存空间的字节数</p><p>其中运算量可以是变量、数组或结构体变量，可以是数据类型的名称。</p><p>结构体变量的适用形式</p><p><code>结构体变量名.成员名</code></p><ol><li><p>不能将一个结构体类型变量作为一个整体加以引用，而只能对结构体类型变量中各个成员分别引用。</p></li><li><p>如果成员本身又属于一个结构体类型，则要用若干个成员运算符，一级一级地找到最低的一级成员。只能对最低级的成员进行赋值或存取以及运算。</p></li><li><p>对成员变量可以像普通变量一样进行各种运算（根据其类型决定可以进行的运算）。</p></li><li><p>在数组中，数组是不能彼此赋值的，而结构体类型变量可以相互赋值。</p></li></ol><h2 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h2><p>与其他类型变量一样，也可以给结构体的每个成员赋初值，这成为结构体的初始化。一中的ｈｉ在定义结构体变量时进行初始化。</p><p><code>struct 结构体名 变量名={初始数据表};</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名</span><br><span class="line">&#123;</span><br><span class="line"> 成员列表;</span><br><span class="line">&#125;变量名=&#123;初始化数据表&#125;;</span><br></pre></td></tr></table></figure><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><p>具有相同结构体类型的结构体变量也可以组成数组，称它们为结构体数组。结构体数组的每一个数组元素都是结构体类型的数据，它们都分别是包括各个成员项。</p><h2 id="结构体数组初始化"><a href="#结构体数组初始化" class="headerlink" title="结构体数组初始化"></a>结构体数组初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名</span><br><span class="line">&#123;</span><br><span class="line"> 成员列表;</span><br><span class="line">&#125;;</span><br><span class="line">struct 结构体名</span><br></pre></td></tr></table></figure><p>在定义结构体类型同时定义结构体数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名</span><br><span class="line">&#123;</span><br><span class="line">成员列表;</span><br><span class="line">&#125;数组名[元素个数];</span><br></pre></td></tr></table></figure><p>直接定义结构体数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">成员列表;</span><br><span class="line">&#125;数组名[元素个数];</span><br></pre></td></tr></table></figure><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>可以设定一个指针变量用来指向一个结构体变量。此时该指针变量的值是结构体变量的起始地址，该指针称为结构体指针。</p><p><code>struct 结构体名 *结构指针名;</code></p><p>其中的结构体名必须是已经定义过的结构体类型。</p><p>当表示指针变量p所指向的结构体变量中的成员时，“（*结构体指针名）.成员名”这种表示形式总是需要使用圆括号，显得不简练。因此，对于结构体指针指向的结构体成员项，给出了另外一种简洁的表示方法。</p><p><code>结构体指针名-&gt;成员名</code>与<code>(*结构体指针名).成员名</code>在意义上完全等价的。</p><h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>在Ｃ语言中，不同数据类型的数据可以使用共同的存储区域，这种数据构造类型称为共用体，简称共用，又称联合体。共用体在定义、说明和使用形式上与结构体相似。两者本质上的不同仅在于使用内存的方式上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union 公用体名</span><br><span class="line">&#123;</span><br><span class="line">成员列表;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于共用体中各成员的数据长度不同，所以公用体变量在存储时总是按其成员中数据长度最大的成员占用内存空间。结构体类型变量在存储时总是按各成员的数据长度之和占用内存空间。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-f62198d797db2d31.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>在使用共用体类型变量的数据是要注意：在共用体类型变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员就失去作用。</p><p>在程序中经常使用结构体与共用体相互嵌套的形式。即共用体类型的成员可以是结构体类型，或者结构体类型的成员是共用体类型。</p><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>在Ｃ语言中，允许使用关键字typedef定义新的数据类型</p><p><code>typedef &lt;已有数据类型&gt; &lt;新数据类型&gt;</code></p><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><p>C/C++定义了４个内存区间</p><ul><li><p>代码区</p></li><li><p>全局变量与静态变量区</p></li><li><p>局部变量区即栈区</p></li><li><p>动态存储区即堆区</p></li></ul><p>静态存储分配</p><p>通常定义变量，编译器在编译时都可以根据该变量的类型知道所需内存空间的大小，从而系统在适当的时候为他们分配确定的存储空间。</p><p>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><p>动态存储分配</p><p>有些操作对象只有在程序运行时才能确定，这样编译器在编译时就无法为他们预定存储空间，只能在程序运行时，系统根据运行时的要求进行内存分配。</p><p>所有动态存储分配都在栈区中进行。从堆上分配，亦成为动态内存分配。程序在运行的时候用malloc申请任意多少的内存，程序员自己负责在任何时用free释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p><h2 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc/free"></a>malloc/free</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void * malloc(size_t num)</span><br><span class="line">void free(void *p)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14300434-f49492cae92c7c8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-f6d902d134d021a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>malloc函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。申请到的是一块连续的内存，有时可能会比所申请的空间大。其有时会申请不到内存，返回NUll。malloc返回值的类型是void <em>，所以在调用malloc时要显示地进行类型转换，将void </em>转换成所需要的指针类型。如果free的参数是NULL的话，没有任何效果。释放一块内存中的一部分是不被允许的。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-9d93bf2887358fe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>注意：</p><p>删除一个指针p(free(p);)，实际意思是删除了p所指的目标（变量或对象等），释放了它所占的堆空间，而不是删除p本身，释放堆空间后，p成了空悬指针，动态分配失败。返回一个空指针（NULL）,表示发生了异常，堆资源不足，分配失败。</p><p>malloc 与free是配对使用的，free只能释放堆空间。如果malloc返回的指针值丢失，则分配的堆空间无法回收，称内存泄漏，同一空间重复释放也是危险的，因为该空间可能以另分配，所以必须妥善保存malloc返回的指针，以保证不发生内存泄漏，也必须保证不会重复释放堆内存空间。</p><p>动态分配的变量或对象的生命期。无名对象的生命期并不依赖于建立它的作用域，比如在函数中建立的动态对象在函数返回后任可使用。我们也称堆空间作为自由空间（free store）就是这个原因。但必须记住释放该对象所占堆空间，并只能释放一次，在函数内建立，而在函数外释放是一件很容易失控的事，往往会出错。</p><h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p>不是NULL指针，是指向“垃圾”内存的指针。“野指针”是很危险的。</p><p>“野指针”的成因主要有两种：</p><ul><li><p>指针变量没有被初始化</p></li><li><p>指针p被free之后，没有置为NULL，让人误以为p是个合法的指针。</p></li><li><p>指针操作超越了变量的作用范围。这种情况让人防不胜防。</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/14300434-6fc570f9ec6ebd4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="make简介"><a href="#make简介" class="headerlink" title="make简介"></a>make简介</h2><p>工程管理器，是指管理较多的文件，也是个“自动编译管理器”，这里的“自动”是指它能够根据文件时间戳自动发现更新过的文件而减少编译的工作量，同时，它通过读入Makefiile文件的内容来执行大量的编译工作。Make将只编译改动的代码文件，而不用完全编译。</p><h2 id="Makefile基本结构"><a href="#Makefile基本结构" class="headerlink" title="Makefile基本结构"></a>Makefile基本结构</h2><p>Makefile是Make读入的唯一配置文件</p><p>由make工具创建的目标体（target）,通常是目标文件或可执行文件，要创建的目标体所依赖的文件（dependency_file）,创建每个目标文件体时需要运行的命令（command）。</p><p>注意：命令行前面必须是一个“TAB键”，否则编译错误为：*** missing separator. Stop.</p><p>Makefile格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target:dependency_files</span><br><span class="line">&lt;TAB&gt; command</span><br></pre></td></tr></table></figure><p>-Wall：表示允许发出gcc所有有用的报警信息</p><p>-c：只是编译不链接，生出目标文件“.o”</p><p>-o file：表示把输出文件输出到file里</p><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test:f1.o f2.o main.o</span><br><span class="line"> gcc f1.o f2.o main.o -o test</span><br><span class="line">f1.o:f1.c</span><br><span class="line"> gcc -c -Wall f1.c -o f1.o</span><br><span class="line">f2.o:f2.c</span><br><span class="line"> gcc -c -Wall f2.c -o f2.o</span><br><span class="line">main.o:main.c</span><br><span class="line"> gcc -c -Wall main.c -o main.o</span><br><span class="line">clean:</span><br><span class="line"> rm *.o test</span><br></pre></td></tr></table></figure><h2 id="创建和使用变量"><a href="#创建和使用变量" class="headerlink" title="创建和使用变量"></a>创建和使用变量</h2><p>创建变量的目的：用来代替一个文本字符串</p><ol><li><p>系列文件的名字</p></li><li><p>传递给编译器的参数</p></li><li><p>需要运行的程序</p></li><li><p>需要查找源代码的目录</p></li><li><p>你需要输出信息的目录</p></li><li><p>你想做其他事情</p></li></ol><p>变量定义的两种方式</p><ul><li><p>递归展开方式VAR=var</p></li><li><p>简单方式VAR: =var</p></li></ul><p>变量使用（$(VAR)）</p><p>用“$$”来表示“$”</p><p>类似于编程语言中的宏</p><p>用这种方式定义的变量，会在变量的定义点，按照被引用的变量的当前值进行展开</p><p>这种定义变量的方式更适合在大量的编程项目中使用，因为它更像我们一般的编程语言</p><p>自动变量</p><table><thead><tr><th>$*</th><th>不包含扩展名的目标文件名称</th></tr></thead><tbody><tr><td>$+</td><td>所有依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件</td></tr><tr><td>$&lt;</td><td>第一个依赖文件的名称</td></tr><tr><td>$?</td><td>所有时间戳比目标文件晚的依赖文件，以空格分开</td></tr><tr><td>$@</td><td>目标文件的完整名称</td></tr><tr><td>$^</td><td>所有不重复的目标依赖文件，以空格分开</td></tr><tr><td>$%</td><td>如果目标是归档成员，则该变量表示目标的归档成员名称</td></tr></tbody></table><h2 id="Make使用"><a href="#Make使用" class="headerlink" title="Make使用"></a>Make使用</h2><p>直接运行make</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-C</td><td>dir读入指定目录下的Makefile</td></tr><tr><td>-f</td><td>file读入当前目录下的file文件作为Makefile</td></tr><tr><td>-i</td><td>忽略所有的命令执行错误</td></tr><tr><td>-I</td><td>dir指定被包含的Makefile所在目录</td></tr><tr><td>-n</td><td>只打印要执行的命令，但不执行这些命令</td></tr><tr><td>-p</td><td>显示make变量数据库和隐含规则</td></tr><tr><td>-s</td><td>在执行命令时不显示命令</td></tr><tr><td>-w</td><td>如果make在执行过程改变目录，打印当前目录名</td></tr></tbody></table><h2 id="Makefile的隐含规则"><a href="#Makefile的隐含规则" class="headerlink" title="Makefile的隐含规则"></a>Makefile的隐含规则</h2><ul><li>编译Ｃ程序的隐含规则</li></ul><p>“<code>&lt;n&gt;</code>.o”的目标的依赖目标会自动推导为“<code>&lt;n&gt;</code>.c”，并且其生成命令是<code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code></p><ul><li>链接Object文件的隐含规则</li></ul><p>“<code>&lt;n&gt;</code>”目标依赖于“<code>&lt;n&gt;</code>.o”,通过运行C的编译器来运行链接程序生成（一般是“ld”）,其生成命令是：<code>$(CC) $(LDFLAGS) &lt;n&gt;.o</code></p><p><code>$(LOADLIBES) $(LDLIBS</code>这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。</p><p>Makefile的VPATH</p><p>VPATH：（虚路径）在make需要去找寻依赖关系时，在文件前加上路径，把路径告诉make。</p><hr><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="数据结构概念"><a href="#数据结构概念" class="headerlink" title="数据结构概念"></a>数据结构概念</h2><p>数据结构是研究组成数据的数据元素的关系的学科。</p><p><strong>数据结构研究的目的</strong></p><p>通过研究数据元素的关系，帮助我们在开发软件的时候更好的组建数据模型，让数据在内存中的操作更加的流畅高效。</p><ul><li><p>逻辑关系</p></li><li><p>存储关系</p></li><li><p>运算关系</p></li></ul><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>数据即信息的载体，是能够输入到计算机中并且能被计算机识别、存储和处理的符号总称。</p><h2 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h2><p>数据元素是数据的基本单位，又称之为记录（Record）</p><h2 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h2><p>数据元素由若干数据项组成，数据项是数据中的最小单位。</p><h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型是对数据元素取值范围与运算的限定。</p><p>数据结构（DS）可用形式化语言描述，即DS是一个二元组：DS = (D, R)，其中Ｄ为数据元素的集合，Ｒ为Ｄ上关系的集合。</p><h2 id="数据之间的相互关系"><a href="#数据之间的相互关系" class="headerlink" title="数据之间的相互关系"></a>数据之间的相互关系</h2><ol><li>逻辑结构：</li></ol><p>表示数据元素之间的抽象关系（如邻接关系、从属关系等）。</p><p>有四种基本的逻辑结构：集合结构、线性结构、树形结构、图状结构</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-e30c70cb3c05368b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ol start="2"><li><p>存储结构</p><p>数据的逻辑结构在计算机内的存储形式。</p></li></ol><p>分为顺序存储结构、链接存储结构、索引存储结构、散列存储结构</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-f4b86a6608ab3b07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-3ed6c662fbb12f43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-5695511947deb1c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><ol start="3"><li>数据运算</li></ol><p>对数据进行的操作，如插入、删除、查找、排序等。</p><p><img src="https://upload-images.jianshu.io/upload_images/14300434-e55b3b2c221cf3fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux部分&quot;&gt;&lt;a href=&quot;#Linux部分&quot; class=&quot;headerlink&quot; title=&quot;Linux部分&quot;&gt;&lt;/a&gt;Linux部分&lt;/h1&gt;&lt;p&gt;由于前面已经学习了Linux，所以在这里只做简单的补充；&lt;/p&gt;
&lt;h2 id=&quot;vi编辑器三种模式
      
    
    </summary>
    
      <category term="嵌入式" scheme="https://smallpotatody.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="嵌入式" scheme="https://smallpotatody.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>linux</title>
    <link href="https://smallpotatody.github.io/2019/07/18/linux/"/>
    <id>https://smallpotatody.github.io/2019/07/18/linux/</id>
    <published>2019-07-18T02:37:27.000Z</published>
    <updated>2019-07-19T08:48:13.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><p>tty控制台终端</p><p>​    tty1-tty6</p><p>​    tty1既是图形界面（默认）</p><p>​    图形界面切换到字符界面终端：ctrl + shift + alt + F2~F6</p><p>​    字符界面切花到图形界面终端：alt + F1</p><p>pts虚拟终端</p><p>​    ctrl + alt + t 打开新终端</p><p>查看系统和BIOS硬件时间：指的是bios时间</p><p><img src="/2019/07/18/linux/1.png" alt></p><h2 id="Linux如何获得帮助？"><a href="#Linux如何获得帮助？" class="headerlink" title="Linux如何获得帮助？"></a>Linux如何获得帮助？</h2><p>方法1：加参数-h 或–help；</p><p><img src="/2019/07/18/linux/2.png" alt></p><p>方法2：man 加命令；</p><p><img src="/2019/07/18/linux/3.png" alt></p><h2 id="关机命令："><a href="#关机命令：" class="headerlink" title="关机命令："></a>关机命令：</h2><p>shutdown、initial、reboot</p><p>shutdown 作用：关机、重启、定时关机</p><p>语法：<code>#shutdown [选项]</code></p><p>选项：</p><p>​    -r：重新启动计算机</p><p>​    -h：关机</p><p>​    -h 时间：定时关机</p><p>​    -c：取消之前的定时关机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now   #马上关机</span><br><span class="line">shutdown -h +10   #10分钟后关机</span><br><span class="line">shutdown -h 20:02 #在20：02时关机</span><br></pre></td></tr></table></figure><p><img src="/2019/07/18/linux/4.png" alt></p><p>init 作用：切换运行级别</p><p>语法：<code>init 0~6</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init 0   #命令用于立即将系统运行级别切换为0，即关机；</span><br><span class="line">init 6   #命令用于将系统运行级别切换为6，即重新启动；</span><br></pre></td></tr></table></figure><p>runlevel 作用：查看当前运行级别</p><p>语法：<code>#runlevel</code></p><p><img src="/2019/07/18/linux/5.png" alt></p><p>!$；表示上一个命令的最后一个参数；</p><p>同一目录下文件和文件名不一样。</p><h2 id="字符操作："><a href="#字符操作：" class="headerlink" title="字符操作："></a>字符操作：</h2><p>i  当前插入</p><p>I  行首插入</p><p>a  当前字符之后插入</p><p>A  行尾插入</p><p>o  下一行插入</p><p>O  上一行插入</p><p> x  向后删除一个字符</p><p> X  向前删除一个字符</p><p> u  撤销一步</p><h2 id="词操作"><a href="#词操作" class="headerlink" title="词操作"></a>词操作</h2><p>dw  删除一个词，删除时要将光标移动到这个词的行首。另外，如果光标不在行首，则删除光标之后的字母。</p><p>yw  复制一个词</p><h2 id="快操作"><a href="#快操作" class="headerlink" title="快操作"></a>快操作</h2><p>大D或d + $ 删至行尾 d+^删至行首</p><p>y + $ 复制至尾  y + ^ 复制至首 </p><h2 id="v模式"><a href="#v模式" class="headerlink" title="v模式"></a>v模式</h2><p>进入v模式，移动光标选择区域</p><p>编程时需要进行多行注释：</p><ol><li>注释：CTRL + v进入列编辑模式</li><li>向下或向上移动光标</li><li>把需要注释的行的开头标记起来</li><li>然后按大写的I</li><li>再插入注释符，比如’#’</li><li>再按Esc，就会全部注释了</li></ol><h2 id="linux文件系统由三部分组成：文件名，inode，block（真正存数据）"><a href="#linux文件系统由三部分组成：文件名，inode，block（真正存数据）" class="headerlink" title="linux文件系统由三部分组成：文件名，inode，block（真正存数据）"></a><strong>linux文件系统由三部分组成：文件名，inode，block（真正存数据）</strong></h2><p>indoe：文件数据都储存在’块中‘，那么很显然，我们还必须找一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域叫做inode，中文名译为”索引节点“。</p><h2 id="inode的内容"><a href="#inode的内容" class="headerlink" title="inode的内容"></a>inode的内容</h2><p>inode包含文件的元信息</p><p>​    文件的字节数</p><p>​    文件拥有者的User ID</p><p>​    文件的Group ID</p><p>​    文件的读、写、执行权限</p><p>​    文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上依次打开的时间。</p><p>​    链接数，即有多少文件名指向这个inode</p><p>​    文件数据block的位置</p><p>使用stat命令查看文件inode信息</p><p><img src="/2019/07/18/linux/6.png" alt></p><h2 id="inode的大小"><a href="#inode的大小" class="headerlink" title="inode的大小"></a>inode的大小</h2><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。</p><p><img src="/2019/07/18/linux/7.png" alt></p><p>每个文件最少有一个inode号。操作系统号码来识别不同文件。</p><p>使用<code>ls -i</code>命令，可以看到文件名对应的inode号码：</p><p><img src="/2019/07/18/linux/8.png" alt></p><p><strong>Linux中ctime，mtime，atime的区别</strong></p><p>ctime：”改变时间（change time）“</p><p>mtime：”修改时间（modification time）“</p><p>改变和修改之间的区别在于是改文件的属性还是更改它的内容。chmod a-w myfile，那么这是一个改变；</p><p>echo foo &gt;&gt; myfile,那么这是一个修改。</p><p>改变是文件的索引节点发生来改变；修改是文本本身的内容发生了变化。</p><p>atime：”访问时间（access time）“</p><p>访问时间是文件最后一次被读取时间。因此阅读一个文件会更新它的访问时间。但是它的修改时间和改变时间没有变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -lc filename            #列出文件的ctime</span><br><span class="line">ls -lu filename            #列出文件的atime</span><br><span class="line">ls -l filename             #列出文件的mtime</span><br></pre></td></tr></table></figure><h2 id="ext4文件系统比ext3文件系统强的方面："><a href="#ext4文件系统比ext3文件系统强的方面：" class="headerlink" title="ext4文件系统比ext3文件系统强的方面："></a>ext4文件系统比ext3文件系统强的方面：</h2><ol><li>ext4与ext3兼容</li><li>更大的文件系统和更大的文件。交织Ext3目前所支持的最大16TB文件系统和最大2</li></ol><p>TB文件，Ext4分别支持1EB（1,048,576TB，1EB=1024PB，1PB=1024TB）的文件系统，以及16TB的文件。</p><ol start="3"><li>无限数量的子目录。Ext3目前只支持32,000个子目录，而Ext4支持无限数量的子目录。</li><li>”无日志“（No Journaling）模式。日志总归有一些开销，Ext4允许关闭日志，以便某些有特殊需求的用户可以借此提升性能。</li></ol><p>LUKS（Linux UNified Key Setup）为Linux硬盘加密提供了一种标准</p><p>​    cryptsetup是linux下的一个分区加密工具，是在经过加密的块设备上再创建文件系统，然后再进行挂在使用，可以达到最底层的加密。</p><p>首先对硬盘进行分区：</p><p>​    fdisk /dev/sdb</p><p>​    fdisk                #分出一个sdb1</p><p>​    fdisk  -l</p><p>下面开始对分区进行加密</p><p><code>#cryptsetup luksFormat/dev/sdb1</code>设置为加密分区</p><p>​    出现要输入yes的地方一定要输入YES</p><p>映射</p><p><code>cryptsetup luksOpen /dev/sdb1 disk1</code>#将分区映射成disk1，则这个设置就在/dev/mapper中</p><p><code>mkfs.ext4 /dev/mapper/disk1</code> 格式化加密分区</p><p><code>mount /dev/mapper/disk1/mnt/luks</code>  挂载加密分区</p><p>df查看分区挂载情况</p><p><code>umount /dev/mapper/disk1</code>   卸载分区</p><p><code>cryptsetup luksClose/dev/mapper/disk1</code>  关闭加密分区</p><p>生成加密分区的密码文件，实现开机自动挂载加密分区</p><p><code>vi /etc/crpttab</code>  写入：</p><p><code>disk1 /dev/sdb1           /root/key</code></p><p>如果这里写none的话，当系统启动时在读取分区时候，会一直停在那，等待输入密码</p><p><code>echo -n &quot;123&quot; &gt; /root/key</code>         生成密码文件</p><p><code>chmod 700 /root/key</code>          修改权限</p><p><code>cryptsetup luksAddKey/dev/sdb1/root/key</code>   添加口令到/dev/sdb1中</p><p><code>cat /etc/crypttab</code></p><p><code>disk1 /dev/sdb1         /root/key</code></p><p>vi /etc/fstab自动挂载文件</p><p>​    /dev/mapper/disk1 /mnt/luks  ext4 defaults  0  0</p><p>mount -a             重新挂载/etc/fstab里的内容，如果报错的话就需要重启系统</p><h2 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h2><p><code>iconv -f gb2312 1.txt -o 2.txt</code></p><p>解决将公司服务器上脚本导到windows上打开串行问题</p><p>这是因为windows和Linux处理回车不同。</p><p><code>unix2dos 文件名</code></p><h2 id="用户分类："><a href="#用户分类：" class="headerlink" title="用户分类："></a>用户分类：</h2><p>根据账号的位置：本地帐号、远程（域）账号。</p><p>根据账号功能：</p><p>​    超级用户（root）    UID ：0</p><p>​    普通用户</p><p>​        系统用户 UID：1-499</p><p>​        本地用户 UID：500+</p><h2 id="组分类："><a href="#组分类：" class="headerlink" title="组分类："></a>组分类：</h2><p>根据账号的位置：本地组、远程（域）组。</p><p>根据账号功能：</p><p>​    超级用户组（root）    UID ：0</p><p>​    普通用户组</p><p>​        系统用户组 UID：1-499</p><p>​        本地用户组 UID：500+</p><p>关于系统用户和组的相关配置文件：</p><p>​        账号信息    密码信息</p><p>用户：     /etc/passwd     /etc/shadow</p><p>组：         /etc/group        /etc/gshadow</p><h2 id="passwd中的伪用户："><a href="#passwd中的伪用户：" class="headerlink" title="passwd中的伪用户："></a>passwd中的伪用户：</h2><p>/etc/passwd文件中常见的伪用户</p><table><thead><tr><th>伪用户</th><th>含义</th></tr></thead><tbody><tr><td>bin</td><td>拥有可执行的用户命令文件</td></tr><tr><td>sys</td><td>拥有系统文件</td></tr><tr><td>adm</td><td>拥有账户文件</td></tr><tr><td>uucp</td><td>UUCP使用</td></tr><tr><td>Ip</td><td>Ip或Ipd子系统使用</td></tr><tr><td>nobody</td><td>NFS使用</td></tr></tbody></table><p>源码安装nginx，运行nginx web服务默认使用nobody用户</p><p><img src="/2019/07/18/linux/9.png" alt></p><p>​                 </p><p><img src="/2019/07/18/linux/10.png" alt></p><p>用户名：密码：最近更改密码的日期（从19700101开始计算）：密码不能更改的天数（最近被改过之后几天后才可以再次更改。0表示随时可以修改）：密码过期时间（多少天后必须再次修改）：密码需要更改期限到来前7发出警告：宽限天数（密码过了几天后还能改密码）：账号过期时间：保留</p><h2 id="为多个用户输入初始密码"><a href="#为多个用户输入初始密码" class="headerlink" title="为多个用户输入初始密码"></a>为多个用户输入初始密码</h2><p><code>#echo 密码 | passwd --stdin 用户名</code> # –stdin非交互添加密码</p><h2 id="Linux用户密码加密"><a href="#Linux用户密码加密" class="headerlink" title="Linux用户密码加密"></a>Linux用户密码加密</h2><p><img src="/2019/07/18/linux/11.png" alt></p><h2 id="控制添加用户规则的文件"><a href="#控制添加用户规则的文件" class="headerlink" title="控制添加用户规则的文件"></a>控制添加用户规则的文件</h2><p><img src="/2019/07/18/linux/12.png" alt></p><p>HOME=/home          #哪个目录作为用户主目录存放目录。如果你不想让用户家目录在/home下，可以修改这个地方。</p><p>SHELL=/bin/bash     #默认shell使用哪个</p><p>SKEL=/etc/skel          #模板目录</p><h2 id="查看用户信息相关命令："><a href="#查看用户信息相关命令：" class="headerlink" title="查看用户信息相关命令："></a>查看用户信息相关命令：</h2><p><code>id 用户名</code></p><p><code>whoami</code></p><p><code>w</code></p><p><code>who</code></p><p><img src="/2019/07/18/linux/13.png" alt></p><h2 id="用户切换"><a href="#用户切换" class="headerlink" title="用户切换"></a>用户切换</h2><p><code>#su [-] username</code>加-用户和shell环境一起切换。</p><hr><h2 id="进入单用户找回root身份"><a href="#进入单用户找回root身份" class="headerlink" title="进入单用户找回root身份"></a>进入单用户找回root身份</h2><p>编辑/etc/passwd，<code>vim /etc/passwd</code>将root​：x：变成root：：​</p><p><img src="/2019/07/18/linux/14.png" alt></p><h2 id="文件基本权限-不适用于root"><a href="#文件基本权限-不适用于root" class="headerlink" title="文件基本权限(不适用于root)"></a>文件基本权限(不适用于root)</h2><p><img src="/2019/07/18/linux/15.png" alt></p><p>对于文件：</p><p>​    r读    w写    x执行</p><p>对于目录：</p><p>​    r读（看到目录里面有什么）</p><p>​    w建文件、删除、移动</p><p>​    x进入    </p><h2 id="修改权限命令"><a href="#修改权限命令" class="headerlink" title="修改权限命令"></a>修改权限命令</h2><p><code>chmod</code></p><p>作用：修改文件权限</p><p>u + r</p><p>g - w</p><p>o = x</p><p>a + x  a表示所有（u、g、o）</p><p><img src="/2019/07/18/linux/16.png" alt></p><p>修改文件夹权限</p><p><img src="/2019/07/18/linux/17.png" alt></p><h2 id="使用数字表示权限"><a href="#使用数字表示权限" class="headerlink" title="使用数字表示权限"></a>使用数字表示权限</h2><p>rwx</p><table><thead><tr><th>r–</th><th>-w-</th><th>–x</th></tr></thead><tbody><tr><td>100</td><td>010</td><td>001</td></tr><tr><td>r=4</td><td>w=2</td><td>x=1</td></tr></tbody></table><p>rw-的值是6 ，rwx r-x r-x的值是755</p><p><img src="/2019/07/18/linux/18.png" alt></p><p><code>chmod a=rwx a.txt</code>    等于   <code>chmod 777 a.txt</code>                </p><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>作用：修改文件拥有者和所属组</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown USER:GROUP 对象</span><br><span class="line">chown USER 对象</span><br><span class="line">chown :GROUP 对象</span><br></pre></td></tr></table></figure><p>-R 递归（目录下的所有内容全部更改，否则只修改目录）</p><p><img src="/2019/07/18/linux/19.png" alt></p><p>设置文件默认权限的补码：</p><p>系统用户：#umask 022</p><p>普通用户：#umask 002</p><p><img src="/2019/07/18/linux/20.png" alt></p><p>计算方法：</p><p>​    文件默认权限=666 - umask值   666-022=644</p><p>​    目录默认权限=777 - umask值</p><p>注意：这是一个好的记忆方法，但不严谨。</p><p>umask掩码为033. 666 - 033=633 结果为：644</p><p>110110110（666）与111100100（033的反码）相与得到110100100（644）</p><p><img src="/2019/07/18/linux/21.png" alt></p><h2 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h2><p>SUID                    SGID                Stickybit</p><p>s对应的数值为：4   s，2    t，1</p><p>SUID：</p><p>限定：只能设置在二进制可执行程序上面。对目录文本设置无效。</p><p>功能：程序运行时的权限从执行者变更成程序的所有者。</p><p>SGID：</p><p>限定：既可以给二进制可执行程序设置，也可以给目录设置。</p><p>功能：在设置了SGID权限的目录下建立文件是，新创建的文件的所属组会继承上级目录的所属组。</p><p>Stickybit：</p><p>限定：只作用于目录</p><p>功能：目录下创建的文件只有root、文件创建者、目录所有者才能删除。</p><p>一个让root都无法删除的文件</p><p>chattr                   lsattr</p><p>+a   只能追加内容</p><p>+i    不能被修改</p><p><img src="/2019/07/18/linux/22.png" alt></p><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p>作用：打包、压缩文件</p><p><img src="/2019/07/18/linux/23.png" alt></p><p>#c      create 创建</p><p>#v       详细</p><p>#f         filename</p><h2 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h2><p>作用：查看文件类型</p><p>用法：file 文件路劲</p><p><img src="/2019/07/18/linux/24.png" alt></p><p>注意：Linux系统不根据后缀名识别文件类型</p><p>不解包，查看tar中的内容：</p><p>​    <code>tar -tvf a.tar</code></p><p><img src="/2019/07/18/linux/25.png" alt></p><p>解包：</p><p>​    <code>tar -xvf a.tar</code></p><p><img src="/2019/07/18/linux/26.png" alt></p><p>指定解压路径：</p><p>​    <code>tar -xf a.tar -C /home</code></p><p><img src="/2019/07/18/linux/27.png" alt></p><h2 id="tar归档-压缩"><a href="#tar归档-压缩" class="headerlink" title="tar归档+压缩"></a>tar归档+压缩</h2><p>格式（后缀名）:.tar.gz 或 .tgz</p><p>语法：<code>tar cvzf   newfile.tar.gz SOUPCE</code></p><p><img src="/2019/07/18/linux/28.png" alt></p><p><code>tar -zxf a.tar -C /home</code></p><h2 id="bz2-归档-压缩"><a href="#bz2-归档-压缩" class="headerlink" title="bz2 归档+压缩"></a>bz2 归档+压缩</h2><p><code>tar -cjvf a.tar.bz2 /root</code></p><p>解压：<code>tar jxf a.tar.bz2 -C /root/a</code></p><h2 id="zip软件包解压缩命令"><a href="#zip软件包解压缩命令" class="headerlink" title="zip软件包解压缩命令"></a>zip软件包解压缩命令</h2><p>zip是压缩程序，unzip是解压程序。</p><p>压缩文件：</p><p>​    <code>zip a.zip /etc/passwd</code></p><p>压缩目录：</p><p>​    <code>zip -r  a.zip /root</code></p><p>解压缩：</p><p>​    <code>unzip a.zip</code></p><p>​    <code>unzip  a.zip -d /home</code></p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>查看进程树：</p><p>pstree树型结构显示系统进程信息</p><p>-p显示进程号</p><h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p><img src="/2019/07/18/linux/30.png" alt></p><p>USER：运行此进程的用户名</p><p>PID：该process的号码</p><p>%CPU：该进程使用掉的CPU资源百分比</p><p>%MEM：该进程所占用的物理内存百分比</p><p>VSZ：该进程使用掉的虚拟内存量（kbytes）</p><p>RSS：该进程占用的固定的内存量（kbytes）</p><p>TTY：该进程是在哪个终端上面运作，若与终端机无关，则显示？，另外，tty1~tty6市本级上面的登入者程序，若为pts/0等等的，则表示为由网络连接进主机的程序。</p><p>STAT：该进程目前的状态，Linux进程有5种基本状态：</p><p>​    R：（正在运行或在运行队列中等待）；</p><p>​    S：该程序目前正在睡眠中，但是可被某些讯号（signal）唤醒。</p><p>​    T：该程序目前暂停了；</p><p>​    Z：该程序应该已经终止，但是其父程序却无法正常的终止它，造成zombie（僵尸）程序的状态；</p><p>​    D：不可中断状态；</p><p>ctrl + c是发送SIGINT信号，终止一个进程</p><p>ctrl + z是发送SIGSTOP信号，挂起一个进程。</p><table><thead><tr><th>&lt;</th><th>高优先级的</th></tr></thead><tbody><tr><td>N</td><td>低优先级的</td></tr><tr><td>L</td><td>有内存分页但是带锁</td></tr><tr><td>s</td><td>包含子进程</td></tr><tr><td>I</td><td>多线程</td></tr><tr><td>+</td><td>前台程序（）</td></tr></tbody></table><p>START：该进程被触发启动的时间</p><p>TIME：该进程实际使用CPU运作的时间</p><p>COMMAND：该进程的实际指令</p><p>ps -aux是用BSD的格式来显示进程</p><p>ps -ef是用标准的格式显示进程</p><p><img src="/2019/07/18/linux/31.png" alt></p><h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><p>作用：动态查看进程</p><p>统计信息区前五行是系统整体的统计信息</p><p>1.第一行是任务队列信息，同<code>uptime</code>命令的执行结果相同</p><p><img src="/2019/07/18/linux/32.png" alt></p><table><thead><tr><th>14:35:50</th><th>当前时间</th></tr></thead><tbody><tr><td>up  3:25</td><td>系统运行时间，格式为时：分</td></tr><tr><td>2 users</td><td>当前登录用户数</td></tr><tr><td>load average: 0.08, 0.03, 0.05</td><td>系统负载，即任务队列的平均长度。三个值分别为1分钟、5分钟、15分钟前到现在的平均值。</td></tr></tbody></table><p>2.第二、三行为进程和CPU的信息</p><table><thead><tr><th>Tasks: 198 total</th><th>进程总数</th></tr></thead><tbody><tr><td>1 running</td><td>正在运行的进程数</td></tr><tr><td>197 sleeping</td><td>睡眠进程数</td></tr><tr><td>0 stopped</td><td>停止进程数</td></tr><tr><td>0 zombie</td><td>僵尸进程数</td></tr><tr><td>%Cpu(s):  1.3 us</td><td>系统用户进程使用CPU百分比</td></tr><tr><td>0.3 sy</td><td>内核空间占用CPU百分比</td></tr><tr><td>0.0 ni</td><td>用户进程空间内改变过优先级的进程占用CPU百分比</td></tr><tr><td>98.3 id</td><td>空闲CPU百分比</td></tr></tbody></table><p>3.第四、五行为内存信息</p><table><thead><tr><th>KiB Mem :   997956 total</th><th>物理内存总量</th></tr></thead><tbody><tr><td>62328 free</td><td>空闲内存总量</td></tr><tr><td>739828 used</td><td>使用的物理内存总量</td></tr><tr><td>195800 buff/cache</td><td>用作内核缓存的内存量和free -k一个意思</td></tr><tr><td>KiB Swap:  2097148 total</td><td>交换区总量</td></tr><tr><td>1914364 free</td><td>空闲交换区总量</td></tr><tr><td>182784 used</td><td>使用的交换区总量</td></tr><tr><td>57860 avail Mem</td><td>缓冲的交换区总量</td></tr></tbody></table><h2 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h2><table><thead><tr><th>PID</th><th>进程id</th></tr></thead><tbody><tr><td>USER</td><td>进程所有者的用户名</td></tr><tr><td>NI</td><td>进程优先级，nice值。负值表示高优先级，正值表示低优先级</td></tr><tr><td>RES</td><td>实际使用内存大小</td></tr></tbody></table><p>top快捷键：</p><p>默认3s刷新一次</p><p>空格：立即刷新</p><p>q退出</p><p>M按内存排序</p><p>P按CPU排序</p><h2 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h2><p><code>kill -9 pid</code></p><p>killall或plill 通过程序的名字，直接杀死所有进程</p><h2 id="文件查找方法"><a href="#文件查找方法" class="headerlink" title="文件查找方法"></a>文件查找方法</h2><p>which：查看可执行文件的位置</p><p>whereis：查看可执行文件的位置及相关文件</p><p>locate：配合数据库缓存，快速查看文件位置</p><p>find：实际搜寻硬盘查询文件名称</p><p>grep：过滤</p><h2 id="find搜索文件系统、实时搜索"><a href="#find搜索文件系统、实时搜索" class="headerlink" title="find搜索文件系统、实时搜索"></a>find搜索文件系统、实时搜索</h2><p>find [目录] [条件] [动作]</p><p>不输入代表当前目录</p><p>类型：-type（f 文件，d 目录，I 链接，p 管道，c 字符文件，b 快文件，s socket文件）</p><p>名字：-name</p><p>大小：-size    +NM大于兆           -NG小NGB</p><p>时间： -mtime    -atime           -ctime</p><h2 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h2><p>cat -s多个空行合并成一个空行显示</p><p>cat -b加行号显示</p><p>nl 加行号</p><p><img src="/2019/07/18/linux/33.png" alt></p><p><code>cp 源文件路径 目的路径 -i</code>覆盖时交互提示：</p><p><img src="/2019/07/18/linux/34.png" alt></p><p>touch创建一个已经存在的文件时，只更新时间戳</p><p><img src="/2019/07/18/linux/35.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;终端&quot;&gt;&lt;a href=&quot;#终端&quot; class=&quot;headerlink&quot; title=&quot;终端&quot;&gt;&lt;/a&gt;终端&lt;/h2&gt;&lt;p&gt;tty控制台终端&lt;/p&gt;
&lt;p&gt;​    tty1-tty6&lt;/p&gt;
&lt;p&gt;​    tty1既是图形界面（默认）&lt;/p&gt;
&lt;p&gt;​    
      
    
    </summary>
    
      <category term="linux" scheme="https://smallpotatody.github.io/categories/linux/"/>
    
    
      <category term="Linux" scheme="https://smallpotatody.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>用virtualbox安装centos</title>
    <link href="https://smallpotatody.github.io/2019/06/13/%E7%94%A8virtualbox%E5%AE%89%E8%A3%85centos/"/>
    <id>https://smallpotatody.github.io/2019/06/13/用virtualbox安装centos/</id>
    <published>2019-06-13T06:41:41.000Z</published>
    <updated>2019-06-13T09:04:43.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装Virtual-Box"><a href="#一、安装Virtual-Box" class="headerlink" title="一、安装Virtual Box"></a>一、安装Virtual Box</h1><h2 id="1-下载virtual-box"><a href="#1-下载virtual-box" class="headerlink" title="1.下载virtual box"></a>1.下载virtual box</h2><p><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">官网</a><img src="/2019/06/13/用virtualbox安装centos/0.png" alt></p><h2 id="2-安装virtual-box"><a href="#2-安装virtual-box" class="headerlink" title="2.安装virtual box"></a>2.安装virtual box<img src="/2019/06/13/用virtualbox安装centos/1.png" alt><img src="/2019/06/13/用virtualbox安装centos/2.png" alt><img src="/2019/06/13/用virtualbox安装centos/3.png" alt><img src="/2019/06/13/用virtualbox安装centos/4.png" alt><img src="/2019/06/13/用virtualbox安装centos/5.png" alt><img src="/2019/06/13/用virtualbox安装centos/6.png" alt><img src="/2019/06/13/用virtualbox安装centos/7.png" alt><img src="/2019/06/13/用virtualbox安装centos/8.png" alt><img src="/2019/06/13/用virtualbox安装centos/9.png" alt></h2><p>安装完成后查看网络出现Virtual Box Host-Only Network表示安装成功</p><p><img src="/2019/06/13/用virtualbox安装centos/10.png" alt></p><h1 id="二、配置虚拟机centos"><a href="#二、配置虚拟机centos" class="headerlink" title="二、配置虚拟机centos"></a>二、配置虚拟机centos</h1><h2 id="1-下载镜像"><a href="#1-下载镜像" class="headerlink" title="1.下载镜像"></a>1.下载镜像</h2><p><a href="https://www.centos.org/download/" target="_blank" rel="noopener">官网</a></p><p>点击DVD ISO</p><p><img src="/2019/06/13/用virtualbox安装centos/1_0.png" alt></p><p>或者去官网选择版本下载<a href="https://wiki.centos.org/Download" target="_blank" rel="noopener"></a></p><p><img src="/2019/06/13/用virtualbox安装centos/1_2.png" alt></p><p>下拉选项找到你要下载的版本号进行下载</p><p><img src="/2019/06/13/用virtualbox安装centos/1_3.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/1_4.png" alt></p><p>选择任意一个链接下载</p><p><img src="/2019/06/13/用virtualbox安装centos/1_1.png" alt></p><h2 id="2-新建虚拟机"><a href="#2-新建虚拟机" class="headerlink" title="2.新建虚拟机"></a>2.新建虚拟机</h2><p><img src="/2019/06/13/用virtualbox安装centos/1_5.png" alt></p><p>设置内存大小</p><p><img src="/2019/06/13/用virtualbox安装centos/1_6.png" alt></p><p>创建磁盘</p><p><img src="/2019/06/13/用virtualbox安装centos/1_7.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/1_8.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/1_9.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/2_0.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/2_1.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/2_2.png" alt></p><h2 id="3-启动centos"><a href="#3-启动centos" class="headerlink" title="3.启动centos"></a>3.启动centos</h2><p><img src="/2019/06/13/用virtualbox安装centos/3_0.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/3_1.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/3_2.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/3_3.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/3_4.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/3_5.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/3_6.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/3_7.png" alt></p><p><img src="/2019/06/13/用virtualbox安装centos/3_8.png" alt></p><p>安装成功，我安装的是无图形化的</p><p><img src="/2019/06/13/用virtualbox安装centos/3_9.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、安装Virtual-Box&quot;&gt;&lt;a href=&quot;#一、安装Virtual-Box&quot; class=&quot;headerlink&quot; title=&quot;一、安装Virtual Box&quot;&gt;&lt;/a&gt;一、安装Virtual Box&lt;/h1&gt;&lt;h2 id=&quot;1-下载virtual-b
      
    
    </summary>
    
      <category term="Linux" scheme="https://smallpotatody.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://smallpotatody.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习</title>
    <link href="https://smallpotatody.github.io/2019/06/12/Linux%E5%AD%A6%E4%B9%A0/"/>
    <id>https://smallpotatody.github.io/2019/06/12/Linux学习/</id>
    <published>2019-06-12T12:23:44.000Z</published>
    <updated>2019-07-18T14:53:14.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Linux发展史"><a href="#一、Linux发展史" class="headerlink" title="一、Linux发展史"></a>一、Linux发展史</h1><p>1970年元年</p><h1 id="二、Linux系统安装"><a href="#二、Linux系统安装" class="headerlink" title="二、Linux系统安装"></a>二、Linux系统安装</h1><p>安装方式：</p><p>​    真机模式</p><p>​    虚拟机安装：通过一些特定的手段，来进行模拟安装</p><p>​        VMware workstation的安装：<a href="https://www.jianshu.com/p/a979f489b47b" target="_blank" rel="noopener">VMware Workstation pro 15破解版安装</a></p><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><p>[root@localhost 图片]$ </p><p>root：该位置表示当前终端登录的用户名</p><p>@：发音at，表示“在”</p><p>localhost：当前登录的主机名</p><p>图片：当前终端工作目录</p><p>#表示身份识别符，管理员登陆时显示#，普通用户显示$;</p><h2 id="关机命令："><a href="#关机命令：" class="headerlink" title="关机命令："></a>关机命令：</h2><p><code>shutdown -h now</code>(正常关机)、<code>halt</code>(关闭内存)、<code>init 0</code></p><h2 id="VMware备份："><a href="#VMware备份：" class="headerlink" title="VMware备份："></a>VMware备份：</h2><p>两种：快照、克隆</p><p>快照：又称还原点，就是保存在拍快照时候的系统的状态（包含了所有的内容），在后期的时候随时可以恢复。【侧重于短期备份，需要频繁备份的时候可以使用快照，做快照的时候虚拟机的操作系统一般处于开启状态】</p><p><img src="/2019/06/12/Linux学习/1.png" alt></p><p><img src="/2019/06/12/Linux学习/2.png" alt></p><p>点击虚拟机 - 快照 - 快照管理器找到刚才建立的快照就可返回刚才的位置；</p><p>克隆：就是复制的意思。【侧重长期备份，做克隆的时候是必须的关闭的】</p><h1 id="三、Linux系统的·文件"><a href="#三、Linux系统的·文件" class="headerlink" title="三、Linux系统的·文件"></a>三、Linux系统的·文件</h1><p>什么是文件？</p><p>一般是一个独立的东西，可以通过一些特定的工具进行打开，并且其中不能包含除了文字以外的东西；</p><p>什么是文件夹？</p><p>可以在其中包含其他文件的东西</p><p><strong>注意：</strong>日常运维工作中，有一半以上的工作内容，其实都是对文件的操作；Linux本身也是一个基于文件形式表示的操作系统；</p><p>Linux一切皆文件</p><p><img src="/2019/06/12/Linux学习/3.png" alt></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>bin：全称binary，含义是二进制。该目录中存储的都是一些二进制文件，文件都是刻意被运行的；</p><p>dev：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能被直接使用的，需要挂载（类似windows下的分配盘符）。</p><p>etc：该目录主要存储一些配置文件</p><p>Home：表示“家”，表示除了root用户以外其他用户的家目录，类似于windows下的user/用户目录</p><p>proc：process，表示进程，该目录中存储的是Linux运行时的进程</p><p>sbin：全称super binary，该目录也是储存一些可以被执行的二进制文件，但是必须得有super权限的用户才能执行</p><p>tmp：表示临时的，当系统运行时候产生的临时文件会在这个目录存储</p><p>usr：存放着用户自己安装的软件。类似于windows下的program files</p><p>var：存放的程序/系统的日志文件的目录</p><p>mnt：当外接设备需要挂载的时候，就需要挂载到mnt目录下。</p><h1 id="四、指令和选项"><a href="#四、指令和选项" class="headerlink" title="四、指令和选项"></a>四、指令和选项</h1><p>什么是指令？</p><p>指的是Linux终端（命令行）中输入的内容就称之为指令</p><p>Linux通用指令格式：</p><pre><code>#指令主体 [选项] [操作对象]</code></pre><p>一个指令可以包含多个选项，操作对象也可以是多个</p><h1 id="五、基础指令"><a href="#五、基础指令" class="headerlink" title="五、基础指令"></a>五、基础指令</h1><h2 id="1-ls指令"><a href="#1-ls指令" class="headerlink" title="1.ls指令"></a>1.ls指令</h2><p>含义：ls（list）</p><p>用法1：<code>#ls</code> ——&gt;含义：列出当前工作目录下的所有文件/文件夹的名称</p><p>用法2：<code>#ls 路径</code> ——&gt;含义：列出指定路径下的所有文件/文件夹的名称</p><p>路径分为两种：相对路径、绝对路径</p><p>相对路径：相对首先要有一个参照物（一般是当前的工作路径）</p><p>​    “./“(当前路径)和”../(上一级路径)”</p><p>绝对路径：绝对路径不需要参照物，直接从根“/”开始寻找对应路劲</p><p><img src="/2019/06/12/Linux学习/4.png" alt></p><p>用法3：<code>#ls 选项 路径</code>——&gt;含义：在列出指定路径下的文件夹/文件的名称，并以指定的格式进行显示</p><p>选项：</p><p>​    -l：表示list，表示以详细列表的形式进行展示</p><p>​    -a：表示显示所有的文件/文件夹（包含了隐藏文件/文件夹）</p><p><img src="/2019/06/12/Linux学习/5.png" alt></p><p>上述列表中第一列字符表示文档的类型，其中”-“表示该行对应的文档类型是文件，”d”表示文档类型为文件夹</p><p>在Linux中隐藏文档一般都是以”.”开头</p><p>用法4：<code>#ls -lh 路径</code>——&gt;含义：列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的时候以可读性较高的形式显示</p><p><img src="/2019/06/12/Linux学习/6.png" alt></p><p>文件夹不管实际大小是多少一般都是显示4k大小</p><h2 id="2-pwd指令"><a href="#2-pwd指令" class="headerlink" title="2.pwd指令"></a>2.pwd指令</h2><p>用法：<code>#pwd</code>(print working directory,打印当前工作目录)</p><p><img src="/2019/06/12/Linux学习/7.png" alt></p><h2 id="3-cd命令"><a href="#3-cd命令" class="headerlink" title="3.cd命令"></a>3.cd命令</h2><p>用法：<code>#cd 路径</code>（change directory，改变目录）</p><p><img src="/2019/06/12/Linux学习/8.png" alt></p><p>在Linux中有一个特殊的符号”~”，表示当前用户的家目录。</p><p><img src="/2019/06/12/Linux学习/9.png" alt></p><h2 id="4-mkdir指令"><a href="#4-mkdir指令" class="headerlink" title="4.mkdir指令"></a>4.mkdir指令</h2><p>用法1：<code>#mkdir 路径</code> (make directory，创建目录)；路径可以是文件夹名称也可以是包含名称的一个完整路径</p><p><img src="/2019/06/12/Linux学习/10.png" alt></p><p><img src="/2019/06/12/Linux学习/11.png" alt></p><p><strong>注意：ls列出的结果颜色说明，其中蓝色的名称表示文件夹，黑色的表示文件，绿色的其权限为拥有所有权限</strong></p><p>用法2：<code>#mkdir -p 路径</code>——&gt;含义：当一次性创建多层不存在的目录的时候，添加-p参数，否则会报错</p><p><img src="/2019/06/12/Linux学习/12.png" alt></p><p>用法3：<code>#mkdir 路径1 路径2 路径3......</code>——&gt;含义：表示一次性创建多个目录</p><h2 id="5-touch命令"><a href="#5-touch命令" class="headerlink" title="5.touch命令"></a>5.touch命令</h2><p>用法：<code>#touch 文件路径</code> ——&gt;含义：创建文件；路径可以是直接的文件名也可以是路径</p><p><img src="/2019/06/12/Linux学习/13.png" alt></p><p>用touch创建多个文件</p><p><img src="/2019/06/12/Linux学习/14.png" alt></p><h2 id="6-cp指令"><a href="#6-cp指令" class="headerlink" title="6.cp指令"></a>6.cp指令</h2><p>用法：<code>#cp 源路径 目的路径</code>（copy，复制）</p><p>含义：复制文件/文件夹到指定位置的位置</p><p><img src="/2019/06/12/Linux学习/15.png" alt></p><p><strong>注意：Linux在复制过程中是可以重新对新位置的文件进行重命名的，但是如果不是必须的需要，则建议保持前后名称一致；cp命令进行文件夹复制操作的时候需要添加选项“-r”【-r表示递归复制】,否则目录将被忽略</strong></p><p><img src="/2019/06/12/Linux学习/16.png" alt></p><h2 id="7-指令"><a href="#7-指令" class="headerlink" title="7.指令"></a>7.指令</h2><p>用法：<code>#mv 源路径 目的路径</code>(move，移动，剪切)</p><p>含义：移动文档到新的位置</p><p><img src="/2019/06/12/Linux学习/17.png" alt></p><p>补充：Linux中重命名也是mv，语法和移动一样</p><p><img src="/2019/06/12/Linux学习/18.png" alt></p><h2 id="8-rm指令"><a href="#8-rm指令" class="headerlink" title="8.rm指令"></a>8.rm指令</h2><p>rm（remove，移除、删除）</p><p>作用：移除/删除文档</p><p>语法：<code>#rm 选项 需要移除的文档路径</code> </p><p>选项：</p><p>​    -f：强制删除，不提示是否删除</p><p>​    -r：表示递归</p><p><strong>注意：删除一个目录的时候需要做递归删除，并且一般也不需要进行删除确认询问，所以移除目录的时候一般需要使用-rf选项</strong></p><p><img src="/2019/06/12/Linux学习/19.png" alt></p><p><code>*</code>为通配符，表示任意的字符</p><h2 id="9-vim命令"><a href="#9-vim命令" class="headerlink" title="9.vim命令"></a>9.vim命令</h2><p>vim（是一款文本编辑器）</p><p>语法：<code>#vim 文件路径</code></p><p>作用：打开一个文件（可以不存在，也可以存在）</p><p><code>i</code>键表示插入模式进行编辑，<code>ESC</code>表示退出编辑模式，再输入<code>:wq</code></p><h2 id="10-输出重定向"><a href="#10-输出重定向" class="headerlink" title="10.输出重定向"></a>10.输出重定向</h2><p>一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术</p><p><code>&gt;</code>：覆盖输出，会覆盖掉原先的文件内容</p><p><code>&gt;&gt;</code>：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加</p><p>语法：<code>#正常执行的命令 &gt;/&gt;&gt; 文件的路径</code></p><p>注意：文件可以不存在，不存在则新建</p><p><img src="/2019/06/12/Linux学习/22.png" alt></p><p><img src="/2019/06/12/Linux学习/20.png" alt></p><p><img src="/2019/06/12/Linux学习/21.png" alt></p><h2 id="11-cat指令"><a href="#11-cat指令" class="headerlink" title="11.cat指令"></a>11.cat指令</h2><p>作用：cat有直接打开一个文件的功能</p><p>语法：<code>#cat 文件的路径</code></p><p><img src="/2019/06/12/Linux学习/23.png" alt></p><p>作用：cat还可以对文件进行合并</p><p>语法：<code>#cat 待合并的文件路径1 待合并的文件路径2 ...... 文件路径n &gt; 合并之后的文件路径</code></p><p><img src="/2019/06/12/Linux学习/24.png" alt></p><h1 id="六、进阶命令（重点）"><a href="#六、进阶命令（重点）" class="headerlink" title="六、进阶命令（重点）"></a>六、进阶命令（重点）</h1><h2 id="1-df指令"><a href="#1-df指令" class="headerlink" title="1.df指令"></a>1.df指令</h2><p>作用：查看磁盘的空间</p><p>语法：<code>#df -h</code>表示以可读性较高的形式展示大小</p><p><img src="/2019/06/12/Linux学习/25.png" alt></p><h2 id="2-free指令"><a href="#2-free指令" class="headerlink" title="2.free指令"></a>2.free指令</h2><p>作用：查看内存使用情况</p><p>语法：<code>#free -m</code>,-m是以兆（MB）为单位显示</p><p><img src="/2019/06/12/Linux学习/26.png" alt></p><p>Swap：用于临时内存，当系统真实内存不够用的时侯可以临时使用磁盘空间来充当内存</p><h2 id="3-head指令"><a href="#3-head指令" class="headerlink" title="3.head指令"></a>3.head指令</h2><p>作用：查看一个文件的前n行，如果不指定n，则默认显示前10行。</p><p>语法：<code>#head -n 文件路径</code>【n表示数字】</p><p><img src="/2019/06/12/Linux学习/27.png" alt></p><h2 id="4-tail指令"><a href="#4-tail指令" class="headerlink" title="4.tail指令"></a>4.tail指令</h2><p>作用：查看一个文件的末n行，如果n不指定默认显示后10行</p><p>语法：<code>#tail -n 文件路劲</code> 【n表示数字】</p><p><img src="/2019/06/12/Linux学习/28.png" alt></p><p>作用：可以通过tail指令来查看一个文件的动态变化</p><p>语法：<code>#tail -f 文件路径</code></p><p>一般用于查看系统的日志比较多</p><p><img src="/2019/06/12/Linux学习/31.png" alt></p><p>q键退出即可</p><h2 id="5-less指令"><a href="#5-less指令" class="headerlink" title="5.less指令"></a>5.less指令</h2><p>作用：查看文件，以较少的内容进行输出，按下辅助功能键（数字+回车（从数字行开始显示）、空格键（翻页）、方向键（换行显示））查看更多</p><p>语法：<code>#less 需要查看的文件路径</code></p><p><img src="/2019/06/12/Linux学习/29.png" alt></p><h2 id="6-wc指令"><a href="#6-wc指令" class="headerlink" title="6.wc指令"></a>6.wc指令</h2><p>作用：统计文件内容信息（包含行数、单词数、字节数）</p><p>语法：<code>#wc [选项] 需要统计的文件路劲</code></p><p>选项：</p><p>​    -l：表示lines，行数</p><p>​    -w：表示words，单词数 【依照空格来判断单词数量】</p><p>​    -c：表示bytes，字节数</p><p><img src="/2019/06/12/Linux学习/30.png" alt></p><h2 id="7-date指令（重点）"><a href="#7-date指令（重点）" class="headerlink" title="7.date指令（重点）"></a>7.date指令（重点）</h2><p>作用：表示操作时间日期（读取、设置）</p><p>语法：<code>#date</code></p><p>语法：<code>#date +%F</code> (等价于#date “+%Y-%m-%d”)</p><p>语法：<code>#date &quot;+%F %T&quot;</code> (等价于#date “+%Y-%m-%d %H:%M:%S”)引号表示让“年月日与时分秒”成为一个不可分割的整体</p><p><img src="/2019/06/12/Linux学习/32.png" alt></p><p>作用：获取之前或者之后的某个时间（备份）</p><p>语法：<code>#date -d &quot;-1 day&quot; &quot;+%Y-%m-%d %H:%M:%S&quot;</code></p><p>符号的可选值：+（之后）/ -（之后）</p><p>单位可选值：day（天）、month（月份）、year（年）</p><p><img src="/2019/06/12/Linux学习/33.png" alt></p><table><thead><tr><th>%F</th><th>表示完整的年月日</th></tr></thead><tbody><tr><td>%T</td><td>表示完整的的时分秒</td></tr><tr><td>%Y</td><td>表示四位年份</td></tr><tr><td>%m</td><td>表示两位月份（带前导0）</td></tr><tr><td>%d</td><td>表示日期（带前导0）</td></tr><tr><td>%H</td><td>表示小时（带前导0）</td></tr><tr><td>%M</td><td>表示分钟（带前导0）</td></tr><tr><td>%S</td><td>表示秒数（带前导0）</td></tr></tbody></table><h2 id="8-cal指令"><a href="#8-cal指令" class="headerlink" title="8.cal指令"></a>8.cal指令</h2><p>作用：用来操作日历</p><p>语法：<code>#cal</code>等价于<code>#cal -1</code>直接输出当前月份的日历</p><p>语法：<code>#cal -3</code>表示输出上一个月+本月+下一个月的日历</p><p>语法：<code>#cal -y 年份</code>表示输出某一个年份的日历</p><p><img src="/2019/06/12/Linux学习/34.png" alt></p><h2 id="9-clear-ctrl-L指令"><a href="#9-clear-ctrl-L指令" class="headerlink" title="9.clear / ctrl + L指令"></a>9.clear / ctrl + L指令</h2><p>作用：清除终端中已存在的命令和结果（信息）清屏</p><p>语法：<code>#clear</code>       或者快捷键：<code>ctrl+L</code></p><p><strong>注意：</strong>该命令并不是真的清除了之前的信息，而是把之前的信息的隐藏到了最上面，通过滚动条继续查看以前的信息。</p><h2 id="10-管道-重要"><a href="#10-管道-重要" class="headerlink" title="10.管道(重要)"></a>10.管道(重要)</h2><p>管道符：<code>|</code></p><p>作用：管道一般可以用于“过滤”，“特殊”，“扩展处理”。</p><p>语法：管道不能单独使用，必须要配合前面所讲的一些指令使用，其作用主要是辅助作用。</p><p><code>#ls /| grep y</code> 以管道作为分界线，前面的命令有个输出，后面需要输入，然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入。</p><p><code>grep</code>指令：主要用于过滤</p><p><img src="/2019/06/12/Linux学习/35.png" alt></p><p>特殊用法案例：通过管道的操作方法来实现less的等价效果（了解）</p><p><code>#less 路径</code> == <code>#cat 路径 | less</code></p><p><img src="/2019/06/12/Linux学习/36.png" alt></p><hr><h1 id="七、高级指令"><a href="#七、高级指令" class="headerlink" title="七、高级指令"></a>七、高级指令</h1><h2 id="1-hostname指令"><a href="#1-hostname指令" class="headerlink" title="1.hostname指令"></a>1.hostname指令</h2><p>作用：操作服务器的主机名（读取、设置）</p><p>语法：<code>#hostname</code> ——含义：表示输出完整的主机名</p><p>语法：<code>#hostname -f</code> ——含义：表示输出当前主机名中的FQDN（全限定域名）</p><p><img src="/2019/06/12/Linux学习/37.png" alt></p><h2 id="2-id命令"><a href="#2-id命令" class="headerlink" title="2.id命令"></a>2.id命令</h2><p>作用：查看一个用户的一些基本信息（包含用户id，用户组id，附加组id…），该指令如果不指定用户则默认当前用户。</p><p>语法1：<code>#id</code> 默认显示当前执行该命令的用户的基本信息</p><p>语法2：<code>#id 用户名</code>显示指定用户的基本信息</p><p>验证上述信息是否正确？</p><p>验证用户信息：通过文件/etc/paswd</p><p>验证用户组信息：通过文件/etc/group</p><p><img src="/2019/06/12/Linux学习/38.png" alt></p><h2 id="3-whoami指令"><a href="#3-whoami指令" class="headerlink" title="3.whoami指令"></a>3.whoami指令</h2><p>作用：“我是谁？”显示当前登录的用户名，一般用于shell脚本,用于获取当前操作的用户名方便记录日志。</p><p>语法：<code>#whoami</code></p><p><img src="/2019/06/12/Linux学习/39.png" alt></p><h2 id="4-ps-ef指令（重点）"><a href="#4-ps-ef指令（重点）" class="headerlink" title="4.ps  -ef指令（重点）"></a>4.ps  -ef指令（重点）</h2><p>指令：ps</p><p>作用：主要是查看服务器的进程信息</p><p>选项含义：</p><p>​    -e：等价于“-A”，表示列出全部的进程信息</p><p>​    -f：显示全部列（显示全字段）</p><p><img src="/2019/06/12/Linux学习/40.png" alt></p><p>列的含义：</p><p>​    UID：该进程执行的用户id；</p><p>​    PID：进程id；</p><p>​    PPID：该进程的父级进程id，如果一个程序的父进程找不到，该程序的进程称之为僵尸进程；</p><p>​    C：CPU的占用率，其形式是百分数；</p><p>​    STIME：进行的启动时间；</p><p>​    TIY：终端设备，发起该进程的设备识别符号，如果显示“？”，则表示该进程并不是由终端设备发起；</p><p>​    TIME：进程执行的时间；</p><p>​    CMD：该进程的名称或者对应的路径；</p><p><img src="/2019/06/12/Linux学习/41.png" alt></p><h2 id="5-top指令（重点）"><a href="#5-top指令（重点）" class="headerlink" title="5.top指令（重点）"></a>5.top指令（重点）</h2><p>作用：查看服务器的进程占的资源</p><p>语法：</p><p>​    进入命令：<code>#top</code>  (动态显示)</p><p>​    退出命令：按下q键</p><p><img src="/2019/06/12/Linux学习/42.png" alt></p><p>表头含义：</p><p>PID：进程id；</p><p>USER：该进程对应的用户；</p><p>PR：优先级；</p><p>VIRT：虚拟内存；</p><p>RES：常驻内存；</p><p>SHR：共享内存；</p><p>​    计算一个进程实际使用的内存 = 常驻内存（RES）-共享内存（SHR）</p><p>S：表示进行的状态[sleeping,其中S表示睡眠，R表示运行]；</p><p>%CPU：表示cpu的占用百分比；</p><p>%MEM：表示内存的占用百分比；</p><p>TIME+：执行的时间；</p><p>COMMAND：进程的名称或者路径；</p><p>在运行top的时候，可以按下方便的快捷键：</p><p>M：表示将结果按照内存（MEM）从高到低进行降序排列；</p><p>P：表示将结果按照CPU使用率从高到低进行降序排列；</p><p>1：当服务器拥有多个cpu的时候可以使用“1”快捷键来切换是否展示显示各个CPU的详细信息。</p><h2 id="6-du-sh命令"><a href="#6-du-sh命令" class="headerlink" title="6.du-sh命令"></a>6.du-sh命令</h2><p>作用：查看目录的真实大小</p><p>语法：<code>#du -sh 目录路径</code></p><p>选项含义：</p><p>​    -s：summaries，只显示汇总的大小</p><p>​    -h：表示以较高的可读性的形式进行显示</p><p><img src="/2019/06/12/Linux学习/43.png" alt></p><h2 id="7-find指令"><a href="#7-find指令" class="headerlink" title="7.find指令"></a>7.find指令</h2><p>作用：用于查找文件（其参数有55个之多）</p><p>语法：<code>#find 路径范围 选项 选项的值</code></p><p>选项：</p><p>​    -name：按照文档名称进行搜索（支持模糊搜索）</p><p>​    -type：按照文档的类型进行搜索</p><p>文档类型：”_”表示文件（在使用find的时候需要f来替换），“d”表示文件夹；</p><p><img src="/2019/06/12/Linux学习/44.png" alt></p><p><img src="/2019/06/12/Linux学习/45.png" alt></p><h2 id="8-service指令（重点）"><a href="#8-service指令（重点）" class="headerlink" title="8.service指令（重点）"></a>8.service指令（重点）</h2><p>作用：用于控制一些软件的服务启动/停止/重启</p><p>语法：<code>#service 服务名 start/stop/restart</code></p><h2 id="9-kill指令（重点）"><a href="#9-kill指令（重点）" class="headerlink" title="9.kill指令（重点）"></a>9.kill指令（重点）</h2><p>作用：表示杀死进程（当遇到僵尸进程或者出于某些原因需要关闭进程的时候）</p><p>语法：<code>#kill 进程 PID</code>（语法需要配合<code>ps -ef</code>一起使用）</p><p><img src="/2019/06/12/Linux学习/46.png" alt></p><p>与kill命令作用相似但是比kill更加好用的杀死进程的命令：<code>killall</code></p><p>语法：<code>killall 进程名称</code></p><p><img src="/2019/06/12/Linux学习/47.png" alt></p><h2 id="10-ifconfig指令（重点）"><a href="#10-ifconfig指令（重点）" class="headerlink" title="10.ifconfig指令（重点）"></a>10.ifconfig指令（重点）</h2><p>作用：用于操作网卡相关的指令</p><p>简单语法：<code>#ifconfig</code>（获取网卡信息）</p><p>Eth0表示Linux中的一个网卡，eth0是其名称。Lo（loop，本地回环网卡，其IP地址一般都是127.0.0.1）也是一个网卡名称。</p><p><img src="/2019/06/12/Linux学习/48.png" alt></p><p>其中inet是网卡的IP地址</p><h2 id="11-reboot指令"><a href="#11-reboot指令" class="headerlink" title="11.reboot指令"></a>11.reboot指令</h2><p>作用：重新启动计算机</p><p>语法：<code>#reboot</code> 重启</p><p>语法：<code>#reboot -w</code>模拟重启，但是不重启（只写关机与开机的日志信息）</p><p><img src="/2019/06/12/Linux学习/49.png" alt></p><h2 id="12-shutdown指令"><a href="#12-shutdown指令" class="headerlink" title="12.shutdown指令"></a>12.shutdown指令</h2><p>作用：关机（慎用）</p><p>语法1：<code>#shutdown -h now &quot;提示&quot;</code> 或者 <code>#shutdown -h 12:00 &quot;提示&quot;</code></p><p> <img src="/2019/06/12/Linux学习/50.png" alt></p><p>如果想要取消关机计划的话，则可以按照以下方式去尝试：</p><ol><li>针对于centos7.x之前的版本：ctrl+c</li><li>针对于centos7.x（包含）之后的版本：<code>#shutdown -c</code></li></ol><p>除了shutdown关机以外，还有以下几个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#init 0</span><br><span class="line">#halt</span><br><span class="line">#poweoff</span><br></pre></td></tr></table></figure><h2 id="13-uptime指令"><a href="#13-uptime指令" class="headerlink" title="13.uptime指令"></a>13.uptime指令</h2><p>作用：输出计算机的持续在线时间（计算机从开机到现在运行的时间）</p><p>语法：<code>#uptime</code></p><h2 id="14-uname指令"><a href="#14-uname指令" class="headerlink" title="14.uname指令"></a>14.uname指令</h2><p>作用：获取计算机操作系统相关信息</p><p>语法1：<code>#uname</code> 获取操作系统的类型</p><p>语法2：<code>#uname -a</code> all,表示获取全部的系统信息（类型、全部主机名、内核版本、发布时间、开源计划）</p><p><img src="/2019/06/12/Linux学习/51.png" alt></p><h2 id="15-netstat-tnlp指令"><a href="#15-netstat-tnlp指令" class="headerlink" title="15.netstat  -tnlp指令"></a>15.netstat  -tnlp指令</h2><p>作用：查看网络连接状态</p><p>语法：<code>#netstat -tnlp</code></p><p><img src="/2019/06/12/Linux学习/52.png" alt></p><p>选项说明：</p><p>​    -t：表示只列出tcp协议的连接</p><p>​    -n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示；</p><p>​    -l：表示过滤出“state（状态）”列中其值为LISTEN（监听）的连接；</p><p>​    -p：表示显示发起连接的进程pid和进程名称；</p><h2 id="16-man指令"><a href="#16-man指令" class="headerlink" title="16.man指令"></a>16.man指令</h2><p>作用：manual，手册（包含了Linux中全部命令手册，英文）</p><p>语法：<code>#man 命令</code>（退出按下q键）</p><p><img src="/2019/06/12/Linux学习/53.png" alt></p><hr><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><p>1.如何通过命令行重启linux操作系统？<code>#reboot</code></p><p>2.如何在命令行中快速删除光标前/后的内容？前：<code>ctrl+u</code> 后：<code>ctrl+k</code></p><p>3.如何删除/tmp下所有A开头的文件？ <code>#rm -f /tmp/A*</code></p><p>4.系统重要文件需要备份，如何使用/etc/passwd备份到/tmp目录下？ <code>#cp /etc/passwd /tmp/</code></p><p>5.如何查看系统最后创建的3个用户？ <code>#tail -3 /etc/passwd</code></p><p>6.什么命令可以统计当前系统中一共有多少账户？ <code>#wc -l /etc/passwd</code>  或者<code>#cat /etc/passwd|wc -l</code></p><p>7.如何创建/tmp/test.conf文件？ <code>#touch /tmp/test.conf</code></p><p>8.如何通过vim编辑打开/tmp/test.conf?  <code>#vim /tmp/test.conf</code></p><p>9.如何查看/etc/passwd的头3行和尾3行？ <code>#head -3 /etc/passwd</code>   和<code>#tail -3 /etc/passwd</code></p><p>10.如何一次性创建目录/text/1/2/3/4？<code>#mkdir -p /text/1/2/3/4</code></p><p>11.如何最快的返回到当前账户的家目录？<code>#cd ~</code>   或 <code>#cd</code></p><p>12.如何查看/etc/所占的磁盘空间？<code>#du -sh /etc</code></p><p>13.如何删除/tmp下所有的文件？ <code>#rm -rf /tmp/*</code></p><p>14.尝试启动Apache的服务，并且检查是否启动成功？ <code>#service httpd start</code>   <code>#ps -ef|grep httpd</code></p><p>15.使用已学习命令杀死Apache的进程。 <code>#killall httpd</code></p><hr><h1 id="八、vim的介绍"><a href="#八、vim的介绍" class="headerlink" title="八、vim的介绍"></a>八、vim的介绍</h1><p>vi是所有unix和Linux系统下的标准编辑器。</p><p>vi和vim都是linux中的编辑器，不同的是，vim比较高级，可以视为vi的升级版本。vi使用于文本编辑，但是vim更适用于coding。vim重点是光标的移动，模式切换店，删除，查找替换，复制，粘贴，撤销命令的使用。</p><h1 id="九、vim三种模式（重点）"><a href="#九、vim三种模式（重点）" class="headerlink" title="九、vim三种模式（重点）"></a>九、vim三种模式（重点）</h1><p>vim中存在三种模式（大众的认知）：命令模式、编辑模式（输入模式）、末行模式（尾行模式）。</p><p>命令模式：在该模式下是不能对文件直接编辑，可以输入快捷键进行一些操作（删除行，复制行，移动光标，粘贴等等），打开文件之后默认进入模式；</p><p>编辑模式：在该模式下可以对文件的内容进行编辑；</p><p>末行模式：可以在末行输入命令来对文件进行操作（搜索、替换、保存、退出、撤销、高亮等等）；</p><p>vim的打开文件的方式（4种，要求掌握的就前三种）：</p><p><code>#vim 文件路径</code> 作用：打开指定的文件</p><p><code>#vim +数字 文件的路径</code> 作用：打开指定文件，并且将光标移动到指定行</p><p><code>#vim +/关键词 文件的路径</code> 作用：打开指定的文件，并且高亮显示关键词</p><p><code>#vim 文件路径1 文件路径2 文件路径3</code> 作用：同时打开多个文件</p><p><img src="/2019/06/12/Linux学习/54.png" alt></p><p><img src="/2019/06/12/Linux学习/55.png" alt></p><h1 id="十、命令模式"><a href="#十、命令模式" class="headerlink" title="十、命令模式"></a>十、命令模式</h1><h2 id="1-光标移动"><a href="#1-光标移动" class="headerlink" title="1.光标移动"></a>1.光标移动</h2><p>a.光标移动到行首</p><p>快捷键：shift + 6 或 ^（T字母上面的6，不要按小键盘的6）</p><p>b.光标移动到行尾</p><p>快捷键：shift + 4 或 $（R字母的左上角的4，不是小键盘的4）</p><p><img src="/2019/06/12/Linux学习/56.png" alt></p><p>c.光标移动到首行</p><p>快捷键：gg</p><p>d.光标移动到末行</p><p>快捷键：G</p><p><img src="/2019/06/12/Linux学习/57.png" alt></p><p>e：翻屏</p><p>向上翻屏：快捷键 ctrl + b 或 PgUp</p><p>向下翻屏：快捷键 ctrl + f  或 PgDn</p><p><img src="/2019/06/12/Linux学习/58.png" alt></p><h2 id="2-复制操作"><a href="#2-复制操作" class="headerlink" title="2.复制操作"></a>2.复制操作</h2><ol><li><p>复制光标所在行</p><p>快捷键：yy</p><p>粘贴：在想要粘贴的地方按下p键</p></li><li><p>以光标所在行为准（包含当前行），向下复制指定的行数</p><p>快捷键：数字yy</p></li><li><p>可视化复制</p><p>快捷键：ctrl + v，然后按下方向键来选中要复制的区块，按下yy键进行复制，最后按下p键粘贴</p></li></ol><h2 id="3-剪切-删除"><a href="#3-剪切-删除" class="headerlink" title="3.剪切/删除"></a>3.剪切/删除</h2><ol><li><p>剪切/删除光标所在行</p><p>快捷键：dd                    （删除之后下一行上移）</p><p>注意：dd严格意义上说是剪切命令，但是如果剪切了不粘贴就是删除的效果。</p></li><li><p>剪切/删除光标所在行为准（包含当前行），向下删除/剪切指定的行</p><p>快捷键：数字dd               （删除之后下一行上移）</p></li><li><p>剪切/删除光标所在当前行，但是删除之后下一行不上移</p><p>快捷键：D                           （删除之后当前行会变成空白行）</p></li></ol><h2 id="4-撤销-恢复"><a href="#4-撤销-恢复" class="headerlink" title="4.撤销/恢复"></a>4.撤销/恢复</h2><p>撤销：输入<code>:u</code>（不属于命令模式） 或者 <code>u</code>            (undo)</p><p>恢复：ctrl + r             恢复（取消）之前的撤销操作</p><h2 id="5-光标的快速移动"><a href="#5-光标的快速移动" class="headerlink" title="5.光标的快速移动"></a>5.光标的快速移动</h2><ol><li><p>快速将光标移动到指定的行</p><p>快捷键：数字 G</p></li><li><p>以当前光标为准向上/向下移动n行</p><p>快捷键：数字👆，数字👇</p></li><li><p>以当前光标为准向左/向右移动n字符</p><p>快捷键：数字👈，数字👉</p></li><li><p>末行模式下的快速移动方式：移动到指定的行</p><p>快捷键：输入英文“:”，其后输入行数数字，按下回车</p></li></ol><h1 id="十一、模式间的切换"><a href="#十一、模式间的切换" class="headerlink" title="十一、模式间的切换"></a>十一、模式间的切换</h1><p><img src="/2019/06/12/Linux学习/59.png" alt></p><h1 id="十二、末行模式"><a href="#十二、末行模式" class="headerlink" title="十二、末行模式"></a>十二、末行模式</h1><p>进入方式：由命令模式进入，按下“:”或者“/（主要是搜索）”即可进入</p><p>退出方式：</p><ol><li>按一次esc</li><li>按二次esc</li><li>删除末行全部输入字符</li></ol><h2 id="1-保存操作（write）"><a href="#1-保存操作（write）" class="headerlink" title="1.保存操作（write）"></a>1.保存操作（write）</h2><p>输入：<code>:w</code>                 保存文件</p><p>输入：<code>:w 路径</code>         另存为</p><h2 id="2-退出（quit）"><a href="#2-退出（quit）" class="headerlink" title="2.退出（quit）"></a>2.退出（quit）</h2><p>输入：<code>:q</code>                  退出文件</p><h2 id="3-保存并退出"><a href="#3-保存并退出" class="headerlink" title="3.保存并退出"></a>3.保存并退出</h2><p>输入：<code>:wq</code>                 保存并且退出</p><h2 id="4-强制（-）"><a href="#4-强制（-）" class="headerlink" title="4.强制（!）"></a>4.强制（!）</h2><p>输入：<code>:q!</code>                 表示强制退出，刚才做的修改操作不做保存</p><h2 id="5-调用外部命令（了解）"><a href="#5-调用外部命令（了解）" class="headerlink" title="5.调用外部命令（了解）"></a>5.调用外部命令（了解）</h2><p>输入：<code>:!外部命令</code></p><h2 id="6-搜索-查找"><a href="#6-搜索-查找" class="headerlink" title="6.搜索/查找"></a>6.搜索/查找</h2><p>输入：<code>/关键词</code></p><p>在搜索结果中切换上/下一个结果：N/n            （next）</p><p>如果需要取消高亮，则需要输入：<code>:nohl</code>    (no highlight)</p><h2 id="7-替换"><a href="#7-替换" class="headerlink" title="7.替换"></a>7.替换</h2><p><code>:s/搜索的关键词/新的内容</code>                    替换光标所在行的第一处符合条件的内容</p><p><code>:s/搜索的关键词/新的内容/g</code>                  替换光标所在行的全部符合条件的内容</p><p><code>:%s/搜索的关键词/新的内容</code>                    替换整个文档中每行第一个符合条件的内容</p><p><code>:%s/搜索的关键词/新的内容/g</code>                 替换整个文档的符合条件的内容</p><p>%表示整个文件，g表示全局（global）</p><h2 id="8-显示行号"><a href="#8-显示行号" class="headerlink" title="8.显示行号"></a>8.显示行号</h2><p>输入：<code>:set nu</code>     (number)</p><p>如果想取消显示，则输入：<code>:set nonu</code></p><h2 id="9-使用vim同时打开多个文件，在末行模式下进行切换文件"><a href="#9-使用vim同时打开多个文件，在末行模式下进行切换文件" class="headerlink" title="9.使用vim同时打开多个文件，在末行模式下进行切换文件"></a>9.使用vim同时打开多个文件，在末行模式下进行切换文件</h2><p>查看当前已经打开的文件的名称：<code>:files</code></p><p><img src="/2019/06/12/Linux学习/60.png" alt></p><p>在%a的位置有2种显示可能</p><p>%a：a=active，表示当前正在打开的文件；</p><p>#；表示上一个打开的文件</p><p>切换文件的方式：</p><ol><li><p>如果需要指定切换文件的名称，则可以输入：<code>:open 文件名称</code></p><p><img src="/2019/06/12/Linux学习/61.png" alt></p></li><li><p>可以通过其他命令来切换上一个文件/下一个文件</p><p>输入：<code>:bn</code> 切换到下一个文件（back next）</p><p>输入：<code>:bp</code> 切换到上一个文件（back previous）</p></li></ol><h1 id="十三、编辑模式"><a href="#十三、编辑模式" class="headerlink" title="十三、编辑模式"></a>十三、编辑模式</h1><p>进入方式：</p><p>i：在光标所在字符前开始插入</p><p>a：在光标所在字符后开始插入</p><p>o：在光标所在行的下面另起一新行插入</p><p>I：在光标所在行的行首开始插入，如果行首有空格则在空格之后插入</p><p>A：在光标所在行的行尾开始插入</p><p>O：在光标所在行的上面另起一行开始插入</p><p>S：删除光标所在行并开始插入</p><p>重点是i（insert），a（after）</p><h1 id="十四、实用功能"><a href="#十四、实用功能" class="headerlink" title="十四、实用功能"></a>十四、实用功能</h1><h2 id="1-代码着色"><a href="#1-代码着色" class="headerlink" title="1.代码着色"></a>1.代码着色</h2><p>显示：<code>syntax on</code>               syntax(语法)</p><p><img src="/2019/06/12/Linux学习/62.png" alt></p><p>​       关闭显示：<code>syntax off</code></p><p>​       <img src="/2019/06/12/Linux学习/63.png" alt></p><h2 id="2-vim中计算器的使用"><a href="#2-vim中计算器的使用" class="headerlink" title="2.vim中计算器的使用"></a>2.vim中计算器的使用</h2><p>当在编辑文件的时候需要使用计算器去计算一些公式，则此时需要用到计算器，但是需要退出，vim自身集成了一个简易的计算器。</p><p>a.进入编辑模式</p><p>b.按下按键“ctrl + R”，然后输入“=”，此时光标会变到最后一行</p><p>c.输入需要计算的内容，按下回车</p><p><img src="/2019/06/12/Linux学习/blog\smallpotatody.github.io\source\_posts\Linux学习\64.png" alt></p><h1 id="十五、扩展"><a href="#十五、扩展" class="headerlink" title="十五、扩展"></a>十五、扩展</h1><h2 id="1-vim的配置（重点）"><a href="#1-vim的配置（重点）" class="headerlink" title="1.vim的配置（重点）"></a>1.vim的配置（重点）</h2><p>vim配置有三种情况：</p><p>​    a.在文件打开的时侯在末行模式下输入的配置（临时的）</p><p>​    b.个人配置文件（~/.vimrc，如果没有可以自行新建）</p><p>​    c.全局配置文件（vim自带，/etc/vimrc）</p><p>新建好个人配置文件之后进行编辑</p><p>在配置文件中进行配置</p><p>比如显示行号：set nu</p><p><img src="/2019/06/12/Linux学习/65.png" alt></p><p>配置好之后打开文件就会永远显示行号</p><p><strong>配置文件优先级：如果针对同一配置项，个人配置文件中存在，则以个人配置文件为准，如果个人配置文件中不存在这一项，则以全局配置文件为准</strong></p><h2 id="2-异常退出"><a href="#2-异常退出" class="headerlink" title="2.异常退出"></a>2.异常退出</h2><p>异常退出：在编辑文件之后并没有正常的去wq（保存退出），而是遇到突然关闭终端或者断电的情况，则会显示下面效果。</p><p><img src="/2019/06/12/Linux学习/66.png" alt></p><p>解决办法：将交换文件（在编辑过程中产生的临时文件）删除即可</p><p><img src="/2019/06/12/Linux学习/67.png" alt></p><h2 id="3-别名机制（实用）"><a href="#3-别名机制（实用）" class="headerlink" title="3.别名机制（实用）"></a>3.别名机制（实用）</h2><p>作用：相当于创建一些属于自己的自定义命令</p><p>别名机制依靠一个别名映射文件：~/.bashrc</p><p><code>vim .bashrc</code>添加<code>alias cls=&#39;clear&#39;</code>即可实现cls为clear的功能</p><p><img src="/2019/06/12/Linux学习/68.png" alt></p><p>注意：如果想新创造的命令生效，必须要重新登录当前用户。</p><p><img src="/2019/06/12/Linux学习/69.png" alt></p><h2 id="4-退出方式"><a href="#4-退出方式" class="headerlink" title="4.退出方式"></a>4.退出方式</h2><p>可以用<code>:q</code>或 <code>:wq</code></p><p>或者<code>:x</code></p><p>说明：</p><ol><li><code>:x</code>在文件没有修改的情况下，表示直接退出，在文件修改的情况下表示保存并退出；</li><li>如果文件没有被修改，但是使用wq进行退出时，则文件的修改时间会被更新；但是如果文件没有被修改，使用x进行退出的话，则文件修改时间不会被更新的；主要是会混淆用户对文件的修改时间的认定。</li></ol><p><strong>建议使用<code>:x</code>来进行对文件的保存退出；X表示对文件进行加密操作，不要使用</strong></p><hr><h1 id="Linux自有服务"><a href="#Linux自有服务" class="headerlink" title="Linux自有服务"></a>Linux自有服务</h1><p>自有服务：即不需要用户独立安装的服务，而是当系统安装好之后就可以直接使用的服务（内置）</p><h1 id="一、运行模式"><a href="#一、运行模式" class="headerlink" title="一、运行模式"></a>一、运行模式</h1><p>运行模式也可称之为运行级别</p><p>在Linux中存在一个进程：init（initialize，初始化），进程id是1；</p><p>查看init进程：<code>#ps -ef | grep init</code></p><p><img src="/2019/06/12/Linux学习/70.png" alt></p><p>该进程存在一个对应的配置文件：inittab（系统运行级别配置文件，位置/etc/inittab）</p><p>文件主要内容：</p><p><img src="/2019/06/12/Linux学习/71.png" alt></p><p><img src="/2019/06/12/Linux学习/72.png" alt></p><p>0  -表示关机级别（不要将默认的运行级别设置成这个值）</p><p>1  -单用户模式</p><p>2  -多用户模式，不带NFS（Network File Syetem)</p><p>3   -完全多用户模式</p><p>4   -没有被使用的模式（被保留模式）</p><p>5    -X11，完整的图形化界面模式</p><p>6    -表示重启级别（不要将默认的运行级别设置成这个值）</p><p>与该级别相关的几个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#init 0                 表示关机</span><br><span class="line">#init 3                 表示切换到不带桌面的模式</span><br><span class="line">#init 5                 切换到图形界面</span><br><span class="line">#init 6                 重启电脑</span><br></pre></td></tr></table></figure><p>注意：init指令需要超级管理员的权限，普通用户无法执行。</p><p>这些命令其实都是调用的init进程，将数字（运行级别）传递给进程，进程去读配置文件执行对应的操作。</p><h2 id="1-切换到纯命令模式下-临时切换，重启之后又恢复"><a href="#1-切换到纯命令模式下-临时切换，重启之后又恢复" class="headerlink" title="1.切换到纯命令模式下(临时切换，重启之后又恢复)"></a>1.切换到纯命令模式下(临时切换，重启之后又恢复)</h2><p><code>#init 3</code></p><p><img src="/2019/06/12/Linux学习/73.png" alt></p><p>切换之后需要输入用户名和密码，在输入密码时没有显示输入，只要输入密码正确，回车即可。</p><h2 id="2-回到桌面模式"><a href="#2-回到桌面模式" class="headerlink" title="2.回到桌面模式"></a>2.回到桌面模式</h2><p><code>#init 5</code></p><h2 id="3-设置模式永久为命令行模式"><a href="#3-设置模式永久为命令行模式" class="headerlink" title="3.设置模式永久为命令行模式"></a>3.设置模式永久为命令行模式</h2><p>将/etc/inittab文件中的initdefault值设置为3（<code>id:3:initdefault:</code>），然后重启。</p><p><img src="/2019/06/12/Linux学习/74.png" alt></p><h1 id="二、用户与用户组管理（重点）"><a href="#二、用户与用户组管理（重点）" class="headerlink" title="二、用户与用户组管理（重点）"></a>二、用户与用户组管理（重点）</h1><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统</p><p>要实现用户账号的管理，要完成的工作主要有如下几个方面：</p><p>用户账号的添加、删除、修改以及用户密码的管理</p><p>用户组的管理</p><p>注意三个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd                             储存用户的关键信息</span><br><span class="line">/etc/group                              储存用户组的关键信息</span><br><span class="line">/etc/shadow                             储存用户的密码信息</span><br></pre></td></tr></table></figure><h2 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1.用户管理"></a>1.用户管理</h2><ol><li><p>添加用户</p><p><code>#useradd 选项 用户名</code></p></li></ol><p>常用选项：</p><p>​    -g：表示指定用户的用户主组，选项的值可以是用户组的id，也可以是组名</p><p>​    -G：表示指定用户的用户附加组，选项的值可以是用户组的id，也可以是组名</p><p>​    -u：uid，用户的id（用户的标识符），系统默认会从1000（500）之后按顺序分配uid，如果不想使用系统分配的，可以通过该选项自定义</p><p>​    -c：添加注释</p><p>验证是否成功：</p><p>​    验证/etc/passwd的最后一行，查看是否有创建的用户的信息；</p><p>​    验证是否存在家目录（在centos下创建好用户之后随之产生一个同名家目录);</p><p><img src="/2019/06/12/Linux学习/75.png" alt></p><p>格式：用户名:密码:用户ID:用户组ID:注释:家目录:解释器shell</p><p>用户名：创建新用户名称，后期登录时需要输入；</p><p>密码：此密码位置一般情况下都是“x”，表示密码的占位；</p><p>用户ID：用户的标识符；</p><p>用户组ID：该用户所属的主组ID；</p><p>注释：解释该用户是做什么用的；</p><p>家目录：用户登录进入系统之后默认的位置；</p><p>解释器shell：等待用户进入系统之后，用户输入指令之后，该解释器会收集用户输入的指令，传递给内核处理；</p><p><strong>注意：</strong>在不添加选项的时候，执行useradd之后会执行一系列的操作</p><p>​    a.创建同名家目录</p><p>​    b.创建同名用户组</p><p><img src="/2019/06/12/Linux学习/76.png" alt></p><p><img src="/2019/06/12/Linux学习/77.png" alt></p><p><strong>注意：</strong>查看用户的主组可以查看passwd文件，查看附加组可以查看group文件。</p><ol start="2"><li><p>修改用户</p><p><code>#usermod 选项 用户名</code>（user modify 用户修改）</p></li></ol><p>常用选项：</p><p>​    -g：表示指定用户的用户主组，选项的值可以是用户组的id，也可以是组名</p><p>​    -G：表示指定用户的用户附加组，选项的值可以是用户组的id，也可以是组名</p><p>​    -u：uid，用户的id（用户的标识符），系统默认会从500之后按顺序分配uid，如果不想使用系统分配的，可以通过该选项自定义</p><p>​    -l：修改用户名</p><p>修改用户主组，附加组</p><p><img src="/2019/06/12/Linux学习/78.png" alt></p><p>​    <code>#usermod -l 新的用户名 旧的用户名</code><img src="/2019/06/12/Linux学习/79.png" alt></p><ol start="3"><li><p>设置密码</p><p>Linux不允许没有密码的用户登陆到系统，因此前面创建的用户目前都处于锁定状态，需要设置密码之后才能登录计算机。</p><p><code>#passwd 用户名</code></p><p><img src="/2019/06/12/Linux学习/80.png" alt></p></li></ol><p><strong>切换用户命令：<code>#su [用户名]</code></strong>（switch user）如果用户名不指定则表示切换到root用户</p><p>切换用户需要注意的事项是：</p><p>​    a.从root往普通用户切换不需要密码，但是反之则需要root密码；</p><p>​    b.切换用户之后前后的工作路径是不变的；</p><p>​    c.普通用户没有办法访问root用户家目录，但是反之则可以；</p><p><img src="/2019/06/12/Linux学习/81.png" alt></p><ol start="4"><li><p>删除用户</p><p>语法：<code>#userdel 选项 用户名</code></p><p>userdel：user delete（用户删除）</p><p>常用选项：</p><p>​    -r：表示删除用户的同时，删除其家目录；</p></li></ol><p><img src="/2019/06/12/Linux学习/82.png" alt></p><p><strong>注意</strong>：已经登录的用户p删除时侯提示失败，但没有登录的用户可以正常删除</p><p>解决办法：直接kill对用用户全部进程，再<code>userdel -r 用户名</code></p><p>所有用户操作的命令（除passwd外）只有root超级管理员有权限执行。</p><h2 id="2-用户组管理"><a href="#2-用户组管理" class="headerlink" title="2.用户组管理"></a>2.用户组管理</h2><p>​    每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux系统对用户组的规定有所不同。Linux下的用户属于与他同名的用户组，这个用户组在创建用户同时创建。</p><p>​    用户组的管理涉及用户的添加、删除和修改。实际上就是对/etc/group文件的更新。</p><p><img src="/2019/06/12/Linux学习/83.png" alt></p><p>文件结构：</p><p>用户组名:密码:用户组ID:组内用户名</p><p>密码：x表示占位符，虽然用户组可以设置密码，但是绝大部分的情况下不设置密码；</p><p>组内用户名：表示附加组是该组的用户名称；</p><ol><li><p>用户组的添加</p><p>语法：<code>#groupadd 选项 用户组名</code></p><p>常用选项：</p><p>​    -g：类似用户添加里的“-u”，-g表示选择自己设置一个自定义的用户组ID数字，如果不指定，则默认从1000（500）开始。</p></li></ol><p><img src="/2019/06/12/Linux学习/84.png" alt></p><ol start="2"><li><p>用户组编辑</p><p>语法：<code>#groupmod 选项 用户组名</code></p><p>常用选项：</p><p>​    -g：类似用户修改里的“-u”，-g表示选择自己设置一个自定义的用户组ID数字；</p><p>​    -n：类似用户修改里的“-l”，表示设置新的用户组的名称</p><p><img src="/2019/06/12/Linux学习/85.png" alt></p></li><li><p>用户组删除</p><p>语法：<code>#groupdel 用户组名</code></p><p><img src="/2019/06/12/Linux学习/86.png" alt></p></li></ol><p><strong>注意：</strong>当如果需要删除一个组，但是这个组是某个用户的主组时，则不允许删除；如果确实需要删除，则先从组内移除所有用户。</p><h1 id="三、网络设置"><a href="#三、网络设置" class="headerlink" title="三、网络设置"></a>三、网络设置</h1><p>首先知道网卡配置文件位置：/etc/sysconfig/network-scripts</p><p>在目录中网卡的配置文件命名格式：ifcfg-网卡名称</p><p><img src="/2019/06/12/Linux学习/87.png" alt></p><p>BOOTPROTO：ip地址分配方式，dpch表示动态主机分配协议</p><p>ONBOOT：是否开机启动</p><p>HWADDR：硬件地址，MAC地址</p><p>重启网卡：</p><p>​    <code>#service networking restart</code></p><p>在有的版本中可能没有service命令来快速操作服务，但是一个共性的目录：/etc/init.d这个目录中放着很多对服务的快捷方式。</p><p>​    <code>#/etc/init.d/networking restart</code></p><p> <img src="/2019/06/12/Linux学习/88.png" alt></p><p><strong>创建快捷方式：</strong></p><p>​    语法：<code>ln -s 原始文件的路径 快捷方式的路径</code></p><p><img src="/2019/06/12/Linux学习/89.png" alt></p><p>其中，文件类型位置的“l”表示其类型为link（连接类型），后面的“-&gt;”指向的是原始文件路径。</p><p><strong>重启单个网卡：</strong></p><p>​    <code>#ifdown 网卡名</code>              停止某个网卡</p><p>​    <code>#ifup 网卡名</code>                  开启某个网卡</p><h1 id="四、ssh服务（重点）"><a href="#四、ssh服务（重点）" class="headerlink" title="四、ssh服务（重点）"></a>四、ssh服务（重点）</h1><p>ssh（secure shell，安全外壳协议），该协议有2个常用的作用：远程连接协议、远程文件传输协议。</p><p>写意使用端口号：默认是22，可以修改，则需要修改ssh服务的配置文件：/etc/ssh/ssh_config</p><p><img src="/2019/06/12/Linux学习/90.png" alt></p><p>注意：</p><p>​    a.注意范围，端口号范围是从0-65535；</p><p>​    b.不能使用别的服务已经占用的端口；</p><p>服务启动/停止/重启</p><p><code>#service sshd start/stop/restart</code></p><p><code>#/etc/init.d/sshd start/stop/restart</code></p><h2 id="1-远程终端"><a href="#1-远程终端" class="headerlink" title="1.远程终端"></a>1.远程终端</h2><p>终端工具·主要帮助运维人员连接远程的服务器，常见终端工具有：Xshell、secureCRT、Putty等。</p><ol><li><p>获取IP地址，可以通过ifconfig命令查看，并测试IP的连接相通性。</p></li><li><p>打开Putty，输入相关信息</p></li><li><p>弹出key确认的时候点击“是”，以后不会再提示·</p><p><img src="/2019/06/12/Linux学习/91.png" alt></p></li></ol><p><img src="/2019/06/12/Linux学习/92.png" alt></p><h2 id="2-ssh服务文件传输"><a href="#2-ssh服务文件传输" class="headerlink" title="2.ssh服务文件传输"></a>2.ssh服务文件传输</h2><p>可视化的界面工具：Filezilla</p><p><img src="/2019/06/12/Linux学习/93.png" alt></p><p><img src="/2019/06/12/Linux学习/94.png" alt></p><p>通过命令行工具来传输文件/文件夹</p><p>工具：PSCP.exe（必须使用命令行打开），为了使用方便可以将其放到环境变量目录中如果不清楚那些路径使环境变量路径，只需要将其放到C:/Windows目录下即可。</p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pscp 选项 用户名@linux主机地址:资源路径 windows 本地的地址 （下载到windows）</span><br><span class="line">pscp 选项 资源路径 用户名@linux主机地址:远程路径           （上传到linux）</span><br><span class="line">pscp 选项 -ls 用户名@linux主机地址                        （列出远程路径下结构）</span><br></pre></td></tr></table></figure><p>​       </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Linux发展史&quot;&gt;&lt;a href=&quot;#一、Linux发展史&quot; class=&quot;headerlink&quot; title=&quot;一、Linux发展史&quot;&gt;&lt;/a&gt;一、Linux发展史&lt;/h1&gt;&lt;p&gt;1970年元年&lt;/p&gt;
&lt;h1 id=&quot;二、Linux系统安装&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Linux" scheme="https://smallpotatody.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://smallpotatody.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>linux常用命令</title>
    <link href="https://smallpotatody.github.io/2019/06/11/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://smallpotatody.github.io/2019/06/11/linux常用命令/</id>
    <published>2019-06-11T12:19:51.000Z</published>
    <updated>2019-06-11T13:28:04.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-文件管理"><a href="#1-文件管理" class="headerlink" title="1. 文件管理"></a>1. 文件管理</h1><h2 id="ls命令-–-显示指定工作目录下的内容及属性信息"><a href="#ls命令-–-显示指定工作目录下的内容及属性信息" class="headerlink" title="ls命令 – 显示指定工作目录下的内容及属性信息"></a>ls命令 – 显示指定工作目录下的内容及属性信息</h2><p>ls 命令是Linux下最常用的指令之一。ls命令为英文单词 list 的缩写，正如英文单词 list 的意思，其功能是列出指定目录下的内容及其相关属性信息。</p><p>默认状态下，ls命令会列出当前目录的内容。而带上参数后，我们可以用ls做更多的事情。作为最基础同时又是使用频率很高的命令，我们很有必要搞清楚ls命令的用法，那么接下来一起看看吧！</p><p><strong>语法格式:</strong> ls [选项] [文件]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-a</th><th>显示所有文件及目录 (包括以“.”开头的隐藏文件)</th></tr></thead><tbody><tr><td>-l</td><td>使用长格式列出文件及目录信息</td></tr><tr><td>-r</td><td>将文件以相反次序显示(默认依英文字母次序)</td></tr><tr><td>-t</td><td>根据最后的修改时间排序</td></tr><tr><td>-A</td><td>同 -a ，但不列出 “.” (当前目录) 及 “..” (父目录)</td></tr><tr><td>-S</td><td>根据文件大小排序</td></tr><tr><td>-R</td><td>递归列出所有子目录</td></tr></tbody></table><p><strong>参考实例</strong></p><p>列出所有文件(包括隐藏文件)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure><p>列出文件的详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure><p>列出根目录(/)下的所有目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /</span><br></pre></td></tr></table></figure><p>列出当前工作目录下所有名称是 “s” 开头的文件 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ltr s*</span><br></pre></td></tr></table></figure><p>列出 /bin 目录下的所有目录及文件的详细信息 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lR /bin</span><br></pre></td></tr></table></figure><p>列出当前工作目录下所有文件及目录并以文件的大小进行排序 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -AS</span><br></pre></td></tr></table></figure><h2 id="pwd命令-–-显示当前路径"><a href="#pwd命令-–-显示当前路径" class="headerlink" title="pwd命令 – 显示当前路径"></a>pwd命令 – 显示当前路径</h2><p>pwd命令是“print working directory”中每个单词的首字母缩写，其功能正如所示单词一样，为打印工作目录，即显示当前工作目录的绝对路径。</p><p>在实际工作中，我们经常会在不同目录之间进行切换，为了防止“迷路”，我们可以使用pwd命令快速查看当前我们所在的目录路径。</p><p><strong>语法格式:</strong> pwd [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-L</th><th>显示逻辑路径</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p><strong>参考实例</strong></p><p>查看当前工作目录路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br><span class="line">/home/linuxcool</span><br></pre></td></tr></table></figure><h2 id="mkdir命令-–-创建目录"><a href="#mkdir命令-–-创建目录" class="headerlink" title="mkdir命令 – 创建目录"></a>mkdir命令 – 创建目录</h2><p>mkdir命令是“make directories”的缩写，用来创建目录。</p><p>注意：默认状态下，如果要创建的目录已经存在，则提示已存在，而不会继续创建目录。 所以在创建目录时，应保证新建的目录与它所在目录下的文件没有重名。 mkdir命令还可以同时创建多个目录，是不是很强大呢？</p><p><strong>语法格式 :</strong> mkdir [参数] [目录]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-p</th><th>递归创建多级目录</th></tr></thead><tbody><tr><td>-m</td><td>建立目录的同时设置目录的权限</td></tr><tr><td>-z</td><td>设置安全上下文</td></tr><tr><td>-v</td><td>显示目录的创建过程</td></tr></tbody></table><p><strong>参考实例</strong></p><p>在工作目录下，建立一个名为 dir 的子目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir dir</span><br></pre></td></tr></table></figure><p>在目录/usr/linuxcool下建立子目录dir，并且设置文件属主有读、写和执行权限，其他人无权访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -m 700 /usr/linuxcool/dir</span><br></pre></td></tr></table></figure><p>同时创建子目录dir1，dir2，dir3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir dir1 dir2 dir3</span><br></pre></td></tr></table></figure><p>递归创建目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p linuxcool/dir</span><br></pre></td></tr></table></figure><h2 id="cp命令-–-复制文件或目录"><a href="#cp命令-–-复制文件或目录" class="headerlink" title="cp命令 – 复制文件或目录"></a>cp命令 – 复制文件或目录</h2><p>cp命令可以理解为英文单词copy的缩写，其功能为复制文件或目录。</p><p>cp命令可以将多个文件复制到一个具体的文件名或一个已经存在的目录下，也可以同时复制多个文件到一个指定的目录中。</p><p><strong>语法格式：</strong>cp [参数] [文件]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-f</th><th>若目标文件已存在，则会直接覆盖原文件</th></tr></thead><tbody><tr><td>-i</td><td>若目标文件已存在，则会询问是否覆盖</td></tr><tr><td>-p</td><td>保留源文件或目录的所有属性</td></tr><tr><td>-r</td><td>递归复制文件和目录</td></tr><tr><td>-d</td><td>当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录</td></tr><tr><td>-l</td><td>对源文件建立硬连接，而非复制文件</td></tr><tr><td>-s</td><td>对源文件建立符号连接，而非复制文件</td></tr><tr><td>-b</td><td>覆盖已存在的文件目标前将目标文件备份</td></tr><tr><td>-v</td><td>详细显示cp命令执行的操作过程</td></tr><tr><td>-a</td><td>等价于“dpr”选项</td></tr></tbody></table><p><strong>参考实例</strong></p><p>复制目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -R dir1 dir2/</span><br></pre></td></tr></table></figure><p>将文件test1改名为test2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -f test1 test2</span><br></pre></td></tr></table></figure><p>复制多个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r file1 file2 file3 dir</span><br></pre></td></tr></table></figure><p>交互式地将目录 /usr/linuxcool 中的所有.c文件复制到目录 dir 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r /usr/linuxcool/*.c dir</span><br></pre></td></tr></table></figure><h2 id="mv命令-–-移动或改名文件"><a href="#mv命令-–-移动或改名文件" class="headerlink" title="mv命令 – 移动或改名文件"></a>mv命令 – 移动或改名文件</h2><p>mv命令是“move”单词的缩写，其功能大致和英文含义一样，可以移动文件或对其改名。</p><p>这是一个使用频率超高的文件管理命令，我们需要特别留意它与复制的区别：mv与cp的结果不同。mv命令好像文件“搬家”，文件名称发生改变，但个数并未增加。而cp命令是对文件进行复制操作，文件个数是有增加的。</p><p><strong>语法格式：</strong>mv [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-i</th><th>若存在同名文件，则向用户询问是否覆盖</th></tr></thead><tbody><tr><td>-f</td><td>覆盖已有文件时，不进行任何提示</td></tr><tr><td>-b</td><td>当文件存在时，覆盖前为其创建一个备份</td></tr><tr><td>-u</td><td>当源文件比目标文件新，或者目标文件不存在时，才执行移动此操作</td></tr></tbody></table><p><strong>参考实例</strong></p><p>将文件file_1重命名为file_2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv file_1 file_2</span><br></pre></td></tr></table></figure><p>将文件file移动到目录dir中 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv file /dir</span><br></pre></td></tr></table></figure><p>将目录dir1移动目录dir2中（前提是目录dir2已存在，若不存在则改名)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /dir1 /dir2</span><br></pre></td></tr></table></figure><p>将目录dir1下的文件移动到当前目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /dir1/* .</span><br></pre></td></tr></table></figure><h1 id="2-文档编辑"><a href="#2-文档编辑" class="headerlink" title="2. 文档编辑"></a>2. 文档编辑</h1><h2 id="cat命令-–-在终端设备上显示文件内容"><a href="#cat命令-–-在终端设备上显示文件内容" class="headerlink" title="cat命令 – 在终端设备上显示文件内容"></a>cat命令 – 在终端设备上显示文件内容</h2><p>Linux系统中有很多个用于查看文件内容的命令，每个命令又都有自己的特点，比如这个cat命令就是用于查看内容较少的纯文本文件的。cat这个命令也很好记，因为cat在英语中是“猫”的意思，小猫咪是不是给您一种娇小、可爱的感觉呢？</p><p>注意：当文件内容较大时，文本内容会在屏幕上快速闪动（滚屏），用户往往看不清所显示的具体内容。因此对于较长文件内容可以按Ctrl+S键，停止滚屏；以及Ctrl+Q键可以恢复滚屏；而按Ctrl+C（中断）键则可以终止该命令的执行。或者对于大文件，干脆用more命令吧！</p><p><strong>语法格式：</strong>cat [参数] [文件]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-n</th><th>显示行数（空行也编号）</th></tr></thead><tbody><tr><td>-s</td><td>显示行数（多个空行算一个编号）</td></tr><tr><td>-b</td><td>显示行数（空行不编号）</td></tr><tr><td>-E</td><td>每行结束处显示$符号</td></tr><tr><td>-T</td><td>将TAB字符显示为 ^I符号</td></tr><tr><td>-v</td><td>使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外</td></tr><tr><td>-e</td><td>等价于”-vE”组合</td></tr><tr><td>-t</td><td>等价于”-vT”组合</td></tr><tr><td>-A</td><td>等价于 -vET组合</td></tr><tr><td>–help</td><td>显示帮助信息</td></tr><tr><td>–version</td><td>显示版本信息</td></tr></tbody></table><p><strong>参考实例</strong></p><p>查看文件的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename.txt</span><br></pre></td></tr></table></figure><p>查看文件的内容，并显示行数编号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n filename.txt</span><br></pre></td></tr></table></figure><p>查看文件的内容，并添加行数编号后输出到另外一个文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n linuxcool.log &gt; linuxprobe.log</span><br></pre></td></tr></table></figure><p>清空文件的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/null &gt; /root/filename.txt</span><br></pre></td></tr></table></figure><p>持续写入文件内容，碰到EOF符后结束并保存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; filename.txt &lt;&lt;EOF</span><br><span class="line">&gt; Hello, World </span><br><span class="line">&gt; Linux!</span><br><span class="line">&gt; EOF</span><br></pre></td></tr></table></figure><p>将软盘设备制作成镜像文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/fd0 &gt; fdisk.iso</span><br></pre></td></tr></table></figure><h2 id="echo命令-–-输出字符串或提取Shell变量的值"><a href="#echo命令-–-输出字符串或提取Shell变量的值" class="headerlink" title="echo命令 – 输出字符串或提取Shell变量的值"></a>echo命令 – 输出字符串或提取Shell变量的值</h2><p>echo命令用于在终端设备上输出字符串或变量提取后的值，这是在Linux系统中最常用的几个命令之一，但操作却非常简单。</p><p>人们一般使用在变量前加上$符号的方式提取出变量的值，例如：$PATH，然后再用echo命令予以输出。或者直接使用echo命令输出一段字符串到屏幕上，起到给用户提示的作用。</p><p><strong>语法格式：</strong>echo [参数] [字符串]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-n</th><th>不输出结尾的换行符</th></tr></thead><tbody><tr><td>-e “\a”</td><td>发出警告音</td></tr><tr><td>-e “\b”</td><td>删除前面的一个字符</td></tr><tr><td>-e “\c”</td><td>结尾不加换行符</td></tr><tr><td>-e “\f”</td><td>换行，光标扔停留在原来的坐标位置</td></tr><tr><td>-e “\n”</td><td>换行，光标移至行首</td></tr><tr><td>-e “\r”</td><td>光标移至行首，但不换行</td></tr><tr><td>-E</td><td>禁止反斜杠转移，与-e参数功能相反</td></tr><tr><td>—version</td><td>查看版本信息</td></tr><tr><td>–help</td><td>查看帮助信息</td></tr></tbody></table><p><strong>参考实例</strong></p><p>输出一段字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;LinuxCool.com&quot; </span><br><span class="line">LinuxCool.com</span><br></pre></td></tr></table></figure><p>输出变量提取后的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure><p>对内容进行转义，不让$符号的提取变量值功能生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo \$PATH</span><br><span class="line">$PATH</span><br></pre></td></tr></table></figure><p>结合输出重定向符，将字符串信息导入文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;It is a test&quot; &gt; linuxcool</span><br></pre></td></tr></table></figure><p>使用反引号符执行命令，并输出其结果到终端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo `date`</span><br></pre></td></tr></table></figure><p>输出带有换行符的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;a\nb\nc&quot;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>输出信息中删除某个字符，注意看数字3消失了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;123\b456&quot; </span><br><span class="line">12456</span><br></pre></td></tr></table></figure><h2 id="rmdir命令-–-删除空目录"><a href="#rmdir命令-–-删除空目录" class="headerlink" title="rmdir命令 – 删除空目录"></a>rmdir命令 – 删除空目录</h2><p>rmdir命令作用是删除空的目录，英文全称：“remove directory”。</p><p>注意：rmdir命令只能删除空目录。当要删除非空目录时，就要使用带有“-R”选项的rm命令。</p><p>rmdir命令的“-p”参数可以递归删除指定的多级目录，但是要求每个目录也必须是空目录。</p><p><strong>语法格式 :</strong>  rmdir [参数] [目录名称]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-p</th><th>用递归的方式删除指定的目录路径中的所有父级目录，非空则报错</th></tr></thead><tbody><tr><td>– – ignore-fail-on-non-empty</td><td>忽略由于删除非空目录时导致命令出错而产生的错误信息</td></tr><tr><td>-v</td><td>显示命令的详细执行过程</td></tr><tr><td>– – help</td><td>显示命令的帮助信息</td></tr><tr><td>– – version</td><td>显示命令的版本信息</td></tr></tbody></table><p><strong>参考实例</strong></p><p>删除空目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir dir</span><br></pre></td></tr></table></figure><p>递归删除指定的目录树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir -p dir/dir_1/dir_2</span><br></pre></td></tr></table></figure><p>显示指令详细执行过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rmdir -v dir</span><br><span class="line">rmdir: 正在删除目录 &apos;dir&apos;</span><br><span class="line">rmdir -p -v dir/dir_1/dir_2</span><br><span class="line">rmdir: 正在删除目录 &apos;dir/dir_1/dir_2</span><br><span class="line">rmdir: 正在删除目录 &apos;dir/dir_1&apos;</span><br><span class="line">rmdir: 正在删除目录 &apos;dir_2&apos;</span><br></pre></td></tr></table></figure><p>显示命令的版本信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rmdir --version</span><br><span class="line">rmdir (GNU coreutils) 8.30</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">许可证 GPLv3+：GNU 通用公共许可证第 3 版或更新版本https://gnu.org/licenses/gpl.html。</span><br><span class="line">本软件是自由软件：您可以自由修改和重新发布它。</span><br><span class="line">在法律范围内没有其他保证。</span><br></pre></td></tr></table></figure><h2 id="tail命令-–-查看文件尾部内容"><a href="#tail命令-–-查看文件尾部内容" class="headerlink" title="tail命令 – 查看文件尾部内容"></a>tail命令 – 查看文件尾部内容</h2><p>tail用于显示文件尾部的内容，默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。如果没有指定文件或者文件名为“-”，则读取标准输入。</p><p><strong>语法格式：</strong>tail [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>–retry</th><th>即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用</th></tr></thead><tbody><tr><td>-c<n>或——bytes=<n></n></n></td><td>输出文件尾部的N（N为整数）个字节内容</td></tr><tr><td>-f&lt;name/descriptor&gt;</td><td>–follow<nameldescript>：显示文件最新追加的内容</nameldescript></td></tr><tr><td>-F</td><td>与选项“-follow=name”和“–retry”连用时功能相同</td></tr><tr><td>-n<n>或——line=<n></n></n></td><td>输出文件的尾部N（N位数字）行内容</td></tr><tr><td>–pid=&lt;进程号&gt;</td><td>与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令</td></tr><tr><td>–help</td><td>显示指令的帮助信息</td></tr><tr><td>–version</td><td>显示指令的版本信息</td></tr></tbody></table><p><strong>参考实例</strong></p><p>显示文件file的最后10行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail file</span><br></pre></td></tr></table></figure><p>显示文件file的内容，从第20行至文件末尾：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail +20 file</span><br></pre></td></tr></table></figure><p>显示文件file的最后10个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -c 10 file</span><br></pre></td></tr></table></figure><p>一直变化的文件总是显示后10行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f 10 file</span><br></pre></td></tr></table></figure><p>显示帮助信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail --help</span><br></pre></td></tr></table></figure><h2 id="expr命令-–-命令行计数器"><a href="#expr命令-–-命令行计数器" class="headerlink" title="expr命令 – 命令行计数器"></a>expr命令 – 命令行计数器</h2><p>expr命令的英文全称是“expression”，即是表达式的意思，作用是一个命令行的计数器，常用于在UNIX/LINUX系统中求表达式变量的值，一般用于整数值，也可用于字符串。</p><p><strong>语法格式：</strong>expr [表达式]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>空格</th><th>隔开每个项</th></tr></thead><tbody><tr><td>\（反斜杠）</td><td>放在 shell 特定的字符前面</td></tr><tr><td>“”(引号)</td><td>对包含空格和其他特殊字符的字符串要用引号括起来</td></tr></tbody></table><p><strong>参考实例</strong></p><p>计算字串长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr length “this is a test”  </span><br><span class="line">14</span><br></pre></td></tr></table></figure><p>抓取字串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr substr “this is a test” 3 5 </span><br><span class="line">is is</span><br></pre></td></tr></table></figure><p>抓取第一个字符数字串出现的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr index &quot;sarasara&quot; a </span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>整数运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">expr 14 % 9</span><br><span class="line">5  </span><br><span class="line">expr 10 + 10</span><br><span class="line">20</span><br><span class="line">expr 1000 + 900</span><br><span class="line">1900</span><br><span class="line">expr 30 / 3 / 2</span><br><span class="line">5</span><br><span class="line">expr 30 * 3  </span><br><span class="line">expr: Syntax error  </span><br><span class="line">expr 30 \* 3 </span><br><span class="line">90</span><br></pre></td></tr></table></figure><p>注意：使用乘号时，必须用反斜线屏蔽其特定含义。因为shell可能会误解显示星号的意义</p><p>使用expr进行四则运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr \( 10 + 10 \) \* 2 + 100 </span><br><span class="line">140</span><br></pre></td></tr></table></figure><h1 id="3-系统管理"><a href="#3-系统管理" class="headerlink" title="3. 系统管理"></a>3. 系统管理</h1><h2 id="uname命令-–-显示系统信息"><a href="#uname命令-–-显示系统信息" class="headerlink" title="uname命令 – 显示系统信息"></a>uname命令 – 显示系统信息</h2><p>uname命令的英文全称即“Unix name”。</p><p>用于显示系统相关信息，比如主机名、内核版本号、硬件架构等。</p><p>如果未指定任何选项，其效果相当于执行”uname -s”命令，即显示系统内核的名字。</p><p><strong>语法格式：</strong>uname [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-a</th><th>显示系统所有相关信息</th></tr></thead><tbody><tr><td>-m</td><td>显示计算机硬件架构</td></tr><tr><td>-n</td><td>显示主机名称</td></tr><tr><td>-r</td><td>显示内核发行版本号</td></tr><tr><td>-s</td><td>显示内核名称</td></tr><tr><td>-v</td><td>显示内核版本</td></tr><tr><td>-p</td><td>显示主机处理器类型</td></tr><tr><td>-o</td><td>显示操作系统名称</td></tr><tr><td>-i</td><td>显示硬件平台</td></tr></tbody></table><p><strong>参考实例</strong></p><p>显示系统主机名、内核版本号、CPU类型等信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br><span class="line">Linux linuxcool 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>仅显示系统主机名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -n</span><br><span class="line">linuxcool</span><br></pre></td></tr></table></figure><p>显示当前系统的内核版本 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line">3.10.0-123.el7.x86_64</span><br></pre></td></tr></table></figure><p>显示当前系统的硬件架构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -i</span><br><span class="line">x86_64</span><br></pre></td></tr></table></figure><h2 id="rsh命令-–-远端登入的shell"><a href="#rsh命令-–-远端登入的shell" class="headerlink" title="rsh命令 – 远端登入的shell"></a>rsh命令 – 远端登入的shell</h2><p>rsh命令的英文全称为“remote shell”，该命令提供的用户环境，也就是shell，以便指令能够在指定的远端主机上执行。</p><p><strong>语法格式：</strong> rsh [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-d</th><th>使用Socket层级的排错功能</th></tr></thead><tbody><tr><td>-l</td><td>指定要登入远端主机的用户名称</td></tr><tr><td>-n</td><td>把输入的指令号向代号为/dev/null的特殊外围设备</td></tr></tbody></table><p><strong>参考实例</strong></p><p>远程命令执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsh -l linuxcool 192.168.1.88 /bin/ls</span><br></pre></td></tr></table></figure><h2 id="yes命令-–-重复打印字符串"><a href="#yes命令-–-重复打印字符串" class="headerlink" title="yes命令 – 重复打印字符串"></a>yes命令 – 重复打印字符串</h2><p>yes命令的作用是中输出指定的字符串，直到yes进程被杀死。不带任何参数输的yes命令默认的字符串就是y。 终止yes命令可以使用组合键ctrl+c</p><p>yes命令通常在脚本中使用，在脚本中可以对对命令和程序的确认提示和问题进行管道输出并回答提问(例如：你确认要删除这个文件吗，按’y’ or ‘n’)。</p><p><strong>语法格式:</strong> yes [字符串]</p><table><thead><tr><th>– -help</th><th>显示帮助信息</th></tr></thead><tbody><tr><td>– -version</td><td>显示命令版本信息</td></tr></tbody></table><p><strong>参考实例</strong></p><p>重复打印一段字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yes linuxcool</span><br><span class="line">linuxcool</span><br><span class="line">linuxcool</span><br><span class="line">linuxcool</span><br><span class="line">linuxcool</span><br><span class="line">linuxcool</span><br><span class="line">linuxcool</span><br><span class="line">linuxcool</span><br><span class="line">linuxcool</span><br><span class="line">...</span><br><span class="line">^C //使用ctrl+c强制停止</span><br></pre></td></tr></table></figure><h2 id="useradd命令-–-创建用户"><a href="#useradd命令-–-创建用户" class="headerlink" title="useradd命令 – 创建用户"></a>useradd命令 – 创建用户</h2><p>useradd命令用来创建新的用户或更改用户的信息。</p><p>useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p><p><strong>语法格式：</strong>useradd [参数] [用户名]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-D</th><th>改变新建用户的预设值</th></tr></thead><tbody><tr><td>-c</td><td>添加备注文字</td></tr><tr><td>-d</td><td>新用户每次登陆时所使用的家目录</td></tr><tr><td>-e</td><td>用户终止日期，日期的格式为YYYY-MM-DD</td></tr><tr><td>-f</td><td>用户过期几日后永久停权。当值为0时用户立即被停权，而值为-1时则关闭此功能，预设值为-1</td></tr><tr><td>-g</td><td>指定用户对应的用户组</td></tr><tr><td>-G</td><td>定义此用户为多个不同组的成员</td></tr><tr><td>-m</td><td>用户目录不存在时则自动创建</td></tr><tr><td>-M</td><td>不建立用户家目录，优先于/etc/login.defs文件设定</td></tr><tr><td>-n</td><td>取消建立以用户名称为名的群组</td></tr><tr><td>-r</td><td>建立系统帐号</td></tr><tr><td>-u</td><td>指定用户id</td></tr></tbody></table><p><strong>参考实例</strong></p><p>添加新用户linuxcool：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd linuxcool</span><br></pre></td></tr></table></figure><p>不创建家目录，并且禁止登陆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -M -s /sbin/nologin linuxcool</span><br></pre></td></tr></table></figure><p>添加新用户linuxcool，指定UID为888，指定归属用户组为root，cool成员，其shell类型为/bin/sh：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -u 888 -s /bin/sh -G root,cool linuxcool</span><br></pre></td></tr></table></figure><p>添加新用户linuxcool，设置家目录为/tmp/linuxcool，用户过期时间为2019/05/01.过期后两天停权：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -e &quot;2019/05/01&quot; -f 2 -d /tmp/linuxcool linuxcool</span><br></pre></td></tr></table></figure><h2 id="who命令-–-打印当前登录用户"><a href="#who命令-–-打印当前登录用户" class="headerlink" title="who命令 – 打印当前登录用户"></a>who命令 – 打印当前登录用户</h2><p>who命令用来打印当前登录用户信息，包含了系统的启动时间 、 活动进程 、 使用者 ID、使用终端等信息，是系统管理员了解系统运行状态的常用命令。</p><p>who命令的输出信息默认来自文件“/var/log/utmp”和“/var/log/wtmp”。</p><p><strong>语法格式：</strong> who [参数] [选项]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-a</th><th>打印全面信息</th></tr></thead><tbody><tr><td>-b</td><td>打印系统最近启动时间</td></tr><tr><td>-d</td><td>打印死掉的进程</td></tr><tr><td>-l</td><td>打印系统登录进程</td></tr><tr><td>-H</td><td>带有列标题打印用户名，登录终端和登录时间</td></tr><tr><td>-t</td><td>打印系统上次锁定时间</td></tr><tr><td>-u</td><td>打印已登录用户列表</td></tr></tbody></table><p><strong>参考实例</strong></p><p>打印用户登录信息（-H 带有列标题打印）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">who -H</span><br><span class="line">名称     线路          时间              备注</span><br><span class="line">root     pts/0        2019-04-10 12:31 (192.168.12.34)</span><br></pre></td></tr></table></figure><p>打印全部信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">who -H -a</span><br><span class="line">名称     线路       时间           空闲  进程号 备注   退出</span><br><span class="line">系统引导 2019-04-03 15:01</span><br><span class="line">运行级别 3 2019-04-03 15:02</span><br><span class="line">登录     tty1      2019-04-03 15:02           852 id=tty1</span><br><span class="line">                   2019-04-03 15:31          1022 id=102   </span><br><span class="line">终端=0 退出=0</span><br><span class="line">root     + pts/0   2019-04-10 12:27   .  2789 (192.168.12.34)</span><br></pre></td></tr></table></figure><p>打印系统最近启动时间 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">who -b</span><br><span class="line">系统引导 2019-04-03 15:01</span><br></pre></td></tr></table></figure><p>打印系统登录进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">who -l</span><br><span class="line">登录   tty1         2019-04-03 15:02               852 id=tty1</span><br></pre></td></tr></table></figure><h1 id="4-磁盘管理"><a href="#4-磁盘管理" class="headerlink" title="4. 磁盘管理"></a>4. 磁盘管理</h1><h2 id="df命令-–-显示磁盘空间使用情况"><a href="#df命令-–-显示磁盘空间使用情况" class="headerlink" title="df命令 – 显示磁盘空间使用情况"></a>df命令 – 显示磁盘空间使用情况</h2><p>df命令的英文全称即“Disk Free”，顾名思义功能是用于显示系统上可使用的磁盘空间。默认显示单位为KB，建议使用“df -h”的参数组合，根据磁盘容量自动变换合适的单位，更利于阅读。</p><p>日常普遍用该命令可以查看磁盘被占用了多少空间、还剩多少空间等信息。</p><p><strong>语法格式：</strong> df [参数] [指定文件]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-a</th><th>显示所有系统文件</th></tr></thead><tbody><tr><td>-B &lt;块大小&gt;</td><td>指定显示时的块大小</td></tr><tr><td>-h</td><td>以容易阅读的方式显示</td></tr><tr><td>-H</td><td>以1000字节为换算单位来显示</td></tr><tr><td>-i</td><td>显示索引字节信息</td></tr><tr><td>-k</td><td>指定块大小为1KB</td></tr><tr><td>-l</td><td>只显示本地文件系统</td></tr><tr><td>-t &lt;文件系统类型&gt;</td><td>只显示指定类型的文件系统</td></tr><tr><td>-T</td><td>输出时显示文件系统类型</td></tr><tr><td>– -sync</td><td>在取得磁盘使用信息前，先执行sync命令</td></tr></tbody></table><p><strong>参考实例</strong></p><p>显示磁盘分区使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df</span><br><span class="line">文件系统                             1K-块    已用     可用   已用% 挂载点</span><br><span class="line">devtmpfs                           1980612       0  1980612    0% /dev</span><br><span class="line">tmpfs                              1994756       0  1994756    0% /dev/shm</span><br><span class="line">tmpfs                              1994756    1040  1993716    1% /run</span><br><span class="line">tmpfs                              1994756       0  1994756    0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/fedora_linuxhell-root 15718400 2040836 13677564   13% /</span><br><span class="line">tmpfs                              1994756       4  1994752    1% /tmp</span><br><span class="line">/dev/sda1                           999320  128264   802244   14% /boot</span><br><span class="line">tmpfs                               398948       0   398948   0% /run/user/0</span><br></pre></td></tr></table></figure><p>以容易阅读的方式显示磁盘分区使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br><span class="line"> 文件系统                           容量   已用   可用  已用% 挂载点</span><br><span class="line"> devtmpfs                           1.9G     0  1.9G    0% /dev</span><br><span class="line"> tmpfs                              2.0G     0  2.0G    0% /dev/shm</span><br><span class="line"> tmpfs                              2.0G  1.1M  2.0G    1% /run</span><br><span class="line"> tmpfs                              2.0G     0  2.0G    0% /sys/fs/cgroup</span><br><span class="line"> /dev/mapper/fedora_linuxhell-root   15G  2.0G   14G   13% /</span><br><span class="line"> tmpfs                              2.0G  4.0K  2.0G    1% /tmp</span><br><span class="line"> /dev/sda1                          976M  126M  784M   14% /boot</span><br><span class="line"> tmpfs                              390M     0  390M    0% /run/user/0</span><br></pre></td></tr></table></figure><p>显示指定文件所在分区的磁盘使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df /etc/dhcp</span><br><span class="line">文件系统                             1K-块    已用     可用   已用% 挂载点</span><br><span class="line">/dev/mapper/fedora_linuxcool-root 15718400 2040836 13677564   13% /</span><br></pre></td></tr></table></figure><p>显示文件类型为ext4的磁盘使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df -t ext4</span><br><span class="line">文件系统        1K-块   已用   可用    已用% 挂载点</span><br><span class="line">/dev/sda1      999320 128264 802244   14% /boot</span><br></pre></td></tr></table></figure><h2 id="lsblk命令-–-查看系统的磁盘"><a href="#lsblk命令-–-查看系统的磁盘" class="headerlink" title="lsblk命令 – 查看系统的磁盘"></a>lsblk命令 – 查看系统的磁盘</h2><p>lsblk命令的英文是“list block”，即用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。</p><p>lsblk命令包含在util-linux-ng包中，现在该包改名为util-linux。</p><p><strong>语法格式：</strong>lsblk [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-a</th><th>显示所有设备</th></tr></thead><tbody><tr><td>-b</td><td>以bytes方式显示设备大小</td></tr><tr><td>-d</td><td>不显示 slaves 或 holders</td></tr><tr><td>-D</td><td>print discard capabilities</td></tr><tr><td>-e</td><td>排除设备</td></tr><tr><td>-f</td><td>显示文件系统信息</td></tr><tr><td>-h</td><td>显示帮助信息</td></tr><tr><td>-i</td><td>use ascii characters only</td></tr><tr><td>-m</td><td>显示权限信息</td></tr><tr><td>-l</td><td>使用列表格式显示</td></tr><tr><td>-n</td><td>不显示标题</td></tr><tr><td>-o</td><td>输出列</td></tr><tr><td>-P</td><td>使用key=”value”格式显示</td></tr><tr><td>-r</td><td>使用原始格式显示</td></tr><tr><td>-t</td><td>显示拓扑结构信息</td></tr></tbody></table><p><strong>参考实例</strong></p><p>lsblk命令默认情况下将以树状列出所有块设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br><span class="line">lsblk NAME   MAJ:MIN rm  SIZE RO type mountpoint</span><br><span class="line">sda      8:0    0 232.9G  0 disk </span><br><span class="line">├─sda1   8:1    0  46.6G  0 part / </span><br><span class="line">├─sda2   8:2    0     1K  0 part  </span><br><span class="line">├─sda5   8:5    0   190M  0 part /boot </span><br><span class="line">├─sda6   8:6    0   3.7G  0 part [SWAP] </span><br><span class="line">├─sda7   8:7    0  93.1G  0 part /data </span><br><span class="line">└─sda8   8:8    0  89.2G  0 part /personal </span><br><span class="line">sr0     11:0    1  1024M  0 rom</span><br></pre></td></tr></table></figure><p>默认选项不会列出所有空设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -a</span><br></pre></td></tr></table></figure><p>也可以用于列出一个特定设备的拥有关系，同时也可以列出组和模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -m</span><br></pre></td></tr></table></figure><p>要获取SCSI设备的列表，你只能使用-S选项，该选项是用来以颠倒的顺序打印依赖的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -S</span><br></pre></td></tr></table></figure><p>例如，你也许想要以列表格式列出设备，而不是默认的树状格式。可以将两个不同的选项组合，以获得期望的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -nl</span><br></pre></td></tr></table></figure><h2 id="fdisk命令-–-磁盘分区"><a href="#fdisk命令-–-磁盘分区" class="headerlink" title="fdisk命令 – 磁盘分区"></a>fdisk命令 – 磁盘分区</h2><p>fdisk命令的英文全称是“Partition table manipulator for Linux”，即作为磁盘的分区工具。进行硬盘分区从实质上说就是对硬盘的一种格式化， 用一个形象的比喻，分区就好比在一张白纸上画一个大方框，而格式化好比在方框里打上格子。</p><p><strong>语法格式：</strong>fdisk [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-b</th><th>指定每个分区的大小</th></tr></thead><tbody><tr><td>-l</td><td>列出指定的外围设备的分区表状况</td></tr><tr><td>-s</td><td>将指定的分区大小输出到标准输出上，单位为区块</td></tr><tr><td>-u</td><td>搭配”-l”参数列表，会用分区数目取代柱面数目，来表示每个分区的起始地址</td></tr><tr><td>-v</td><td>显示版本信息</td></tr></tbody></table><p><strong>参考实例</strong></p><p>查看所有分区情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>选择分区磁盘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br></pre></td></tr></table></figure><p>在当前磁盘上建立扩展分区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /ext</span><br></pre></td></tr></table></figure><p>不检查磁盘表面加快分区操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /actok</span><br></pre></td></tr></table></figure><p>重建主引导记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk /cmbr</span><br></pre></td></tr></table></figure><h2 id="quota命令-–-显示磁盘已使用的空间与限制"><a href="#quota命令-–-显示磁盘已使用的空间与限制" class="headerlink" title="quota命令 – 显示磁盘已使用的空间与限制"></a>quota命令 – 显示磁盘已使用的空间与限制</h2><p>quota命令用于显示磁盘已使用的空间与限制。执行quota命令可查询磁盘空间的限制，并得知已使用多少空间。</p><p><strong>语法参数：</strong>quota [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-g</th><th>列出群组的磁盘空间限制</th></tr></thead><tbody><tr><td>-q</td><td>简明列表，只列出超过限制的部分</td></tr><tr><td>-u</td><td>列出用户的磁盘空间限制</td></tr><tr><td>-v</td><td>显示该用户或群组，在所有挂入系统的存储设备的空间限制</td></tr><tr><td>-V</td><td>显示版本信息</td></tr></tbody></table><p><strong>参考实例</strong></p><p>显示目前执行者（root ）的 quota 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quota -guvs</span><br></pre></td></tr></table></figure><p>显示 test 这个使用者的 quota 值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quota -uvs test</span><br></pre></td></tr></table></figure><h2 id="arpd命令-–-收集arp信息"><a href="#arpd命令-–-收集arp信息" class="headerlink" title="arpd命令 – 收集arp信息"></a>arpd命令 – 收集arp信息</h2><p>arpd命令是用来收集免费arp信息的一个守护进程，它将收集到的信息保存在磁盘上或者在需要时，提供给内核用户用于避免多余广播。</p><p><strong>语法格式：</strong>arpd [参数]</p><p><strong>参考实例</strong></p><table><thead><tr><th>-l</th><th>将arp数据库输出到标准输出设备显示并退出</th></tr></thead><tbody><tr><td>-f</td><td>指定读取和加载arpd数据库的文本文件，文件的格式与“-l”输出信息类似</td></tr><tr><td>-b</td><td>指定arpd数据库文件，默认的位置为“/var/lib/arpd.db</td></tr><tr><td>-a</td><td>指定目标被认为死掉前查询的次数</td></tr><tr><td>-k</td><td>禁止通过内核发送广播查询</td></tr><tr><td>-n</td><td>设定缓冲失效时间</td></tr></tbody></table><p><strong>常用参数：</strong>﻿</p><p>启动arpd进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpd -b /var/tmp/arpd.db</span><br></pre></td></tr></table></figure><p>一段时间后看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall arpd ; arpd -l -b /var/tmp/arpd.db</span><br></pre></td></tr></table></figure><p>启用内核帮助程序，将主要角色留给内核：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpd -b /var/tmp/arpd.db -a 1 eth0 eth1</span><br></pre></td></tr></table></figure><p>完全替换接口eth0和eth1上的内核决议。 在这种情况下，内核仍会进行单播探测以验证条目，但所有广播活动都被抑制并在arpd的授权下进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpd -b /var/tmp/arpd.db -a 3 -k eth0 eth1</span><br></pre></td></tr></table></figure><p>禁止内核发送广播查询 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arpd -k</span><br></pre></td></tr></table></figure><h1 id="5-文件传输"><a href="#5-文件传输" class="headerlink" title="5. 文件传输"></a>5. 文件传输</h1><h2 id="curl命令-–-文件传输工具"><a href="#curl命令-–-文件传输工具" class="headerlink" title="curl命令 – 文件传输工具"></a>curl命令 – 文件传输工具</h2><p>curl命令是一个利用URL规则在shell终端命令行下工作的文件传输工具；它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。</p><p>作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征；做网页处理流程和数据检索自动化。</p><p><strong>语法格式：</strong>curl [参数] [网址]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-O</th><th>把输出写到该文件中，保留远程文件的文件名</th></tr></thead><tbody><tr><td>-u</td><td>通过服务端配置的用户名和密码授权访问</td></tr></tbody></table><p><strong>参考实例</strong></p><p>将下载的数据写入到文件，必须使用文件的绝对地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://www.linuxcool.com/abc.txt --silent -O</span><br></pre></td></tr></table></figure><p>访问需要授权的页面时，可通过-u选项提供用户名和密码进行授权：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -u root https://www.linuxprobe.com/</span><br><span class="line">Enter host password for user &apos;root&apos;:</span><br></pre></td></tr></table></figure><h2 id="ftpwho命令-–-显示ftp会话信息"><a href="#ftpwho命令-–-显示ftp会话信息" class="headerlink" title="ftpwho命令 – 显示ftp会话信息"></a>ftpwho命令 – 显示ftp会话信息</h2><p>ftpwho命令用于显示当前所有以FTP登入的用户会话信息。</p><p>执行该命令可得知当前用FTP登入系统的用户有哪些人，以及他们正在进行的操作。</p><p><strong>语法格式：</strong>ftpwho [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-h</th><th>显示帮助信息</th></tr></thead><tbody><tr><td>-v</td><td>详细模式，输出更多信息</td></tr></tbody></table><p><strong>参考实例</strong></p><p>查询当前正在登录FTP 服务器的用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftpwho</span><br></pre></td></tr></table></figure><h2 id="fsck命令-–-检查并修复Linux文件系统"><a href="#fsck命令-–-检查并修复Linux文件系统" class="headerlink" title="fsck命令 – 检查并修复Linux文件系统"></a>fsck命令 – 检查并修复Linux文件系统</h2><p>fsck命令的英文全称是“filesystem check”，即检查文件系统的意思，常用于检查并修复Linux文件系统的一些错误信息，操作文件系统需要先备份重要数据，以防丢失。</p><p>Linux fsck命令用于检查并修复Linux文件系统，可以同时检查一个或多个 Linux 文件系统；若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p><p><strong>语法格式：</strong>fsck [参数] [文件系统]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-a</th><th>自动修复文件系统，不询问任何问题</th></tr></thead><tbody><tr><td>-A</td><td>依照/etc/fstab配置文件的内容，检查文件内所列的全部文件系统</td></tr><tr><td>-N</td><td>不执行指令，仅列出实际执行会进行的动作</td></tr><tr><td>-P</td><td>当搭配”-A”参数使用时，则会同时检查所有的文件系统</td></tr><tr><td>-r</td><td>采用互动模式，在执行修复时询问问题，让用户得以确认并决定处理方式</td></tr><tr><td>-R</td><td>当搭配”-A”参数使用时，则会略过/目录的文件系统不予检查</td></tr><tr><td>-t</td><td>指定要检查的文件系统类型</td></tr><tr><td>-T</td><td>执行fsck指令时，不显示标题信息</td></tr><tr><td>-V</td><td>显示指令执行过程</td></tr></tbody></table><p><strong>参考实例</strong></p><p>修复坏的分区文件系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fsck -t ext3 -r /usr/local</span><br><span class="line"> fsck from util-linux 2.23.2</span><br><span class="line"> e2fsck 1.42.9 (28-Dec-2013)</span><br><span class="line"> fsck.ext3: Is a directory while trying to open /usr/local</span><br><span class="line"> The superblock could not be read or does not describe a correct ext2</span><br><span class="line"> filesystem.  If the device is valid and it really contains an ext2</span><br><span class="line"> filesystem (and not swap or ufs or something else), then the superblock</span><br><span class="line"> is corrupt, and you might try running e2fsck with an alternate superblock:</span><br><span class="line">     e2fsck -b 8193 </span><br><span class="line"> /usr/local: status 8, rss 1232, real 0.020288, user 0.002022, sys 0.005354</span><br></pre></td></tr></table></figure><p>显示fsck系统安装的版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fsck --version </span><br><span class="line">fsck from util-linux 2.23.2</span><br></pre></td></tr></table></figure><h2 id="ftpshut命令-–-指定时间关闭FTP服务器"><a href="#ftpshut命令-–-指定时间关闭FTP服务器" class="headerlink" title="ftpshut命令 – 指定时间关闭FTP服务器"></a>ftpshut命令 – 指定时间关闭FTP服务器</h2><p>ftpshut命令为系统管理者提供了在设置的时间关闭FTP服务器，且能在关闭之前发出警告信息通知用户的功能。</p><p>关闭时间若设置后为”none”，则会马上关闭服务器。如果采用”+30″的方式来设置表示服务器在30分钟之后关闭。依次类推，假设使用”1130″的格式则代表服务器会在每日的11时30分关闭，时间格式为24 小时制。FTP服务器关闭后，在/etc目录下会产生一个名称为shutmsg的文件，把它删除后即可再次启用FTP服务器。</p><p><strong>语法格式：</strong>ftpshut [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-d</th><th>切断所有FTP连线时间</th></tr></thead><tbody><tr><td>-l</td><td>停止接受FTP登入的时间</td></tr></tbody></table><p><strong>参考实例</strong></p><p>在晚上11:00 关闭FTP服务器，并在关闭前5 分钟拒绝新的FTP登录，前3 分钟关闭所有ftp的链接，且给出警告信息 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftpshut-d 3 -1 5 1100 &quot;Server will be shutdown at 23:00:00&quot;</span><br></pre></td></tr></table></figure><h2 id="lprm命令-–-删除打印队列中的打印任务"><a href="#lprm命令-–-删除打印队列中的打印任务" class="headerlink" title="lprm命令 – 删除打印队列中的打印任务"></a>lprm命令 – 删除打印队列中的打印任务</h2><p>lprm命令的英文全称是“Remove jobs from the print queue”，意为用于删除打印队列中的打印任务。尚未完成的打印机工作会被放在打印机贮列之中，这个命令可用来将未送到打印机的工作取消。</p><p><strong>语法格式：</strong>lprm [参数] [任务编号]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-E</th><th>与打印服务器连接时强制使用加密</th></tr></thead><tbody><tr><td>-P</td><td>指定接受打印任务的目标打印机</td></tr><tr><td>-U</td><td>指定可选的用户名</td></tr></tbody></table><p><strong>参考实例</strong></p><p>将打印机hpprint中的第102号任务移除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lprm -Phpprint 102</span><br></pre></td></tr></table></figure><p>将第101号任务由预设打印机中移除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lprm 101</span><br></pre></td></tr></table></figure><h1 id="6-网络通讯"><a href="#6-网络通讯" class="headerlink" title="6. 网络通讯"></a>6. 网络通讯</h1><h2 id="ping命令-–-测试主机间网络连通性"><a href="#ping命令-–-测试主机间网络连通性" class="headerlink" title="ping命令 – 测试主机间网络连通性"></a>ping命令 – 测试主机间网络连通性</h2><p>ping命令主要用来测试主机之间网络的连通性，也可以用于。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p><p>不过值得我们注意的是：Linux系统下的ping命令与Windows系统下的ping命令稍有不同。Windows下运行ping命令一般会发出4个请求就结束运行该命令；而Linux下不会自动终止，此时需要我们按CTR+C终止或者使用-c参数为ping命令指定发送的请求数目。</p><p><strong>语法格式：</strong>ping [参数] [目标主机]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-d</th><th>使用Socket的SO_DEBUG功能</th></tr></thead><tbody><tr><td>-c</td><td>指定发送报文的次数</td></tr><tr><td>-i</td><td>指定收发信息的间隔时间</td></tr><tr><td>-I</td><td>使用指定的网络接口送出数据包</td></tr><tr><td>-l</td><td>设置在送出要求信息之前，先行发出的数据包</td></tr><tr><td>-n</td><td>只输出数值</td></tr><tr><td>-p</td><td>设置填满数据包的范本样式</td></tr><tr><td>-q</td><td>不显示指令执行过程</td></tr><tr><td>-R</td><td>记录路由过程</td></tr><tr><td>-s</td><td>设置数据包的大小</td></tr><tr><td>-t</td><td>设置存活数值TTL的大小</td></tr><tr><td>-v</td><td>详细显示指令的执行过程</td></tr></tbody></table><p><strong>参考实例</strong></p><p>检测与linuxcool网站的连通性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.linuxcool.com</span><br></pre></td></tr></table></figure><p>连续ping4次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 4 www.linuxcool.com</span><br></pre></td></tr></table></figure><p>设置次数为4，时间间隔为3秒：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 4 -i 3 www.linuxcool.com</span><br></pre></td></tr></table></figure><p>利用ping命令获取指定网站的IP地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping -c 1 linuxcool.com | grep from | cut -d &quot; &quot; -f 4</span><br><span class="line">220.181.57.216</span><br></pre></td></tr></table></figure><h2 id="netstat命令-–-显示网络状态"><a href="#netstat命令-–-显示网络状态" class="headerlink" title="netstat命令 – 显示网络状态"></a>netstat命令 – 显示网络状态</h2><p>netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。</p><p>从整体上看，netstat的输出结果可以分为两个部分：一个是Active Internet connections，称为有源TCP连接，其中”Recv-Q”和”Send-Q”指%0A的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到；另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。</p><p><strong>语法格式：</strong>netstat [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-a</th><th>显示所有连线中的Socket</th></tr></thead><tbody><tr><td>-p</td><td>显示正在使用Socket的程序识别码和程序名称</td></tr><tr><td>-u</td><td>显示UDP传输协议的连线状况</td></tr><tr><td>-i</td><td>显示网络界面信息表单</td></tr><tr><td>-n</td><td>直接使用IP地址，不通过域名服务器</td></tr></tbody></table><p><strong>参考实例</strong></p><p>显示详细的网络状况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -a</span><br></pre></td></tr></table></figure><p>显示当前户籍UDP连接状况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nu</span><br></pre></td></tr></table></figure><p>显示UDP端口号的使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">netstat -apu </span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address  Foreign Address  State  PID/Program name    </span><br><span class="line">udp        0      0 0.0.0.0:bootpc          0.0.0.0:*      4000/dhclient       </span><br><span class="line">udp        0      0 localhost:323           0.0.0.0:*      3725/chronyd        </span><br><span class="line">udp6       0      0 localhost:323           [::]:*         3725/chronyd</span><br></pre></td></tr></table></figure><p>显示网卡列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netstat -i </span><br><span class="line">Kernel Interface table </span><br><span class="line">Iface MTU Met  RX-OK  RX-ERR  RX-DRP RX-OVR  TX-OK TX-ERR TX-DRP TX-OVR Flg </span><br><span class="line">eth0 1500   0  181864   0      0       0     141278   0     0     0    BMRU </span><br><span class="line">lo   16436  0   3362    0      0       0     3362     0     0     0    LRU</span><br></pre></td></tr></table></figure><p>显示组播组的关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">netstat -g </span><br><span class="line">IPv6/IPv4 Group Memberships Interface    </span><br><span class="line">RefCnt Group </span><br><span class="line">--------------- ------ --------------------- </span><br><span class="line">lo        1   ALL-SYSTEMS.MCAST.NET </span><br><span class="line">eth0      1   ALL-SYSTEMS.MCAST.NET lo       1   ff02::1 </span><br><span class="line">eth0      1   ff02::1:ff0a:b0c eth0          1   ff02::1</span><br></pre></td></tr></table></figure><h2 id="ifconfig命令-–-显示或设置网络设备"><a href="#ifconfig命令-–-显示或设置网络设备" class="headerlink" title="ifconfig命令 – 显示或设置网络设备"></a>ifconfig命令 – 显示或设置网络设备</h2><p>ifconfig命令的英文全称是“network interfaces configuring”，即用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p><p><strong>语法格式：</strong>ifconfig [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>add&lt;地址&gt;</th><th>设置网络设备IPv6的IP地址</th></tr></thead><tbody><tr><td>del&lt;地址&gt;</td><td>删除网络设备IPv6的IP地址</td></tr><tr><td>down</td><td>关闭指定的网络设备</td></tr><tr><td>up</td><td>启动指定的网络设备</td></tr><tr><td>IP地址</td><td>指定网络设备的IP地址</td></tr></tbody></table><p><strong>参考实例</strong></p><p>显示网络设备信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig</span><br><span class="line">eth0   Link encap:Ethernet HWaddr 00:50:56:0A:0B:0C       </span><br><span class="line">       inet addr:192.168.0.3 Bcast:192.168.0.255 Mask:255.255.255.0</span><br><span class="line">       inet6 addr: fe80::250:56ff:fe0a:b0c/64 Scope:Link     </span><br><span class="line">       UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1      </span><br><span class="line">       RX packets:172220 errors:0 dropped:0 overruns:0 frame:0      </span><br><span class="line">       TX packets:132379 errors:0 dropped:0 overruns:0 carrier:0 </span><br><span class="line">       collisions:0 txqueuelen:1000       </span><br><span class="line">       RX bytes:87101880 (83.0 MiB) TX bytes:41576123 (39.6 MiB) </span><br><span class="line">       Interrupt:185 Base address:0x2024  </span><br><span class="line">lo    Link encap:Local Loopback       </span><br><span class="line">      inet addr:127.0.0.1 Mask:255.0.0.0      </span><br><span class="line">      inet6 addr: ::1/128 Scope:Host      </span><br><span class="line">      UP LOOPBACK RUNNING MTU:16436 Metric:1      </span><br><span class="line">      RX packets:2022 errors:0 dropped:0 overruns:0 frame:0      </span><br><span class="line">      TX packets:2022 errors:0 dropped:0 overruns:0 carrier:0   </span><br><span class="line">      collisions:0 txqueuelen:0       </span><br><span class="line">      RX bytes:2459063 (2.3 MiB) </span><br><span class="line">      TX bytes:2459063 (2.3 MiB)</span><br></pre></td></tr></table></figure><p>启动关闭指定网卡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 down</span><br><span class="line"># ifconfig eth0 up</span><br></pre></td></tr></table></figure><p>为网卡配置和删除IPv6地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 add 33ffe:3240:800:1005::2/64</span><br><span class="line"># ifconfig eth0 del 33ffe:3240:800:1005::2/64</span><br></pre></td></tr></table></figure><p>用ifconfig修改MAC地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 down</span><br><span class="line"># ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE</span><br><span class="line"># ifconfig eth0 up</span><br><span class="line"># ifconfig eth1 hw ether 00:1D:1C:1D:1E </span><br><span class="line"># ifconfig eth1 up</span><br></pre></td></tr></table></figure><p>配置IP地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig eth0 192.168.1.56 </span><br><span class="line"># ifconfig eth0 192.168.1.56 netmask 255.255.255.0</span><br><span class="line"># ifconfig eth0 192.168.1.56 netmask 255.255.255.0 broadcast 192.168.1.255</span><br></pre></td></tr></table></figure><h2 id="ss命令-–-显示活动套接字信息"><a href="#ss命令-–-显示活动套接字信息" class="headerlink" title="ss命令 – 显示活动套接字信息"></a>ss命令 – 显示活动套接字信息</h2><p>ss是Socket Statistics的缩写。ss命令用来显示处于活动状态的套接字信息。它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。</p><p><strong>语法格式：</strong>ss [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-n</th><th>不解析服务名称，已数字方式显示</th></tr></thead><tbody><tr><td>-a</td><td>显示所有套接字</td></tr><tr><td>-l</td><td>显示处于监听状态的套接字</td></tr><tr><td>-o</td><td>显示计时器信息</td></tr><tr><td>-e</td><td>显示详细的套接字信息</td></tr><tr><td>-m</td><td>显示套接字的内存使用情况</td></tr><tr><td>-p</td><td>显示使用套接字的进程</td></tr><tr><td>-i</td><td>显示内部的TCP信息</td></tr><tr><td>-s</td><td>显示套接字使用概况</td></tr><tr><td>-4</td><td>仅显示ipv4的套接字</td></tr><tr><td>-6</td><td>仅显示ipv6的套接字</td></tr><tr><td>-0</td><td>显示PACKET套接字</td></tr><tr><td>-t</td><td>只显示TCP套接字</td></tr><tr><td>-u</td><td>只显示UDP套接字</td></tr><tr><td>-d</td><td>只显示DCCP套接字</td></tr><tr><td>-w</td><td>只显示RAW套接字</td></tr><tr><td>-x</td><td>只显示 Unix套接字</td></tr><tr><td>-D</td><td>将原始TCP套接字信息转储到文件</td></tr></tbody></table><p><strong>参考实例</strong></p><p>显示TCP套接字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># ss -t -a </span><br><span class="line">State     Recv-Q     Send-Q     Local Address:Port     Peer Address:Port   </span><br><span class="line">LISTEN    0          128        0.0.0.0:ssh            0.0.0.0:*                                </span><br><span class="line">ESTAB     0          52         192.168.60.19:ssh      192.168.30.21:59321               </span><br><span class="line">LISTEN    0          128        *:websm                *:*               </span><br><span class="line">LISTEN    0          128        [::]:ssh               [::]:*</span><br></pre></td></tr></table></figure><p>显示UDP套接字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ss -u -a</span><br><span class="line">State     Recv-Q     Send-Q     Local Address:Port     Peer Address:Port              </span><br><span class="line">UNCONN    0          0          0.0.0.0:bootpc         0.0.0.0:*                 </span><br><span class="line">UNCONN    0          0          127.0.0.1:323          0.0.0.0:*                 </span><br><span class="line">UNCONN    0          0          [::1]:323              [::]:*</span><br></pre></td></tr></table></figure><p>显示套接字使用概况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ss -s</span><br><span class="line">Total: 185</span><br><span class="line">TCP:   4 (estab 1, closed 0, orphaned 0, timewait 0)</span><br><span class="line">Transport Total     IP        IPv6</span><br><span class="line">RAW       1         0         1        </span><br><span class="line">UDP       3         2         1        </span><br><span class="line">TCP       4         2         2        </span><br><span class="line">INET      8         4         4        </span><br><span class="line">FRAG      0         0         0</span><br></pre></td></tr></table></figure><h2 id="ipcalc命令-–-简单的IP地址计算器"><a href="#ipcalc命令-–-简单的IP地址计算器" class="headerlink" title="ipcalc命令 – 简单的IP地址计算器"></a>ipcalc命令 – 简单的IP地址计算器</h2><p>ipcalc命令的全称是：Calculate IP information for a host（计算主机的IP信息）</p><p>ipcalc命令是一个简单的ip地址计算器，可以完成简单的IP地址计算任务。</p><p><strong>语法格式：</strong> ipcalc [参数] [IP地址]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-b</th><th>由给定的IP地址和网络掩码计算出广播地址</th></tr></thead><tbody><tr><td>-h</td><td>显示给定IP地址所对应的主机名</td></tr><tr><td>-m</td><td>由给定的IP地址计算器网络掩码</td></tr><tr><td>-p</td><td>显示给定的掩码或IP地址的前缀</td></tr><tr><td>-n</td><td>由给定的IP地址和网络掩码计算网络地址</td></tr><tr><td>-s</td><td>安静模式，不显示任何错误信息</td></tr><tr><td>–help</td><td>显示帮助信息</td></tr></tbody></table><p><strong>参考实例</strong></p><p>计算给定掩码的前缀 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ipcalc -p 192.168.88.56 255.255.255.0</span><br><span class="line">PREFIX=24</span><br></pre></td></tr></table></figure><p>给定IP和网络掩码计算网络地址 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ipcalc -n 192.168.88.56 255.255.255.0</span><br><span class="line">NETWORK=192.168.88.0</span><br></pre></td></tr></table></figure><p>给定IP显示对应的主机名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ipcalc -h 223.5.5.5</span><br><span class="line">HOSTNAME=public1.alidns.com</span><br></pre></td></tr></table></figure><p>使用多个参数计算给定IP的网络掩码，广播地址，网络地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ipcalc -m -b -n 119.29.29.29/28</span><br><span class="line">NETMASK=255.255.255.240</span><br><span class="line">BROADCAST=119.29.29.31</span><br><span class="line">NETWORK=119.29.29.16</span><br></pre></td></tr></table></figure><h1 id="7-设备管理"><a href="#7-设备管理" class="headerlink" title="7. 设备管理"></a>7. 设备管理</h1><h2 id="mount命令-–-文件系统挂载"><a href="#mount命令-–-文件系统挂载" class="headerlink" title="mount命令 – 文件系统挂载"></a>mount命令 – 文件系统挂载</h2><p>mount命令用于加载文件系统到指定的加载点。此命令的最常用于挂载cdrom，使我们可以访问cdrom中的数据，因为你将光盘插入cdrom中，Linux并不会自动挂载，必须使用Linux mount命令来手动完成挂载。</p><p><strong>语法格式：</strong>mount [参数]</p><p><strong>常用参数：</strong>﻿</p><table><thead><tr><th>-t</th><th>指定挂载类型</th></tr></thead><tbody><tr><td>-l</td><td>显示已加载的文件系统列表</td></tr><tr><td>-h</td><td>显示帮助信息并退出</td></tr><tr><td>-V</td><td>显示程序版本</td></tr><tr><td>-n</td><td>加载没有写入文件“/etc/mtab”中的文件系统</td></tr><tr><td>-r</td><td>将文件系统加载为只读模式</td></tr><tr><td>-a</td><td>加载文件“/etc/fstab”中描述的所有文件系统</td></tr></tbody></table><p><strong>参考实例</strong>﻿</p><p>查看版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount -V</span><br></pre></td></tr></table></figure><p>启动所有挂载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount -a</span><br></pre></td></tr></table></figure><p>挂载 /dev/cdrom 到 /mnt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount /dev/cdrom /mnt</span><br></pre></td></tr></table></figure><p>挂载nfs格式文件系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount -t nfs /123 /mnt</span><br></pre></td></tr></table></figure><p>挂载第一块盘的第一个分区到/etc目录 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount -t ext4 -o loop,default /dev/sda1 /etc</span><br></pre></td></tr></table></figure><h2 id="setleds命令-–-设定键盘上方三个-LED-的状态"><a href="#setleds命令-–-设定键盘上方三个-LED-的状态" class="headerlink" title="setleds命令 – 设定键盘上方三个 LED 的状态"></a>setleds命令 – 设定键盘上方三个 LED 的状态</h2><p>setleds即是英文词组“set leds”的合并，翻译为中文就是设置LED灯。setleds命令用来设定键盘上方三个 LED 灯的状态。在 Linux 中，每一个虚拟主控台都有独立的设定。</p><p>这是一个十分神奇的命令，竟然可以通过命令来控制键盘的灯的状态。那么下面我一起来学习一下这个命令吧。</p><p><strong>语法格式：</strong>setleds [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-F</th><th>设定虚拟主控台的状态</th></tr></thead><tbody><tr><td>-D</td><td>改变虚拟主控台的状态和预设的状态</td></tr><tr><td>-L</td><td>直接改变 LED 显示的状态</td></tr><tr><td>+num/-num</td><td>将数字键打开或关闭</td></tr><tr><td>+caps/-caps</td><td>把大小写键打开或关闭</td></tr><tr><td>+scroll /-scroll</td><td>把选项键打开或关闭</td></tr></tbody></table><p><strong>参考实例</strong></p><p>控制键盘灯num灯亮和灯灭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># setleds +num </span><br><span class="line"># setleds -num</span><br></pre></td></tr></table></figure><p>控制键盘的大小写键打开或关闭，键盘指示灯亮与灭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># setleds +caps </span><br><span class="line"># setleds -caps</span><br></pre></td></tr></table></figure><p>控制键盘的选项键打开或关闭，键盘指示灯亮与灭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># setleds +scroll</span><br></pre></td></tr></table></figure><p>对三灯的亮与灭的情况进行组合，分别设置为数字灯亮，大小写灯灭，选项键scroll灯灭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># setleds +num -caps -scroll</span><br></pre></td></tr></table></figure><h2 id="loadkeys命令-–-改变linux键盘驱动程序"><a href="#loadkeys命令-–-改变linux键盘驱动程序" class="headerlink" title="loadkeys命令 – 改变linux键盘驱动程序"></a>loadkeys命令 – 改变linux键盘驱动程序</h2><p>loadkeys命令可以根据一个键盘定义表改变 linux 键盘驱动程序转译键盘输入过程。</p><p><strong>语法格式：</strong>loadkeys [参数] [文件]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-v</th><th>印出详细的资料，你可以重复以增加详细度</th></tr></thead><tbody><tr><td>-q</td><td>不要显示任何讯息</td></tr><tr><td>-c</td><td>清除所有 composite 定义</td></tr><tr><td>-s</td><td>将定串定义表清除</td></tr></tbody></table><p><strong>参考实例</strong></p><p>显示功能键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># loadkeys --funcs-only</span><br></pre></td></tr></table></figure><p>将定串定义表清除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># loadkeys -s</span><br></pre></td></tr></table></figure><p>清除所有 composite 定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># loadkeys -c</span><br></pre></td></tr></table></figure><p>印出详细的资料，你可以重复以增加详细度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># loadkeys -v</span><br></pre></td></tr></table></figure><p>不要显示任何讯息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># loadkeys -q</span><br></pre></td></tr></table></figure><h1 id="8-备份压缩"><a href="#8-备份压缩" class="headerlink" title="8. 备份压缩"></a>8. 备份压缩</h1><h2 id="gzip命令-–-压缩和解压文件"><a href="#gzip命令-–-压缩和解压文件" class="headerlink" title="gzip命令 – 压缩和解压文件"></a>gzip命令 – 压缩和解压文件</h2><p>gzip命令的英文是“GNUzip”，是常用来压缩文件的工具，gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。</p><p>gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。</p><p><strong>语法格式：</strong>gzip [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-a</th><th>使用ASCII文字模式</th></tr></thead><tbody><tr><td>-d</td><td>解开压缩文件</td></tr><tr><td>-f</td><td>强行压缩文件</td></tr><tr><td>-l</td><td>列出压缩文件的相关信息</td></tr><tr><td>-c</td><td>把压缩后的文件输出到标准输出设备，不去更动原始文件</td></tr><tr><td>-r</td><td>递归处理，将指定目录下的所有文件及子目录一并处理</td></tr><tr><td>-q</td><td>不显示警告信息</td></tr></tbody></table><p><strong>参考实例</strong></p><p>把rancher-v2.2.0目录下的每个文件压缩成.gz文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># gzip *</span><br></pre></td></tr></table></figure><p>把上例中每个压缩的文件解压，并列出详细的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># gzip -dv *</span><br></pre></td></tr></table></figure><p>递归地解压目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># gzip -dr rancher.gz</span><br></pre></td></tr></table></figure><h2 id="unzip命令-–-解压缩zip文件"><a href="#unzip命令-–-解压缩zip文件" class="headerlink" title="unzip命令 – 解压缩zip文件"></a>unzip命令 – 解压缩zip文件</h2><p>unzip命令是用于.zip格式文件的解压缩工具 ，unzip命令将列出、测试或从zip格式存档中提取文件，这些文件通常位于MS-DOS系统上。</p><p>默认行为（就是没有选项）是从指定的ZIP存档中提取所有的文件到当前目录（及其下面的子目录）。一个配套程序zip（1L）创建ZIP存档；这两个程序都与PKWARE的PKZIP和PKUNZIP为MS-DOS创建的存档文件兼容，但许多情况下，程序选项或默认行为是不同的。</p><p><strong>语法格式：</strong>unzip [参数] [文件]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-l</th><th>显示压缩文件内所包含的文件</th></tr></thead><tbody><tr><td>-v</td><td>执行时显示详细的信息</td></tr><tr><td>-c</td><td>将解压缩的结果显示到屏幕上，并对字符做适当的转换</td></tr><tr><td>-n</td><td>解压缩时不要覆盖原有的文件</td></tr><tr><td>-j</td><td>不处理压缩文件中原有的目录路径</td></tr></tbody></table><p><strong>参考实例</strong></p><p>把/home目录下面的mydata.zip解压到mydatabak目录里面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># unzip mydata.zip -d mydatabak</span><br></pre></td></tr></table></figure><p>把/home目录下面的wwwroot.zip直接解压到/home目录里面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># unzip wwwroot.zip</span><br></pre></td></tr></table></figure><p>把/home目录下面的abc12.zip、abc23.zip、abc34.zip同时解压到/home目录里面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># unzip abc\*.zip</span><br></pre></td></tr></table></figure><p>查看把/home目录下面的wwwroot.zip里面的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># unzip -v wwwroot.zip</span><br></pre></td></tr></table></figure><p>验证/home目录下面的wwwroot.zip是否完整：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># unzip -t wwwroot.zip</span><br></pre></td></tr></table></figure><h2 id="zip命令-–-压缩文件"><a href="#zip命令-–-压缩文件" class="headerlink" title="zip命令 – 压缩文件"></a>zip命令 – 压缩文件</h2><p>zip程序将一个或多个压缩文件与有关文件的信息(名称、路径、日期、上次修改的时间、保护和检查信息以验证文件完整性)一起放入一个压缩存档中。可以使用一个命令将整个目录结构打包到zip存档中。</p><p>对于文本文件来说，压缩比为2：1和3：1是常见的。zip只有一种压缩方法(通缩)，并且可以在不压缩的情况下存储文件。(如果添加了bzip 2支持，zip也可以使用bzip 2压缩，但这些条目需要一个合理的现代解压缩来解压缩。当选择bzip 2压缩时，它将通货紧缩替换为默认方法。)zip会自动为每个要压缩的文件选择更好的两个文件(通缩或存储，如果选择bzip2，则选择bzip2或Store)。</p><p><strong>语法格式：</strong>zip [参数] [文件]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-q</th><th>不显示指令执行过程</th></tr></thead><tbody><tr><td>-r</td><td>递归处理，将指定目录下的所有文件和子目录一并处理</td></tr><tr><td>-z</td><td>替压缩文件加上注释</td></tr><tr><td>-v</td><td>显示指令执行过程或显示版本信息</td></tr><tr><td>-n&lt;字尾字符串&gt;</td><td>不压缩具有特定字尾字符串的文件</td></tr></tbody></table><p><strong>参考实例</strong></p><p>将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># zip -q -r html.zip /home/html</span><br></pre></td></tr></table></figure><p>压缩文件 cp.zip 中删除文件 a.c：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># zip -dv cp.zip a.c</span><br></pre></td></tr></table></figure><p>把/home目录下面的mydata目录压缩为mydata.zip：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># zip -r mydata.zip mydata</span><br></pre></td></tr></table></figure><p>把/home目录下面的abc文件夹和123.txt压缩成为abc123.zip：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># zip -r abc123.zip abc 123.txt</span><br></pre></td></tr></table></figure><p>将 logs目录打包成 log.zip：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># zip -r log.zip ./logs</span><br></pre></td></tr></table></figure><h2 id="bzip2命令-–-bz2文件的压缩程序"><a href="#bzip2命令-–-bz2文件的压缩程序" class="headerlink" title="bzip2命令 – bz2文件的压缩程序"></a>bzip2命令 – bz2文件的压缩程序</h2><p>Linux系统中bzip2命令的英文是“bunzip2”，即.bz2文件格式的压缩程序； bzip2命令系统默认是没有安装的，需要安装bzip2库才可以使用此命令。</p><p>bzip2命令采用新的压缩演算法，压缩效果比传统的LZ77/LZ78压缩演算法来得好。若没有加上任何参数，bzip2压缩完文件后会产生.bz2的压缩文件，并删除原始的文件。</p><p><strong>语法格式：</strong>bzip2 [参数] 文件系统</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-c</th><th>将压缩与解压缩的结果送到标准输出</th></tr></thead><tbody><tr><td>-d</td><td>执行解压缩</td></tr><tr><td>-f</td><td>bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖，请使用此参数</td></tr><tr><td>-k</td><td>bzip2在压缩或解压缩后，会删除原始的文件。若要保留原始文件，请使用此参数</td></tr><tr><td>-s</td><td>降低程序执行时内存的使用量</td></tr><tr><td>-t</td><td>测试.bz2压缩文件的完整性</td></tr><tr><td>-v</td><td>压缩或解压缩文件时，显示详细的信息</td></tr><tr><td>-z</td><td>强制执行压缩</td></tr></tbody></table><p><strong>参考实例</strong></p><p>压缩文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># bzip2 a.txt</span><br></pre></td></tr></table></figure><p>检查文件完整性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># bzip2 -t a.txt.bz2</span><br></pre></td></tr></table></figure><h2 id="zipinfo命令-–-查看压缩文件信息"><a href="#zipinfo命令-–-查看压缩文件信息" class="headerlink" title="zipinfo命令 – 查看压缩文件信息"></a>zipinfo命令 – 查看压缩文件信息</h2><p>zipinfo命令的全称为“zip information”，该命令用于列出压缩文件信息。执行zipinfo指令可得知zip压缩文件的详细信息。</p><p><strong>语法格式：</strong>zipinfo [参数]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-1</th><th>只列出文件名称</th></tr></thead><tbody><tr><td>-2</td><td>此参数的效果和指定”-1″参数类似，但可搭配”-h”,”-t”和”-z”参数使用</td></tr><tr><td>-h</td><td>只列出压缩文件的文件名称</td></tr><tr><td>-l</td><td>此参数的效果和指定”-m”参数类似，但会列出原始文件的大小而非每个文件的压缩率</td></tr><tr><td>-m</td><td>此参数的效果和指定”-s”参数类似，但多会列出每个文件的压缩率</td></tr><tr><td>-M</td><td>若信息内容超过一个画面，则采用类似more指令的方式列出信息</td></tr><tr><td>-s</td><td>用类似执行”ls -l”指令的效果列出压缩文件内容</td></tr><tr><td>-t</td><td>只列出压缩文件内所包含的文件数目，压缩前后的文件大小及压缩率</td></tr><tr><td>-T</td><td>将压缩文件内每个文件的日期时间用年，月，日，时，分，秒的顺序列出</td></tr><tr><td>-v</td><td>详细显示压缩文件内每一个文件的信息</td></tr><tr><td>-x&lt;范本样式&gt;</td><td>不列出符合条件的文件的信息</td></tr><tr><td>-z</td><td>如果压缩文件内含有注释，就将注释显示出来</td></tr></tbody></table><p><strong>参考实例</strong></p><p>显示压缩文件信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># zipinfo file.zip </span><br><span class="line">Archive: file.zip  486 bytes  3 files</span><br><span class="line">-rw-r--r-- 2.3 unx    0 bx stor 24-May-10 18:54 a.c</span><br><span class="line">-rw-r--r-- 2.3 unx    0 bx stor 24-May-10 18:54 b.c</span><br><span class="line">-rw-r--r-- 2.3 unx    0 bx stor 24-May-10 18:54 c.c</span><br><span class="line">3 files, 0 bytes uncompressed, 0 bytes compressed: 0.0%</span><br></pre></td></tr></table></figure><p>显示压缩文件中每个文件的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># zipinfo -v file.zip</span><br></pre></td></tr></table></figure><p>只显示压缩包大小、文件数目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># zipinfo -h file.zip             </span><br><span class="line">Archive:  file.zip</span><br><span class="line">Zip file size: 907 bytes, number of entries: 3</span><br></pre></td></tr></table></figure><p>生成一个基本的、长格式的列表(而不是冗长的)，包括标题和总计行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># zipinfo -l file</span><br></pre></td></tr></table></figure><p>查看存档中最近修改的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># zipinfo -T file | sort –nr -k 7 | sed 15q</span><br></pre></td></tr></table></figure><h1 id="9-其他命令"><a href="#9-其他命令" class="headerlink" title="9. 其他命令"></a>9. 其他命令</h1><h2 id="bc命令-–-浮点运算"><a href="#bc命令-–-浮点运算" class="headerlink" title="bc命令 – 浮点运算"></a>bc命令 – 浮点运算</h2><p>bc的英文全拼为“ Binary Calculator ”，是一种支持任意精度的交互执行的计算器语言。bash内置了对整数四则运算的支持，但是并不支持浮点运算，而bc命令可以很方便的进行浮点运算，当然整数运算也不再话下。</p><p><strong>语法格式：</strong>bc [选项]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-i</th><th>强制进入交互式模式</th></tr></thead><tbody><tr><td>-l</td><td>定义使用的标准数学库</td></tr><tr><td>-w</td><td>定义使用的标准数学库</td></tr><tr><td>-q</td><td>打印正常的GNU bc环境信息</td></tr></tbody></table><p><strong>参考实例</strong></p><p>算术操作高级运算bc命令它可以执行浮点运算和一些高级函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;1.212*3&quot; | bc </span><br><span class="line"> 3.636</span><br></pre></td></tr></table></figure><p>设定小数精度（数值范围）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;scale=2;3/8&quot; | bc</span><br><span class="line"> .37</span><br></pre></td></tr></table></figure><p>计算平方和平方根：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;10^10&quot; | bc</span><br><span class="line"> 10000000000</span><br><span class="line">[root@linuxcool ~]# echo &quot;sqrt(100)&quot; | bc</span><br><span class="line"> 10</span><br></pre></td></tr></table></figure><h2 id="rmmod命令-–-删除模块"><a href="#rmmod命令-–-删除模块" class="headerlink" title="rmmod命令 – 删除模块"></a>rmmod命令 – 删除模块</h2><p>rmmod即“remove module”的简称,rmmod命令用于删除模块。 执行rmmod命令，可删除不需要的模块。Linux操作系统的核心具有模块化的特性，因此在编译核心时，不需要吧全部功能都放入核心，可以将这些功能编译成一个个单独的模块，待有需要时再分别载入它们。</p><p><strong>语法格式：</strong>rmmod [参数] [模块名称]</p><p><strong>常用参数：</strong></p><table><thead><tr><th>-a</th><th>删除所有目前不需要的模块</th></tr></thead><tbody><tr><td>-s</td><td>把信息输出至syslog常驻服务，而非终端机界面</td></tr><tr><td>-v</td><td>显示指令执行的详细信息</td></tr><tr><td>-f</td><td>强制移除模块，使用此选项比较危险</td></tr><tr><td>-w</td><td>等待着，知道模块能够被除时再移除模块</td></tr></tbody></table><p><strong>参考实例</strong></p><p>卸载模块pppoe并显示执行信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rmmod -v pppoe</span><br></pre></td></tr></table></figure><p>卸载bridge模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rmmod bridge</span><br></pre></td></tr></table></figure><p>卸载bridge模块并将错误信息写入syslog：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rmmod -s bridge</span><br></pre></td></tr></table></figure><p>孤立正在使用的bridge模块，知道不被使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rmmod -w bridge</span><br></pre></td></tr></table></figure><p>删除正在使用的bridge模块（-f可以删除正在使用的模块，非常危险，慎用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rmmod -f bridge</span><br></pre></td></tr></table></figure><p><a href="https://www.linuxcool.com/" target="_blank" rel="noopener">Linux命令</a></p><p>我在上面这个网站看到的常用Linux命令，所以拿出来方便自己学习和记忆。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-文件管理&quot;&gt;&lt;a href=&quot;#1-文件管理&quot; class=&quot;headerlink&quot; title=&quot;1. 文件管理&quot;&gt;&lt;/a&gt;1. 文件管理&lt;/h1&gt;&lt;h2 id=&quot;ls命令-–-显示指定工作目录下的内容及属性信息&quot;&gt;&lt;a href=&quot;#ls命令-–-显示指定
      
    
    </summary>
    
      <category term="Linux" scheme="https://smallpotatody.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://smallpotatody.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>全国计算机信息安全技术</title>
    <link href="https://smallpotatody.github.io/2019/06/11/%E5%85%A8%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    <id>https://smallpotatody.github.io/2019/06/11/全国计算机信息安全技术/</id>
    <published>2019-06-11T11:48:07.000Z</published>
    <updated>2019-06-11T12:18:35.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="考试大纲"><a href="#考试大纲" class="headerlink" title="考试大纲"></a>考试大纲</h1><h2 id="基本要求"><a href="#基本要求" class="headerlink" title="　　基本要求"></a>　　基本要求</h2><p>　　1. 了解信息安全保障工作的总体思路和基本实践方法</p><p>　　2. 掌握信息安全技术的基本概念、原理、方法和技术</p><p>　　3. 熟练掌握计算机网络安全、系统软件安全和应用软件安全的基本知识和实践技能</p><p>　　4. 掌握信息安全设备的安装、配置和使用的基本方法</p><p>　　5. 了解信息系统安全设施部署与管理基本技术</p><p>　　6. 了解信息安全风险评估和等级保护原理与方法</p><p>　　7. 了解信息安全相关的标准、法律法规和道德规范</p><h2 id="考试内容"><a href="#考试内容" class="headerlink" title="　　考试内容"></a>　　考试内容</h2><h3 id="一、信息安全保障概述"><a href="#一、信息安全保障概述" class="headerlink" title="　　一、信息安全保障概述"></a>　　一、信息安全保障概述</h3><p>　　1. 信息安全保障的内涵和意义</p><p>　　2. 信息安全保障的总体思路和基本实践方法</p><h3 id="二、信息安全基础技术与原理"><a href="#二、信息安全基础技术与原理" class="headerlink" title="　　二、信息安全基础技术与原理"></a>　　二、信息安全基础技术与原理</h3><p>　　1. 密码技术</p><p>　　(1)对称密码与非对称密码</p><p>　　(2)哈希函数</p><p>　　(3)数字签名</p><p>　　(4)密钥管理</p><p>　　2. 认证技术</p><p>　　(1)消息认证</p><p>　　(2)身份认证</p><p>　　3. 访问控制技术</p><p>　　(1)访问控制模型</p><p>　　(2)访问控制技术</p><p>　　4. 审计和监控技术</p><p>　　(1)审计和监控基础</p><p>　　(2)审计和监控技术</p><h3 id="三、系统安全"><a href="#三、系统安全" class="headerlink" title="　　三、系统安全"></a>　　三、系统安全</h3><p>　　1. 操作系统安全</p><p>　　(1)操作系统安全基础</p><p>　　(2)操作系统安全实践</p><p>　　2. 数据库安全</p><p>　　(1)数据库安全基础</p><p>　　(2)数据库安全实践</p><h3 id="四、网络安全"><a href="#四、网络安全" class="headerlink" title="　　四、网络安全"></a>　　四、网络安全</h3><p>　　1. 网络安全基础</p><p>　　2. 网络安全威胁技术</p><p>　　3. 网络安全防护技术</p><p>　　(1)防火墙</p><p>　　(2)入侵检测系统与入侵防御系统</p><p>　　(3)PKI</p><p>　　(4)VPN</p><p>　　(5)网络安全协议</p><h3 id="五、应用安全"><a href="#五、应用安全" class="headerlink" title="　　五、应用安全"></a>　　五、应用安全</h3><p>　　1. 软件漏洞概念与原理</p><p>　　2. 软件安全开发</p><p>　　3. 软件安全检测</p><p>　　4. 软件安全保护</p><p>　　5. 恶意程序</p><p>　　6. Web 应用系统安全</p><h3 id="六、信息安全管理"><a href="#六、信息安全管理" class="headerlink" title="　　六、信息安全管理"></a>　　六、信息安全管理</h3><p>　　1. 信息安全管理体系</p><p>　　2. 信息安全风险评估</p><p>　　3. 信息安全管理措施</p><h3 id="七、信息安全标准与法规"><a href="#七、信息安全标准与法规" class="headerlink" title="　　七、信息安全标准与法规"></a>　　七、信息安全标准与法规</h3><p>　　1. 信息安全标准</p><p>　　2. 信息安全法律法规与国家政策</p><p>　　3. 信息安全从业人员道德规范</p><h2 id="考试方式"><a href="#考试方式" class="headerlink" title="　　考试方式"></a>　　考试方式</h2><p>　　上机考试，考试时长 120 分钟，满分 100 分。 包含：选择题(60 分)、填空题(20 分)、综合应用题(20 分)。</p><hr><h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h1><h2 id="第一章信息安全保障概述"><a href="#第一章信息安全保障概述" class="headerlink" title="第一章信息安全保障概述"></a>第一章信息安全保障概述</h2><h3 id="1-1信息安全保障背景"><a href="#1-1信息安全保障背景" class="headerlink" title="1.1信息安全保障背景"></a>1.1信息安全保障背景</h3><h4 id="1-1-1信息技术及其发展阶段"><a href="#1-1-1信息技术及其发展阶段" class="headerlink" title="1.1.1信息技术及其发展阶段"></a>1.1.1信息技术及其发展阶段</h4><p>信息技术两个方面：生产：信息技术产业；应用：信息技术扩散</p><p>信息技术核心：微电子技术，通信技术，计算机技术，网络技术</p><p>第一阶段，电讯技术的发明；第二阶段，计算机技术的发展；第三阶段，互联网的使用</p><h4 id="1-1-2信息技术的影响"><a href="#1-1-2信息技术的影响" class="headerlink" title="1.1.2信息技术的影响"></a>1.1.2信息技术的影响</h4><p>积极：社会发展，科技进步，人类生活</p><p>消极：信息泛滥，信息污染，信息犯罪</p><h3 id="1-2信息安全保障基础"><a href="#1-2信息安全保障基础" class="headerlink" title="1.2信息安全保障基础"></a>1.2信息安全保障基础</h3><h4 id="1-2-1信息安全发展阶段"><a href="#1-2-1信息安全发展阶段" class="headerlink" title="1.2.1信息安全发展阶段"></a>1.2.1信息安全发展阶段</h4><p>通信保密阶段（20世纪四十年代）：机密性，密码学</p><p>计算机安全阶段（20世纪六十和七十年代）：机密性、访问控制与认证，公钥密码学（Diffie</p><p>Hellman，DES），计算机安全标准化（安全评估标准）</p><p>信息安全保障阶段：信息安全保障体系（IA），PDRR模型：保护（protection）、检测（detection）、响应(response)、恢复（restore），我国PWDRRC模型：保护、预警（warning）、监测、应急、恢复、反击（counter-attack），BS/ISO 7799标准（有代表性的信息安全管理体系标准）：信息安全管理实施细则、信息安全管理体系规范</p><h4 id="1-2-2信息安全的含义"><a href="#1-2-2信息安全的含义" class="headerlink" title="1.2.2信息安全的含义"></a>1.2.2信息安全的含义</h4><p>一是运行系统的安全，二是系统信息的安全：口令鉴别、用户存取权限控制、数据存取权限方式控制、审计跟踪、数据加密等</p><p>信息安全的基本属性：完整性、机密性、可用性、可控制性、不可否认性</p><h4 id="1-2-3信息系统面临的安全风险"><a href="#1-2-3信息系统面临的安全风险" class="headerlink" title="1.2.3信息系统面临的安全风险"></a>1.2.3信息系统面临的安全风险</h4><h4 id="1-2-4信息安全问题产生的根源：信息系统的复杂性，人为和环境的威胁"><a href="#1-2-4信息安全问题产生的根源：信息系统的复杂性，人为和环境的威胁" class="headerlink" title="1.2.4信息安全问题产生的根源：信息系统的复杂性，人为和环境的威胁"></a>1.2.4信息安全问题产生的根源：信息系统的复杂性，人为和环境的威胁</h4><h4 id="1-2-5信息安全的地位和作用"><a href="#1-2-5信息安全的地位和作用" class="headerlink" title="1.2.5信息安全的地位和作用"></a>1.2.5信息安全的地位和作用</h4><h4 id="1-2-6信息安全技术"><a href="#1-2-6信息安全技术" class="headerlink" title="1.2.6信息安全技术"></a>1.2.6信息安全技术</h4><p>核心基础安全技术：密码技术</p><p>安全基础设施技术：标识与认证技术，授权与访问控制技术</p><p>基础设施安全技术：主机系统安全技术，网络系统安全技术</p><p>应用安全技术：网络与系统安全攻击技术，网络与系统安全防护与响应技术，安全审计与责任认定技术，恶意代码监测与防护技术</p><p>支撑安全技术：信息安全评测技术，信息安全管理技术</p><h2 id="1-3信息安全保障体系"><a href="#1-3信息安全保障体系" class="headerlink" title="1.3信息安全保障体系"></a>1.3信息安全保障体系</h2><h4 id="1-3-1信息安全保障体系框架"><a href="#1-3-1信息安全保障体系框架" class="headerlink" title="1.3.1信息安全保障体系框架"></a>1.3.1信息安全保障体系框架</h4><p>生命周期：规划组织，开发采购，实施交付，运行维护，废弃</p><p>保障要素：技术，管理，工程，人员</p><p>安全特征：机密性，完整性，可用性</p><h4 id="1-3-2信息系统安全模型与技术框架"><a href="#1-3-2信息系统安全模型与技术框架" class="headerlink" title="1.3.2信息系统安全模型与技术框架"></a>1.3.2信息系统安全模型与技术框架</h4><p>P2DR安全模型：策略（policy），防护，检测，响应；防护时间大于检测时间加上响应时间，安全目标暴露时间=检测时间+响应时间，越小越好；提高系统防护时间，降低检测时间和响应时间</p><p>信息保障技术框架（IATF）：纵深防御策略（）：人员，技术，操作；技术框架焦点域：保护本地计算机，保护区域边界，保护网络及基础设施，保护支撑性基础设施</p><h2 id="1-4信息安全保障基本实践"><a href="#1-4信息安全保障基本实践" class="headerlink" title="1.4信息安全保障基本实践"></a>1.4信息安全保障基本实践</h2><h4 id="1-4-1国内外信息安全保障工作概况"><a href="#1-4-1国内外信息安全保障工作概况" class="headerlink" title="1.4.1国内外信息安全保障工作概况"></a>1.4.1国内外信息安全保障工作概况</h4><h4 id="1-4-2信息安全保障工作的内容"><a href="#1-4-2信息安全保障工作的内容" class="headerlink" title="1.4.2信息安全保障工作的内容"></a>1.4.2信息安全保障工作的内容</h4><p>确定安全需求，设计和实施安全方案，进行信息安全评测，实施信息安全监控</p><hr><h2 id="第二章信息安全基础技术与原理"><a href="#第二章信息安全基础技术与原理" class="headerlink" title="第二章信息安全基础技术与原理"></a>第二章信息安全基础技术与原理</h2><h3 id="2-1密码技术"><a href="#2-1密码技术" class="headerlink" title="2.1密码技术"></a>2.1密码技术</h3><h4 id="2-1-1对称密码与非对称密码"><a href="#2-1-1对称密码与非对称密码" class="headerlink" title="2.1.1对称密码与非对称密码"></a>2.1.1对称密码与非对称密码</h4><p>对称密钥密码体制：发送方和接收方使用相同的密钥</p><p>非对称密钥密码体制：发送方和接收方使用不同的密钥</p><p>对称密钥体制：</p><p>加密处理速度快、保密度高，密钥管理分发复杂代价高、数字签名困难</p><p>分组密码：一次加密一个明文分组：DES，IDEA，AES；序列密码：一次加密一位或者一个字符：RC4，SEAL</p><p>加密方法：代换法：单表代换密码，多表代换；置换法</p><p>安全性：攻击密码体制：穷举攻击法（对于密钥长度128位以上的密钥空间不再有效），密码分析学；典型的密码攻击：唯密文攻击，已知明文攻击，选择明文攻击（加密算法一般要能够抵抗选择明文攻击才认为是最安全的，分析方法：差分分析和线性分析），选择密文攻击</p><p>基本运算：异或，加，减，乘，查表</p><p>设计思想：扩散，混淆；乘积迭代：乘积密码，常见的乘积密码是迭代密码，DES，AES</p><p>数据加密标准DES：基于Feistel网络，3DES，有效密钥位数：56</p><p>国际数据加密算法IDEA：利用128位密钥对64位的明文分组，经连续加密产生64位的密文分组</p><p>高级加密标准AES：SP网络</p><p>分组密码：电子密码本模式ECB，密码分组链模式CBC，密码反馈模式CFB，输出反馈模式OFB，计数模式CTF</p><p>非对称密码：</p><p>基于难解问题设计密码是非对称密码设计的主要思想，NP问题NPC问题</p><p>克服密钥分配上的困难、易于实现数字签名、安全性高，降低了加解密效率</p><p>RSA：基于大合数因式分解难得问题设计；既可用于加密，又可用于数字签名；目前应用最广泛</p><p>ElGamal：基于离散对数求解困难的问题设计</p><p>椭圆曲线密码ECC：基于椭圆曲线离散对数求解困难的问题设计</p><p>通常采用对称密码体制实现数字加密，公钥密码体制实现密钥管理的混合加密机制</p><h4 id="2-1-2哈希函数"><a href="#2-1-2哈希函数" class="headerlink" title="2.1.2哈希函数"></a>2.1.2哈希函数</h4><p>单向密码体制，从一个明文到密文的不可逆的映射，只有只有加密过程，没有解密过程</p><p>可将任意长度的输入经过变换后得到固定长度的输出（原消息的散列或消息摘要）</p><p>应用：消息认证（基于哈希函数的消息认证码），数字签名（对消息摘要进行数字签名口令的安全性，数据完整性）</p><p>消息摘要算法MD5：128位</p><p>安全散列算法SHA：160位</p><p>SHA比MD5更安全，SHA比MD5速度慢了25%，SHA操作步骤较MD5更简单</p><h4 id="2-1-3数字签名"><a href="#2-1-3数字签名" class="headerlink" title="2.1.3数字签名"></a>2.1.3数字签名</h4><p>通过密码技术实现，其安全性取决于密码体制的安全程度</p><p>普通数字签名：RSA，ElGamal，椭圆曲线数字签名算法等</p><p>特殊数字签名：盲签名，代理签名，群签名，不可否认签名，具有消息恢复功能得签名等</p><p>常对信息的摘要进行签名</p><p>美国数字签名标准DSS：签名算法DSA</p><p>应用：鉴权：重放攻击；完整性：同形攻击；不可抵赖</p><h4 id="2-1-4密钥管理"><a href="#2-1-4密钥管理" class="headerlink" title="2.1.4密钥管理"></a>2.1.4密钥管理</h4><p>包括密钥的生成，存储，分配，启用与停用，控制，更新，撤销与销毁等诸多方面密钥的分配与存储最为关键</p><p>借助加密，认证，签名，协议和公证等技术</p><p>密钥的秘密性，完整性，真实性</p><p>密钥产生：噪声源技术（基于力学，基于电子学，基于混沌理论的密钥产生技术）；主密钥，加密密钥，会话密钥的产生</p><p>密钥分配：</p><p>分配手段：人工分发（物理分发），密钥交换协议动态分发</p><p>密钥属性：秘密密钥分配，公开密钥分配</p><p>密钥分配技术：基于对称密码体制的密钥分配，基于公钥密码体制的密钥分配</p><p>密钥信息交换方式：人工密钥分发，给予中心密钥分发，基于认证密钥分发</p><p>人工密钥分发：主密钥</p><p>基于中心的密钥分发：利用公开密钥密码体制分配传统密码的密钥；可信第三方：密钥分发中心KDC，密钥转换中心KTC；拉模型，推模型；密钥交换协议：Diffie-Hellman算法</p><p>公开密钥分配：公共发布；公用目录；公约授权：公钥管理机构；公钥证书：证书管理机构CA，目前最流行</p><p>密钥存储：</p><p>公钥存储</p><p>私钥存储：用口令加密后存放在本地软盘或硬盘；存放在网络目录服务器中：私钥存储服务PKSS；智能卡存储；USB Key存储</p><h3 id="2-2认证技术"><a href="#2-2认证技术" class="headerlink" title="2.2认证技术"></a>2.2认证技术</h3><h4 id="2-2-1消息认证"><a href="#2-2-1消息认证" class="headerlink" title="2.2.1消息认证"></a>2.2.1消息认证</h4><p>产生认证码的函数：</p><p>消息加密：整个消息的密文作为认证码</p><p>消息认证码（MAC）：利用密钥对消息产生定长的值，并以该值作为认证码；基于DES的MAC算法</p><p>哈希函数：将任意长的消息映射为定长的哈希值，并以该哈希值作为认证码</p><h4 id="2-2-2身份认证"><a href="#2-2-2身份认证" class="headerlink" title="2.2.2身份认证"></a>2.2.2身份认证</h4><p>身份认证系统：认证服务器、认证系统客户端、认证设备</p><p>系统主要通过身份认证协议（单向认证协议和双向认证协议）和认证系统软硬件进行实现</p><p>认证手段：静态密码方式</p><p>动态口令认证：动态短信密码，动态口令牌（卡）</p><p>USB Key认证：挑战/应答模式，基于PKI体系的认证模式</p><p>生物识别技术</p><p>认证协议：基于口令的认证协议，基于对称密码的认证，基于公钥密码的认证</p><h3 id="2-3访问控制技术"><a href="#2-3访问控制技术" class="headerlink" title="2.3访问控制技术"></a>2.3访问控制技术</h3><p>访问控制模型：</p><p>自主访问控制（DAC）：访问矩阵模型：访问能力表（CL），访问控制表（ACL）；商业环境中，大多数系统，如主流操作系统、防火墙等</p><p>强制访问控制（DAC）：安全标签：具有偏序关系的等级分类标签，非等级分类标签，比较主体和客体的安全标签等级,，访问控制安全标签列表（ACSLL）；访问级别：最高秘密级，秘密级，机密级，无级别及；Bell-Lapadula模型：只允许向下读、向上写，保证数据的保密性，Biba不允许向下读、向上写，保护数据完整性；Chinese Wall模型：多边安全系统中的模型，包括了MAC和DAC的属性</p><p>基于角色的访问控制（RBAC）：要素：用户，角色，许可；面向企业，大型数据库的权限管理；用户不能自主的将访问权限授权给别的用户；MAC基于多级安全需求，RBAC不是</p><h3 id="2-3-2访问控制技术"><a href="#2-3-2访问控制技术" class="headerlink" title="2.3.2访问控制技术"></a>2.3.2访问控制技术</h3><p>集中访问控制：</p><p>认证、授权、审计管理（AAA管理）</p><p>拨号用户远程认证服务RADIUS：提供集中式AAA管理；客户端/服务器协议，运行在应用层，使用UDP协议；组合认证与授权服务</p><p>终端访问控制器访问控制系统TACACS：TACACS+使用TCP；更复杂的认证步骤；分隔认证、授权、审计</p><p>Diameter：协议的实现和RADIUS类似，采用TCP协议，支持分布式审计</p><p>非集中式访问控制：</p><p>单点登录SSO</p><p>Kerberos：使用最广泛的身份验证协议；引入可信的第三方。Kerberos验证服务器；能提供网络信息的保密性和完整性保障；支持双向的身份认证</p><p>SESAME：认证过程类似于Kerberos</p><h4 id="2-4审计和监控技术"><a href="#2-4审计和监控技术" class="headerlink" title="2.4审计和监控技术"></a>2.4审计和监控技术</h4><h4 id="2-4-1审计和监控基础"><a href="#2-4-1审计和监控基础" class="headerlink" title="2.4.1审计和监控基础"></a>2.4.1审计和监控基础</h4><p>审计系统：日志记录器：收集数据，系统调用Syslog收集数据；分析器：分析数据；通告器：通报结果</p><p>2.4.2审计和监控技术</p><p>恶意行为监控：主机监测：可监测的地址空间规模有限；网络监测：蜜罐技术（软件honeyd），蜜网（诱捕网络）：高交互蜜罐、低交互蜜罐、主机行为监视模块</p><p>网络信息内容审计：方法：网络舆情分析：舆情分析引擎、自动信息采集功能、数据清理功能；技术：网络信息内容获取技术（嗅探技术）、网络内容还原分析技术；模型：流水线模型、分段模型；不良信息内容监控方法：网址、网页内容、图片过滤技术</p><hr><h2 id="第三章系统安全"><a href="#第三章系统安全" class="headerlink" title="第三章系统安全"></a>第三章系统安全</h2><h3 id="3-1操作系统安全"><a href="#3-1操作系统安全" class="headerlink" title="3.1操作系统安全"></a>3.1操作系统安全</h3><h4 id="3-1-1操作系统安全基础"><a href="#3-1-1操作系统安全基础" class="headerlink" title="3.1.1操作系统安全基础"></a>3.1.1操作系统安全基础</h4><p>基本安全实现机制：</p><p>CPU模式和保护环：内核模式、用户模式</p><p>进程隔离：使用虚拟地址空间达到该目的</p><h4 id="3-1-2操作系统安全实践"><a href="#3-1-2操作系统安全实践" class="headerlink" title="3.1.2操作系统安全实践"></a>3.1.2操作系统安全实践</h4><p>UNIX/Linux系统：</p><p>文件系统安全：所有的事物都是文件：正规文件、目录、特殊文件（/dev下设备文件）、链接、Sockets；文件系统安全基于i节点中的三层关键信息：UID、GID、模式；模式位，权限位的八进制数表示；设置SUID（使普通用户完成一些普通用户权限不能完成的事而设置）和SGID，体现在所有者或同组用户权限的可执行位上；chmod改变文件权限设置、chown、chgrp；unmask创建文件默认权限</p><p>账号安全管理：/etc/passwd、/etc/shadow；伪用户账号；root账户管理：超级用户账户可不止一个，将UID和GID设置为0即可，使用可插入认证模块PAM进行认证登录</p><p>日志与审计：日志系统：记录连接时间的日志：/var/log/wtmp、/var/run/utmp，进程统计：pacct与acct，错误日志：/var/log/messages</p><p>Windows系统：</p><p>Windows安全子系统：winlogon和图形化标识和验证GINA、本地安全认证、安全支持提供者的接口（SSPI）、认证包、安全支持提供者、网络登录服务、安全账号管理器（SAM）</p><p>登录验证：Kerberos</p><p>用户权力与权限：用户权限：目录权限、文件权限；共享权限</p><p>日志与审计：系统日志、应用程序日志、安全日志</p><p>安全策略：密码策略；锁定策略；审核策略；用户全力指派；安全选项；装载自定义安全模板；windows加密文件系统</p><p>可信计算技术：</p><p>可信计算平台联盟（TCPA），可信计算组织（TCG）</p><p>可信PC，可新平台模块（TPM），可信软件栈（TSS），可信网络连接（TNC）</p><p>可信平台模块（TPM）：具有密码运算能力和存储能力，是一个含有密码运算部件和存储部件的小型片上系统；物理可信、管理可信的；</p><p>可信密码模块（TCM）：中国</p><p>可信计算平台：三个层次：可信平台模块（信任根）、可信软件栈、可信平台应用软件；我国：可信密码模块、可信密码模块服务模块、安全应用</p><p>可信网络连接（TNC）：开放性、安全性</p><h3 id="3-2数据库安全"><a href="#3-2数据库安全" class="headerlink" title="3.2数据库安全"></a>3.2数据库安全</h3><p>3.2.1数据库安全基础</p><p>统计数据库安全</p><p>现代数据库运行环境：多层体系结构，中间层完成对数据库访问的封装</p><p>数据库安全功能：</p><p>用户标识和鉴定</p><p>存取控制：自主存取控制：用户权限有两个要素组成：数据库对象和操作类型，GRANT语句向用户授予权限，REVOKE语句收回授予的权限，角色：权限的集合；强制存取控制：主体和客体，敏感度标记：许可证级别（主体）、密级（客体），首先要实现自主存取控制</p><p>审计：用户级审计、系统审计；AUDIT设置审计功能，NOAUDIT取消审计功能</p><p>数据加密</p><p>视图与数据保密性：将视图机制与授权机制结合起来使用，首先用视图机制屏蔽一部分保密数据，然后在视图上再进一步定义存取权限</p><p>数据完整性：</p><p>语义完整性，参照完整性，实体完整性</p><p>约束：优先于使用触发器、规则和默认值</p><p>默认值：CREATEDEFAULT</p><p>规则：CREATE RULE，USE EXEC sp_bindefault，DROP RULE</p><p>事务处理：BEGAIN</p><p>TRANSACTION，COMMIT，ROLLBACK；原子性、一致性、隔离性、持久性；自动处理事务、隐式事物、用户定义事物、分布式事务</p><p>3.2.2数据库安全实践</p><p>数据库十大威胁：</p><p>过度的特权滥用；合法的特权滥用；特权提升；平台漏洞；SQL注入；不健全的审计；拒绝服务；数据库通信协议漏洞；不健全的认证；备份数据库暴露</p><p>安全防护体系：事前检查，事中监控，事后审计</p><p>数据库安全特性检查：</p><p>端口扫描（服务发现）：对数据库开放端口进行扫描；渗透测试：黑盒式的安全监测，攻击性测试，对象是数据库的身份验证系统和服务监听系统，监听器安全特性分析、用户名和密码渗透、漏洞分析；内部安全监测：安全员数据、内部审计、安全配置检查、漏洞检测、版本补丁检测</p><p>数据库运行安全监控：网络嗅探器、数据库分析器、SQL分析器、安全审计</p><hr><h2 id="第四章网络安全"><a href="#第四章网络安全" class="headerlink" title="第四章网络安全"></a>第四章网络安全</h2><h3 id="4-1网络安全基础"><a href="#4-1网络安全基础" class="headerlink" title="4.1网络安全基础"></a>4.1网络安全基础</h3><h4 id="4-1-1TCP-IP体系架构"><a href="#4-1-1TCP-IP体系架构" class="headerlink" title="4.1.1TCP/IP体系架构"></a>4.1.1TCP/IP体系架构</h4><h4 id="4-1-2网络协议"><a href="#4-1-2网络协议" class="headerlink" title="4.1.2网络协议"></a>4.1.2网络协议</h4><p>数据链路层协议：地址解析协议（ARP），逆向地址解析协议（RARP）</p><p>网络层协议：IP协议， Internet控制报文协议（ICMP）：发送出错和控制消息，提供了一个错误侦测与回馈机制</p><p>传输层协议：TCP协议，UDP协议</p><p>应用层协议：HTTP，SMTP和POP3，DNS</p><h4 id="4-2网络安全威胁技术"><a href="#4-2网络安全威胁技术" class="headerlink" title="4.2网络安全威胁技术"></a>4.2网络安全威胁技术</h4><h4 id="4-2-1扫描技术"><a href="#4-2-1扫描技术" class="headerlink" title="4.2.1扫描技术"></a>4.2.1扫描技术</h4><p>互联网信息搜集</p><p>IP地址扫描：操作系统命令ping（网络故障诊断命令）、tracer，自动化的扫描工具Namp 、Superscan</p><p>端口扫描：Namp软件；TCP全连接扫描，TCP SYN扫描，TCP FIN扫描，UDP的ICMP端口不可达扫描，ICMP扫描；乱序扫描和慢速扫描</p><p>漏洞扫描：网络漏洞扫描：模拟攻击技术；主机漏洞扫描：漏洞特征匹配技术、补丁安装信息的检测</p><p>弱口令扫描：基于字典攻击的弱口令扫描技术、基因穷举攻击的弱口令扫描技术</p><p>综合漏洞扫描：Nessus</p><p>扫描防范技术：防火墙，用安全监测工具对扫描行为进行监测</p><h4 id="4-2-2网络嗅探"><a href="#4-2-2网络嗅探" class="headerlink" title="4.2.2网络嗅探"></a>4.2.2网络嗅探</h4><p>非主动类信息获取攻击技术</p><p>防范：实现对网络传输数据的加密，VPN、SSL、SSH等加密和传输的技术和设备，利用网络设备的物理或者逻辑隔离的手段</p><h4 id="4-2-3网络协议欺骗"><a href="#4-2-3网络协议欺骗" class="headerlink" title="4.2.3网络协议欺骗"></a>4.2.3网络协议欺骗</h4><p>IP地址欺骗：和其他攻击技术相结合</p><p>ARP欺骗：中间人欺骗（局域网环境内实施），伪装成网关欺骗（主要针对局域网内部主机与外网通信的情况）；防范：MAC地址与IP地址双向静态绑定</p><p>TCP欺骗：将外部计算机伪装成合法计算机；非盲攻击：网络嗅探，已知目标主机的初始序列号，盲攻击：攻击者和目标主机不在同一个网络上</p><p>DNS欺骗：基于DNS服务器的欺骗，基于用户计算机的DNS欺骗</p><h4 id="4-2-4诱骗式攻击"><a href="#4-2-4诱骗式攻击" class="headerlink" title="4.2.4诱骗式攻击"></a>4.2.4诱骗式攻击</h4><p>网站挂马：</p><p>攻击者成功入侵网站服务器，具有了网站中网页的修改权限</p><p>技术：框架挂马：直接加在框架代码和框架嵌套挂马；JS脚本挂马；b ody挂马；伪装欺骗挂马</p><p>防范：Web服务器，用户计算机</p><p>诱骗下载：</p><p>主要方式：多媒体类文件下载，网络游戏软件和插件下载，热门应用软件下载，电子书爱好者，P2P种子文件</p><p>文件捆绑技术：多文件捆绑方式，资源融合捆绑方式，漏洞利用捆绑方式</p><p>钓鱼网站</p><p>社会工程</p><h4 id="4-2-5软件漏洞攻击利用技术"><a href="#4-2-5软件漏洞攻击利用技术" class="headerlink" title="4.2.5软件漏洞攻击利用技术"></a>4.2.5软件漏洞攻击利用技术</h4><p>软件漏洞：操作系统服务程序漏洞，文件处理软件漏洞，浏览器软件漏洞，其他软件漏洞</p><p>软件漏洞攻击利用技术：直接网络攻击；诱骗式网络攻击：基于网站的诱骗式网络攻击，网络传播本地诱骗点击攻击</p><h4 id="4-2-6拒绝服务攻击"><a href="#4-2-6拒绝服务攻击" class="headerlink" title="4.2.6拒绝服务攻击"></a>4.2.6拒绝服务攻击</h4><p>实现方式：利用目标主机自身存在的拒绝服务性漏洞进行攻击，耗尽目标主机CPU和内存等计算机资源的攻击，耗尽目标主机网络带宽的攻击</p><p>分类：IP层协议的攻击：发送ICMP协议的请求数据包，Smurf攻击；TCP协议的攻击：利用TCP本身的缺陷实施的攻击，包括SYN-Flood和ACK-Flood攻击，使用伪造的源IP地址，利用TCP全连接发起的攻击，僵尸主机；UDP协议的攻击；应用层协议的攻击：脚本洪水攻击</p><p>分布式拒绝服务（DDos）：攻击者，主控端，代理端，僵尸网络</p><p>防范：支持DDos防御功能的防火墙</p><h4 id="4-2-7Web脚本攻击"><a href="#4-2-7Web脚本攻击" class="headerlink" title="4.2.7Web脚本攻击"></a>4.2.7Web脚本攻击</h4><p>针对Web服务器端应用系统的攻击技术：</p><p>注入攻击：SQL注入，代码注入，命令注入，LDAP注入，XPath注入；防范：遵循数据与代码分离的原则</p><p>访问控制攻击，非授权的认证和会话攻击</p><p>针对Web客户端的攻击技术：</p><p>跨站脚本攻击（XSS）：反射型XSS（非持久性的跨站脚本攻击），存储型XSS（持久型的跨站脚本攻击），DOM-based XSS（基于文档对象模型的跨站脚本攻击）：从效果上来说属于反射型XSS</p><p>跨站点请求伪造攻击（CSRF）：伪造客户顿请求；防范：使用验证码，在用户会话验证信息中添加随机数</p><p>点击劫持攻击</p><h4 id="4-2-8远程控制"><a href="#4-2-8远程控制" class="headerlink" title="4.2.8远程控制"></a>4.2.8远程控制</h4><p>木马：</p><p>具有远程控制、信息偷取、隐藏传输功能的恶意程序；通过诱骗的方式安装；一般没有病毒的的感染功能；特点：伪装性，隐藏性，窃密性，破坏性；</p><p>连接方式：C/S结构；最初的网络连接方法；反弹端口技术：服务器端主动的发起连接请求，客户端被动的等待连接；木马隐藏技术：线程插入技术、DLL动态劫持技术、RootKit（内核隐藏技术）</p><p>Wwbshell：用Web脚本写的木马后门，用于远程控制网站服务器；以ASP、PHP、ASPX、JSP等网页文件的形式存在；被网站管理员可利用进行网站管理、服务器管理等</p><h3 id="4-3网络安全防护技术"><a href="#4-3网络安全防护技术" class="headerlink" title="4.3网络安全防护技术"></a>4.3网络安全防护技术</h3><h4 id="4-3-1防火墙"><a href="#4-3-1防火墙" class="headerlink" title="4.3.1防火墙"></a>4.3.1防火墙</h4><p>一般部署在网络边界，也可部署在内网中某些需要重点防护的部门子网的网络边界</p><p>功能：在内外网之间进行数据过滤；对网络传输和访问的数据进行记录和审计；防范内外网之间的异常网络行为；通过配置NAT提高网络地址转换功能</p><p>分类：硬件防火墙：X86架构的防火墙（中小企业），ASIC、NP架构的防火墙（电信运营商）；软件防火墙（个人计算机防护）</p><p>防火墙技术：</p><p>包过滤技术：默认规则；主要在网络层和传输层进行过滤拦截，不能阻止应用层攻击，也不支持对用户的连接认证，不能防止IP地址欺骗</p><p>状态检测技术（动态包过滤技术）：增加了对数据包连接状态变化的额外考虑，有效阻止Dos攻击</p><p>地址翻译技术：静态NAT，NAT池，端口地址转换PAT</p><p>应用级网关（代理服务器）：在应用层对数据进行安全规则过滤</p><p>体系结构：</p><p>双重宿主主机体系结构：至少有两个网络接口，在双重宿主主机上运行多种代理服务器，有强大的身份认证系统</p><p>屏蔽主机体系结构：防火墙由一台包过滤路由器和一台堡垒主机组成，通过包过滤实现了网络层传输安全的同时，还通过代理服务器实现了应用层的安全</p><p>屏蔽子网体系结构：由两个包过滤路由器和一台堡垒主机组成；最安全，支持网络层、传输层、应用层的防护功能；添加了额外的保护体系，周边网络（非军事区，DMZ）通常放置堡垒主机和对外开放的应用服务器；堡垒主机运行应用级网关</p><p>防火墙的安全策略</p><h4 id="4-3-2入侵检测系统和入侵防御系统"><a href="#4-3-2入侵检测系统和入侵防御系统" class="headerlink" title="4.3.2入侵检测系统和入侵防御系统"></a>4.3.2入侵检测系统和入侵防御系统</h4><p>入侵检测系统（IDS）：</p><p>控制台：在内网中，探测器：连接交换机的网络端口</p><p>分类：根据数据采集方式：基于网络的入侵检测系统（NIDS）、基于主机的入侵检测系统（HIDS）；根据检测原理：误用检测型入侵检测系统、异常检测型入侵检测系统</p><p>技术：误用检测技术：专家系统、模型推理、状态转换分析；异常检测技术：统计分析、神经网络；其他入侵检测技术：模式匹配、文件完整性检验、数据挖掘、计算机免疫方法</p><p>体系结构：集中式结构：单一的中央控制台；分布式结构：建立树形分层结构</p><p>部署：一个控制台可以管理多个探测器，控制台可以分层部署，主动控制台和被动控制台</p><p>入侵防御系统（IPS）：</p><p>部署：网络设备：网络中需要保护的关键子网或者设备的网络入口处，控制台</p><p>不足：可能造成单点故障，可能造成性能瓶颈，漏报和无保的影响</p><h4 id="4-3-3PKI"><a href="#4-3-3PKI" class="headerlink" title="4.3.3PKI"></a>4.3.3PKI</h4><p>公共密钥基础设施是创建、管理、存储、分布和作废数字证书的一场系列软件、硬件、人员、策略和过程的集合</p><p>组成：数字证书是PKI的核心；安全策略；证书认证机构（CA）；证书注册机构；证书分发机构；基于PKI的应用接口</p><p>数字证书</p><p>信任模式：单证书认证机构信任模式，层次信任模型，桥证书认证机构信任模型</p><h4 id="4-3-4VPN"><a href="#4-3-4VPN" class="headerlink" title="4.3.4VPN"></a>4.3.4VPN</h4><p>利用开放的物理链路和专用的安全协议实现逻辑上网络安全连接的技术</p><p>网络连接类型：远程访问型VPN（Client-LAN）客户机和服务器都安装VPN软件；网络到网关类型的VPN（LAN-LAN）客户端和服务器各自在自己的网络边界部署硬件VPN网关设备</p><p>VPN协议分类：网络隧道技术</p><p>第二层隧道协：封装数据链路层数据包；介于二、三层之间的隧道协议；第三层隧道协议IPSec，通用路由封装协议（GRE）；传输层的SSL VPN协议：SSL协议工作在TCP/IP和应用层之间</p><h4 id="4-3-5网络安全协议"><a href="#4-3-5网络安全协议" class="headerlink" title="4.3.5网络安全协议"></a>4.3.5网络安全协议</h4><p>Internet安全协议（IPSec）：引入加密算法、数据完整性验证和身份认证；网络安全协议：认证协议头（AH）、安全载荷封装（ESP，传输模式、隧道模式），密钥协商协议：互联网密钥交换协议（IKE）</p><p>传输层安全协议（SSL）：解决点到点数据安全传输和传输双方身份认证的网络安全传输协议；记录协议和握手协议</p><p>应用层安全协议：</p><p>Kerberos协议；SSH协议：加密所有传输的数据，能防止DNS欺骗和IP欺骗；安全超文本传输协议（SHTTP）；安全多用途网际邮件扩充协议（S/MIME）；安全电子交易协议（SET）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;考试大纲&quot;&gt;&lt;a href=&quot;#考试大纲&quot; class=&quot;headerlink&quot; title=&quot;考试大纲&quot;&gt;&lt;/a&gt;考试大纲&lt;/h1&gt;&lt;h2 id=&quot;基本要求&quot;&gt;&lt;a href=&quot;#基本要求&quot; class=&quot;headerlink&quot; title=&quot;　　基本要求&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="信息安全技术" scheme="https://smallpotatody.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="计算机三级" scheme="https://smallpotatody.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%89%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>javaScript</title>
    <link href="https://smallpotatody.github.io/2019/06/03/JavaScript/"/>
    <id>https://smallpotatody.github.io/2019/06/03/JavaScript/</id>
    <published>2019-06-03T01:04:06.000Z</published>
    <updated>2019-06-08T02:33:10.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h1><h2 id="1-JavaScript简介"><a href="#1-JavaScript简介" class="headerlink" title="1. JavaScript简介"></a>1. JavaScript简介</h2><blockquote><p>JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在<a href="https://baike.baidu.com/item/HTML" target="_blank" rel="noopener">HTML</a>（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。</p></blockquote><p>Javascript包含了三个部分：ECMAScript、DOM和BOM</p><h2 id="2-如何使用JavaScript"><a href="#2-如何使用JavaScript" class="headerlink" title="2. 如何使用JavaScript"></a>2. 如何使用JavaScript</h2><p>通过<code>&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code>中直接编写</p><p>通过<code>&lt;script type=&quot;text/javascript&quot; src=&#39;目标文档的url&#39;&gt;&lt;/script&gt;</code>链接外部的Js文件，一旦应用了外部文件，就不能编写代码了，即使编写了，浏览器也会忽略。</p><p>作为某个元素的事件属性值或者是超链接的href属性值</p><p><img src="/2019/06/03/JavaScript/1.png" alt></p><h2 id="3-代码屏蔽"><a href="#3-代码屏蔽" class="headerlink" title="3. 代码屏蔽"></a>3. 代码屏蔽</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">Js代码</span><br><span class="line">//--&gt;</span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure><p>如果浏览器不支持Js，可以使用<code>&lt;noscript&gt;&lt;/noscript&gt;</code>标签，显示noscript中的内容</p><h2 id="4-Javascript的基本语法"><a href="#4-Javascript的基本语法" class="headerlink" title="4. Javascript的基本语法"></a>4. Javascript的基本语法</h2><ul><li>Javascript的执行顺序：按照在html文件中的顺序依次执行</li><li>大小写敏感：Javascript严格区分大小写</li><li>忽略空白符和换行符</li><li><p>语句分隔符：</p><ul><li>使用<code>;</code>结束语句,可以把多个语句写在一行，最后一个语句的分号可以省略，但尽量不要省略，可以使用{}括成一个语句组，形成一个块block</li></ul></li><li><p>通过\对代码进行拆行操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.write(&apos;hello\</span><br><span class="line">world&apos;);</span><br></pre></td></tr></table></figure></li><li><p>注释：</p><p>单行注释 <code>//</code></p><p>多行注释 <code>/*注释内容*/</code> </p></li><li><p>保留字</p></li><li>通过<code>document.write()</code>向文档书写内容</li><li>通过<code>console.log()</code>向控制台写入内容</li><li>Javascript中的错误<ul><li>语法错误：通过控制台进行调试</li><li>逻辑错误：通过alert()进行调试</li></ul></li></ul><h2 id="5-标识符"><a href="#5-标识符" class="headerlink" title="5. 标识符"></a>5. 标识符</h2><ul><li>在JS中所有的可以由我们自主命名的都可以成为标识符。</li><li>规则：<ol><li>标识符中可以含有字母、数字、_、$</li><li>标识符不能以数字开头</li><li>标识符不能是ES中的关键字或保留字</li><li>标识符一般都采用驼峰命名法</li></ol></li></ul><h1 id="数据类型与变量"><a href="#数据类型与变量" class="headerlink" title="数据类型与变量"></a>数据类型与变量</h1><h2 id="1-原始数据类型"><a href="#1-原始数据类型" class="headerlink" title="1. 原始数据类型"></a>1. 原始数据类型</h2><ul><li><p>数值型</p><ul><li><p>十进制数</p></li><li><p>十六进制数</p></li><li><p>八进制数</p></li><li><p>特殊值</p><p>Infinity无穷大</p><p>NaN ：可以通过isNaN()检测值是否为NaN</p></li></ul></li><li><p>字符串型</p><p>定界符：<code>&quot;&quot;或&#39;&#39;</code></p><p>转义符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\n回车换行</span><br><span class="line">\r换行</span><br><span class="line">\t水平制表符</span><br><span class="line">\&quot;&quot;</span><br><span class="line">\&apos;&apos;</span><br><span class="line">\\\</span><br></pre></td></tr></table></figure></li><li><p>布尔值型</p><p>true | false 只有小写才是</p><p><img src="/2019/06/03/JavaScript/3.png" alt></p></li></ul><h2 id="2-复合数据类型"><a href="#2-复合数据类型" class="headerlink" title="2. 复合数据类型"></a>2. 复合数据类型</h2><ul><li>对象(object)</li><li>数组(array)</li><li>函数(function)</li></ul><h2 id="3-特殊数据类型"><a href="#3-特殊数据类型" class="headerlink" title="3. 特殊数据类型"></a>3. 特殊数据类型</h2><ul><li>无定义数据类型undefined</li><li>空值null</li></ul><p>在JS中一共有六种数据类型</p><ul><li>String-&gt;字符串</li><li>Number-&gt;数值</li><li>Boolean-&gt;布尔值</li><li>Null-&gt;空值</li><li>Undefined-&gt;未定义</li><li>Object-&gt;对象</li></ul><h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><ol><li><p>声明变量</p><p>通过<code>var</code>关键字声明变量，可以声明变量的同时给变量赋值，可以一次声明一个变量也可以一次声明多个变量，如果只声明变量未对其赋值，默认值为<code>undefined</code>，如果变量重名会产生覆盖。</p><p><strong>注意：</strong>变量严格区分大小写，变量名称不要包含特殊字符，变量名称最好遵循驼峰标记法或下划线法，。变量名称最好含义明确。</p></li><li><p>变量在内存中的储存与释放</p><ul><li>收集方式</li><li>收集内容</li><li>回收算法</li></ul></li></ol><p><img src="/2019/06/03/JavaScript/2.png" alt></p><h2 id="5-类型转换"><a href="#5-类型转换" class="headerlink" title="5. 类型转换"></a>5. 类型转换</h2><ul><li><p>隐式转换</p><ul><li><p>转换成布尔类型假</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">underfined-&gt;false</span><br><span class="line">null  -&gt;false</span><br><span class="line">数值型0或0.0或NaN-&gt;false</span><br><span class="line">字符串长度0-&gt;false</span><br><span class="line">其它对象-&gt;true</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>转换为数值型数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">undefined-NaN</span><br><span class="line">null-&gt;0</span><br><span class="line">true-&gt;1</span><br><span class="line">false-&gt;0</span><br><span class="line">内容为数字-&gt;数字，否则转换成NaN</span><br><span class="line">其它对象-&gt;NaN</span><br></pre></td></tr></table></figure></li><li><p>转换为字符串型数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">undefined-&gt;&quot;undefined&quot;</span><br><span class="line">null-&gt;&quot;null&quot;</span><br><span class="line">true-&gt;&quot;true&quot;</span><br><span class="line">false-&gt;&quot;false&quot;</span><br><span class="line">数值型-&gt;NaN、0或者与数值对应的字符串</span><br><span class="line">其它对象-&gt;如果存在这个对象则转换为toString()方法的值，否则转换为Undefined</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>显示转换</p><ul><li><p>转换成数值</p><ul><li><p>Number函数强制转换成数值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数值-&gt;转换成原来的的值</span><br><span class="line"></span><br><span class="line">字符串-&gt;如果可以解析为数值，则转换成数值，否则转换成NaN或者0</span><br><span class="line"></span><br><span class="line">true-&gt;1,false-&gt;0</span><br><span class="line"></span><br><span class="line">undefined-&gt;NaN</span><br><span class="line"></span><br><span class="line">null-&gt;0</span><br></pre></td></tr></table></figure></li><li><p>转换成整形</p><p><code>parseInt(string,radix);返回转换成浮点型的值</code></p><p>当参数radix的值为0，或者没有设置这个参数，parseInt()会根据string来判断数字的基数。</p><p>当忽略radix，Javascript默认数字的基数规则为：</p><p>​    如果string以0开头，parseInt()会把string其余部分解析为十六进制的整数转化为十进制</p><p>​    如果string以0开头，那么ECMAScript v3允许parseInt()的一个实现把其后的字符解析为八进制或十六进制的数</p><p>​    如果string以1~9的数字开头，parseInt()将把他解析为十进制的整数</p><p>​    字符串如果以合法字符开始，截取合法字符</p><p>​    开头和结尾的空格是允许的</p><p>​    如果字符串的第一个字符不能被转换为数字，parseInt()会返回NaN</p><p>​    在字符串以”0”为开始时旧的浏览器默认使用八进制基数。ECMAScript 5，默认的是十进制的基数</p></li><li><p>转换成浮点型</p><p><code>parseFloat(string);返回转换成浮点型的值</code></p><p>该函数指定字符串的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。</p></li></ul><p><strong>注意：</strong>Number函数将字符串转换为数值比parseInt函数严格很多。基本上只要有一个字符无法转换成数值，整个字符串就会被转换成NaN。</p></li></ul><ul><li><p>转换成字符串</p><ul><li><p>通过String函数转换成字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数值-&gt;数值本身</span><br><span class="line">字符串-&gt;字符串本身</span><br><span class="line">true-&gt;&quot;true&quot;</span><br><span class="line">false-&gt;&quot;false&quot;</span><br><span class="line">undefined-&gt;&quot;undefined&quot;</span><br><span class="line">null-&gt;&quot;null&quot;</span><br></pre></td></tr></table></figure></li><li><p>转换成字符串型<code>toString()</code></p></li><li><p>转换成布尔类型</p><p>通过Boolean函数强制转换成布尔值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0、-0、0.0-&gt;false</span><br><span class="line">NaN-&gt;false</span><br><span class="line">空字符串-&gt;false</span><br><span class="line">undefined-&gt;false</span><br><span class="line">null-&gt;false</span><br></pre></td></tr></table></figure><p><img src="/2019/06/03/JavaScript/4.png" alt></p></li></ul></li></ul></li></ul><h1 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h1><h2 id="1-表达式"><a href="#1-表达式" class="headerlink" title="1. 表达式"></a>1. 表达式</h2><p>表达式是用于Javascript脚本运行时进行计算的式子，可以包含常量、变量、运算符。</p><h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h2><ul><li><p>算术运算符</p><p><code>+、-、*、/、%、++、--</code></p><p><strong>注意：</strong><code>+</code>号用来连接两个字符串。只要+连接的操作数中有一个是字符串类型，JS就会自动把非字符串型数据作为字符串型数据来处理。JS代码的执行顺序是从左到右，所有在+连接的表达式中，遇到字符串型数据之前，所有出现的数值型数据（或者可以自动转换为数值型的数据）仍被作为数值来处理。为了避免这种情况，我们可以在表达式前拼一个空字符串。</p><p><img src="/2019/06/03/JavaScript/5.png" alt></p></li><li><p>字符连接符</p><p>通过<code>+</code>连接字符串</p></li><li><p>赋值运算符</p><p><code>=、+=、-=、*=、/=、%=</code></p></li><li><p>比较运算符</p><p><code>&gt;、&gt;=、&lt;、&lt;=、==、!=、===、!==</code></p></li></ul><p><strong>注意：</strong>比较运算符的结果为布尔类型。<code>==</code>只比较值是否相等、<code>===</code>比较值和类型。</p><ul><li><p>逻辑运算符</p><p><code>&amp;&amp;、||、！</code></p></li></ul><p><strong>注意：</strong>逻辑运算符的结果为布尔类型，<code>&amp;&amp;</code>如果第一个表达式为false，造成短路，<code>||</code>如果第一个表达式为true，造成短路。</p><ul><li><p>三元运算符</p><p><code>exp1?exp2:exp3</code></p></li><li><p>其他运算符</p><ul><li><p>逗号运算符</p><p>逗号用来将多个表达式连接为一个个表达式，新表达式的值为最后一个表达式的值，多用在变量声明处</p></li><li><p>vold运算符</p><p>vold运算符用来指明一个表达式无返回结果</p></li><li><p>typeof运算符</p><p>typeof运算符用来返回同一个字符串，返回的是操作数的数据类型</p></li></ul></li></ul><h2 id="3-运算符的优先级"><a href="#3-运算符的优先级" class="headerlink" title="3. 运算符的优先级"></a>3. 运算符的优先级</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">•.、[]、 new</span><br><span class="line">•()</span><br><span class="line">•++、 --</span><br><span class="line">•!、~、+(单目)、-(单目)、typeof、void、delete</span><br><span class="line">•%、*、/</span><br><span class="line">•+(双目)、-(双目)</span><br><span class="line">•&lt;&lt; 、 &gt;&gt;、 &gt;&gt;&gt;</span><br><span class="line">•&lt;、&lt;=、&gt;、&gt;=</span><br><span class="line">•==、!==、===</span><br><span class="line">•&amp;</span><br><span class="line">•^</span><br><span class="line">•|</span><br><span class="line">•&amp;&amp;</span><br><span class="line">•||</span><br><span class="line">•?:</span><br><span class="line">•=、+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=、&amp;=、^=、|=</span><br><span class="line">•,</span><br></pre></td></tr></table></figure><p>通过()改变优先级</p><p><img src="/2019/06/03/JavaScript/6.png" alt></p><h2 id="4-流程控制"><a href="#4-流程控制" class="headerlink" title="4. 流程控制"></a>4. 流程控制</h2><ul><li><p>条件语句</p><p><code>if(exp)</code>执行一句代码</p><p><code>if(exp){执行代码段;}</code></p><p><code>if(exp){exp为true执行代码段}else{exp为false执行代码段;}</code></p><p><code>if...elseif...</code>与<code>switch...case</code></p><p><code>if</code>嵌套</p><p><img src="/2019/06/03/JavaScript/7.png" alt></p></li><li><p>循环语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for循环</span><br><span class="line">for(exp1;exp2;exp3)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>while循环</code></p><p><code>do...while循环</code></p></li><li><p>特殊循环控制</p><p><code>break终止循环</code></p><p><code>continue</code>跳过当次循环，进入下次循环</p></li></ul><p><img src="/2019/06/03/JavaScript/9.png" alt></p><p><img src="/2019/06/03/JavaScript/8.png" alt></p><p><img src="/2019/06/03/JavaScript/10.png" alt></p><p><img src="/2019/06/03/JavaScript/11.png" alt></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-什么是函数？"><a href="#1-什么是函数？" class="headerlink" title="1. 什么是函数？"></a>1. 什么是函数？</h2><p>函数是完成某一功能的代码段，函数是可重复执行的代码段，函数方便管理和维护。</p><h2 id="2-自定义函数"><a href="#2-自定义函数" class="headerlink" title="2. 自定义函数"></a>2. 自定义函数</h2><ul><li><p>通过<code>function</code>关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function 函数名称([参数,...])&#123;</span><br><span class="line">    代码段;</span><br><span class="line">    return 返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：函数名称不要包含特殊字符；函数名称最好含义精确；函数名称最好遵循驼峰标记法或者下划线法；函数名称严格区分大小写；函数名如果重复会产生覆盖；函数可以有参数也可以没有参数，可以有一个参数也可以有多个参数；函数通过return加返回值，如果没有return默认返回undefined；函数不调用不执行；</strong></p></li><li><p>匿名函数</p><p>函数表达式可以存储在变量中，变量也可以作为一个函数使用</p><p>可以将匿名函数作为参数传递给其它函数，接收方函数就可以通过所传递进来的函数完成某些功能</p><p>可以通过匿名函数来执行某些一次性的任务</p></li><li><p>通过Function()构造函数</p><p>通过内置Javascript函数构造器（Function()）定义；</p><p>​    <code>var myFunction</code></p></li></ul><h2 id="3-调用函数"><a href="#3-调用函数" class="headerlink" title="3. 调用函数"></a>3. 调用函数</h2><ul><li>作为一个函数调用</li></ul><p>通过函数名称()进行调用，如果有参数传递相应的参数即可</p><p>在HTML中默认的全局对象是HTML页面本省，所以函数是在属于HTML页面。在浏览器中的页面对象是浏览器窗口（window对象），所以函数会自动变为window对象的函数。也可以通过window.函数名称()进行调用</p><ul><li>全局对象</li></ul><p>当函数没有被自身的对象调用时，this的值就会变成全局对象。在web浏览器中全局对象是浏览器窗口window对象。</p><ul><li>函数作为方法调用</li></ul><p>可以将函数定义为对象的方法进行调用</p><ul><li>使用构造函数调用函数</li></ul><p>如果函数调用前使用了new关键字，则调用了构造函数</p><ul><li>作为回调函数调用函数</li></ul><p>call()、apply()</p><h2 id="4-参数"><a href="#4-参数" class="headerlink" title="4. 参数"></a>4. 参数</h2><p>函数可以有参数也可以没有参数，如果定义了参数，在调用函数的时侯没有传值，默认设置为undefined；在调用函数时如果传递参数超过了定义时参数，js会忽略掉多余参数；js中不能直接写默认值，可以通过arguments对象来实现默认值效果；可以通过arguments对象实现可变参数的函数；通过值传递参数在函数体内对变量做修改不会影响变量本身；通过对象传递参数在函数体内对变量做更改会影响变量本身；</p><p><img src="/2019/06/03/JavaScript/12.png" alt></p><h2 id="5-变量的作用域"><a href="#5-变量的作用域" class="headerlink" title="5. 变量的作用域"></a>5. 变量的作用域</h2><ul><li>局部变量</li></ul><p>在函数体内声明的变量，仅在函数体内可以使用</p><ul><li>全局变量</li></ul><p>函数体外声明的变量，在变量声明开始到脚本结束都可以使用</p><p><strong>注意：尽量控制全局变量的数量，容易引发BUG；最好总是使用var语句来声明变量</strong></p><h2 id="6-JavaScript全局函数"><a href="#6-JavaScript全局函数" class="headerlink" title="6. JavaScript全局函数"></a>6. JavaScript全局函数</h2><p><code>isFinite(value)</code>检测某个值是否是无穷值，如果number是NaN或者+Infinity或者-Infinity的数，isFinite()返回false。</p><p><code>isNaN(value)</code>检测某个值是否是NaN，isNaN()检测是否是非数值，如果值为NaN返回true，否则返回false。</p><p><code>encodeURI(uri)</code>将字符串编码为URI，函数是不会转义的，使用encodeURIComponent()方法分别对特殊含义的ASCII标点符号进行编码；<code>decodeURI(uri)</code>解码某个编码的URI；</p><p><code>encodeURIComponent(uri)</code>将字符串编码为URI组件;<code>decodeURIComponent(uri)</code>解码一个编码的URI组件；</p><p><code>escape()</code>对字符串进行编码；<code>unescape()</code>解码由<code>escape()</code>编码的字符串；</p><p><code>eval()</code>将Javascript字符串当作脚本来执行；注意：如果参数是一个表达式，eval()函数将执行表达式。如果参数是JavaScript语句，eval()将执行Javascript语句；eval()函数是一种由函数执行的动态代码，比直接执行脚本慢很多；慎重使用eval()函数，尽量不用，保证程序的安全性；</p><p><code>Number(object)</code>把对象的值转换位数字；注意：如果对象的值无法转换为数字，Number()函数返回NaN；如果参数是Date对象，Number()返回从1970年1月1日到现在所经历的毫秒数；</p><p><code>String()</code>把对象的值转换为字符串；String()函数返回与字符串对象的toString()方法一样；</p><p><img src="/2019/06/03/JavaScript/13.png" alt></p><h2 id="7-特殊形式的函数"><a href="#7-特殊形式的函数" class="headerlink" title="7. 特殊形式的函数"></a>7. 特殊形式的函数</h2><ul><li><p>函数也是数据</p><p>JavaScript中函数也是一种数据类型，只不过这种特殊类型有两个重要特性，即它们所包含的是代码、他们是可以执行的。</p></li><li><p>回调函数</p><p>回调函数的优势：</p><p>​    可以让我们在不做命名的情况下传递函数，这样可以节省全局变量；</p><p>​    我们可以将一个函数调用操作委托给另一个函数，这样就可以节省一些代码编写；</p><p>​    有助于提升性能；</p></li><li><p>自调函数</p><p>​    优势：使用自调匿名函数不会产生任何全局变量；</p><p>​    缺点：函数无法重复执行，适合执行一些一次性的或初始化的任务；</p></li><li><p>内部（私有）函数</p><p>​    优势：确保全局名字空间的纯净性，防止命名冲突；私有性之后我们就可以选择只将一些必要函数暴露给外部，并保留属于自己的函数，使其不被其他应用程序所调；</p></li><li><p>返回函数的函数</p><p><img src="/2019/06/03/JavaScript/14.png" alt></p></li><li><p>闭包</p><p>​    作用域链</p><p>​    词法作用域</p><p><strong>注意：闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中中可能导致内存泄露。尽量再退出函数之前，将不使用的局部变量全部删除；闭包会在父函数的外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包函数当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</strong></p></li></ul><hr><h1 id="Javascript中的对象"><a href="#Javascript中的对象" class="headerlink" title="Javascript中的对象"></a>Javascript中的对象</h1><h2 id="1-Javascript对象"><a href="#1-Javascript对象" class="headerlink" title="1. Javascript对象"></a>1. Javascript对象</h2><p>Javascript对象是基本数据类型之一，是复合类型；JavaScript中几乎所有事物都是对象；Javascript的对象是拥有属性和方法的数据。</p><p>Javascript中的对象可以简单理解成”名称:值”对(name:value)</p><p>​    JavaScript中的对象与这些概念类似：</p><p>​        Perl和Ruby中的散列（哈希）</p><p>​        C/C++中的散列表</p><p>​        Java中的HashMap</p><p>​        PHP中的关联数组</p><p>​    名称：“名称是一个Javascript字符串”；</p><p>​    注意：可以将属性名括在引号之间</p><p>​        这三种形式一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;prop:1&#125;</span><br><span class="line">var obj=&#123;&quot;prop&quot;:1&#125;</span><br><span class="line">var obj=&#123;&apos;prop&apos;:1&#125;</span><br></pre></td></tr></table></figure><p>​        必须放到引号之间：</p><p>​            如果属性名是Javascript的保留字之一</p><p>​            如果属性名包含各种特殊字符（除字母、数字、下划线以外的字符）</p><p>​            如果属性名以数字开头</p><p>​            在ECMAScript5中，保留字可以用做不带引号的属性名，但对于ECMAScript3中必须使用引号括起来</p><p>​            在ECMAScript5中对象直接量中的最后一个属性后的逗号将被忽略，在ECMAScript3的大部分实现中也可以忽略这个逗号，但在IE中报错。</p><h2 id="2-JavaScript中的对象分类"><a href="#2-JavaScript中的对象分类" class="headerlink" title="2. JavaScript中的对象分类"></a>2. JavaScript中的对象分类</h2><ul><li><p>内建对象</p><p>​    通过<code>var obj={}</code>对象字面量（object literal）法</p><p>​    通过<code>var obj=new Object()</code>创建</p><p>​    通过构造函数创建对象：</p><p>​        <code>function Person(){}</code></p><p>​        <code>var Person=function(){}</code></p><p>​        构造器属性(constructor property):</p><p>​            当我们创建对象的时候，实际上同时也赋予了该对象一种特殊的属性，就是构造器属性；这个构造器属性实际上是一个指向用于创建该对象的构造器函数的引用</p><p>​        通过instanceof操作符可以检测一个对象是否由某个指定的构造器函数创建的</p><p><strong>注意：使用的时候通过new操作符得到对象：<code>var person1=new Person()</code>；用构造器创建对象的时候可以接收参数；构造器函数的首字母最好大写，区别其他的一班函数</strong></p><p>​    通过Object.create创建对象</p></li><li><p>自定义对象</p></li></ul><h2 id="3-访问对象的属性和方法"><a href="#3-访问对象的属性和方法" class="headerlink" title="3. 访问对象的属性和方法"></a>3. 访问对象的属性和方法</h2><p>属性：</p><p>​    数据属性</p><p>​    访问属性</p><p>属性操作：</p><p>​    访问属性：</p><p>​        对象名.属性名</p><p>​        对象名[属性名]</p><p>​        当处于某个对象方法内部的时候，可以通过this来访问同一对象的属性</p><p>​    添加属性：</p><p>​        对象名</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript简介&quot;&gt;&lt;a href=&quot;#JavaScript简介&quot; class=&quot;headerlink&quot; title=&quot;JavaScript简介&quot;&gt;&lt;/a&gt;JavaScript简介&lt;/h1&gt;&lt;h2 id=&quot;1-JavaScript简介&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="前端" scheme="https://smallpotatody.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://smallpotatody.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://smallpotatody.github.io/2019/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://smallpotatody.github.io/2019/05/19/计算机网络/</id>
    <published>2019-05-19T14:12:25.000Z</published>
    <updated>2019-05-19T14:23:30.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="1-1-计算机网络在信息时代中的作用"><a href="#1-1-计算机网络在信息时代中的作用" class="headerlink" title="1.1 计算机网络在信息时代中的作用"></a>1.1 计算机网络在信息时代中的作用</h2><ul><li>21世纪的一些重要特征就是数字化、网络化和信息化，它是一个以网络为核心的信息时代。</li><li>网络是指“三网”，即电信网络、有线电视网络和计算机网络。</li></ul><p><strong>计算机网络向用户提供最重要的功能：</strong></p><ul><li>连通性——计算机网络使上网用户之间都可以交换信息。</li><li>共享——资源共享。</li></ul><h2 id="1-2-因特网概述"><a href="#1-2-因特网概述" class="headerlink" title="1.2 因特网概述"></a>1.2 因特网概述</h2><ul><li><p>网络(network)由若干结点(node)和连接这些结点的链路(link)组成。 </p><p>结点——用于计算机网络中，表示计算机或路由器。</p><p>链路——连接的线路。</p></li><li><p>互联网是“网络的网络”(network of networks)。</p></li><li><p>连接在因特网上的计算机都称为主机(host)。</p><p>internet——互连网（互联网）</p><p>Internet——当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，使用TCP/IP协议族作为通信规则。前身是美国的阿帕网APPRANET</p></li></ul><p><em>n起源于美国的因特网现已发展成为世界上最大的国际性计算机互联网</em></p><p><img src="/2019/05/19/计算机网络/1.png" alt></p><p><strong>因特网发展三个阶段</strong></p><ol><li>第一阶段——从单个网络ARPANET向互联网发展</li><li>第二阶段——逐步建成了三级结构的因特网</li><li>第三阶段——逐渐形成了多层次ISP结构的因特网</li></ol><p><strong>计算机网络、互联网、互连网</strong></p><ul><li>计算机网络：一些相互连接的计算机的集合。</li><li>互连网、互联网：一些相互连接的计算机网络的集合（网络的网络，互连网(互联网)由许多网络通过路由器互连而成）。</li></ul><h2 id="1-3-因特网的组成"><a href="#1-3-因特网的组成" class="headerlink" title="1.3  因特网的组成"></a>1.3  因特网的组成</h2><ul><li>边缘部分——由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</li><li>核心部分——由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。</li></ul><p><strong>两种通信方式</strong></p><ol><li><p>客户服务器方式（C/S 方式——Client/Server）</p><p>客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户是服务的请求方，服务器是服务的提供方。</p></li><li><p>对等方式（P2P 方式——Peer to Peer）</p></li></ol><p><strong>因特网核心部分</strong></p><ul><li>在网络核心部分起特殊作用的是路由器(router)。</li><li>路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。 </li></ul><p><strong>电路交换</strong></p><p>从通信资源的分配角度来看，“交换”就是按照某种方式动态地分配传输线路的资源。 </p><p>电路交换必定是面向连接的。 且利用率很低。</p><p>电路交换的三个阶段：</p><ul><li>建立连接</li><li>通信</li><li>释放连接</li></ul><p><strong>分组交换</strong>（存储转发）</p><p>报文：要发送的整块数据</p><p>分组：先将报文划分成较短的、固定长度的数据段，每一个数据段前面添加上首部构成分组或包。</p><p><img src="/2019/05/19/计算机网络/2.png" alt></p><p>每一个分组的首部都含有地址等控制信息。分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。用这样的存储转发方式，最后分组就能到达最终目的地。</p><p>因特网的核心部分是由许多网络和把它们互连起来的路由器组成，而主机处在因特网的边缘部分。在因特网核心部分的路由器之间一般都用高速链路相连接，而在网络边缘的主机接入到核心部分则通常以相对较低速率的链路相连接。主机的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器的用途则是用来转发分组的，即进行分组交换的。 </p><p><strong>分组交换优点</strong></p><ol><li>高效</li><li>灵活</li><li>迅速</li><li>可靠</li></ol><p>分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。无法确保通信时端到端所需的带宽，在通信量较大时可能造成网络拥塞。</p><p><img src="/2019/05/19/计算机网络/3.png" alt></p><h2 id="1-4计算机网络的的定义与分类"><a href="#1-4计算机网络的的定义与分类" class="headerlink" title="1.4计算机网络的的定义与分类"></a>1.4计算机网络的的定义与分类</h2><p><strong>最简单定义</strong>：计算机网络是一些互相连接、自治的计算机的集合。</p><p><strong>分类</strong>：</p><p>从网络的作用范围进行分类</p><ul><li>广域网 WAN (Wide Area Network)</li><li>局域网 LAN (Local Area Network) </li><li>城域网 MAN (Metropolitan Area Network)</li><li>个人区域网 PAN (Personal Area Network) </li></ul><p>从网络的使用者分类</p><ul><li>公用网（public network）</li><li>专用网（private network）</li></ul><h2 id="1-5计算机网络的主要性能指标"><a href="#1-5计算机网络的主要性能指标" class="headerlink" title="1.5计算机网络的主要性能指标"></a>1.5计算机网络的主要性能指标</h2><ol><li><p>速率</p><p>速率即数据率(data rate)或比特率(bit rate)是计算机网络中最重要的一个性能指标。速率的单位是b/s，或kb/s,Mb/s, Gb/s 等。</p></li><li><p>带宽</p><p>“带宽”(bandwidth)本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）。</p><p>现在“带宽”是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s)。</p></li><li><p>吞吐量</p><p>吞吐量/吞吐率(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。</p><p>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><p>受网络的带宽或网络的额定速率的限制。 </p></li><li><p>时延</p><p><img src="/2019/05/19/计算机网络/4.png" alt></p></li></ol><p><strong>对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率。提高链路带宽减小了数据的发送时延.</strong> </p><ol start="5"><li><p>丢包率</p><p>丢包率即分组丢失率，是指在一定的时间范围内，分组在传输过程中丢失的分组数量与总的分组数量的比率。</p><p>具体：接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。</p><p>在现代计算机网络中网络拥塞是丢包的主要原因。因此，丢包率往往反映了网络的拥塞情况。</p></li><li><p>利用率</p><p><strong>信道利用率</strong>指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。</p><p><strong>网络利用率</strong>则是全网络的信道利用率的加权平均值。</p><p>信道利用率并非越高越好。 </p><p>若令 <em>D</em>0 表示网络空闲时的时延，<em>D</em><br>表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示<em>D</em>和 <em>D</em>0之间的关系： </p></li></ol><p><img src="/2019/05/19/计算机网络/6.png" alt></p><p><img src="/2019/05/19/计算机网络/5.png" alt></p><h2 id="1-6计算机网络体系结构"><a href="#1-6计算机网络体系结构" class="headerlink" title="1.6计算机网络体系结构"></a>1.6计算机网络体系结构</h2><p>网络协议(network protocol)，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。 </p><p>三要素：语法，即数据与控制信息的结构或格式。</p><p>语义，即各个控制信息的具体含义，包括需要发出何种控制信息，完成何种动作以及做出何种响应。</p><p>同步（或时序），即事件实现顺序和时间的详细说明，包括数据应该在何时发送出去以及数据应该以什么速率发送。</p><p>计算机网络的体系结构(architecture)是计算机网络的各层及其协议的集合。l体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。   </p><p><img src="/2019/05/19/计算机网络/7.png" alt></p><p><strong>物理层</strong>: 如何在物理媒体上传送比特流</p><p><strong>数据链路层:</strong> 相邻节点间分组(帧)的传输</p><p>PPP, 以太网</p><p><strong>网络层:</strong> 如何将分组从源主机通过中间路由器传送到目的主机</p><p>IP, 选路协议</p><p><strong>运输层:</strong> 提供不同主机上应用程序间的数据传输服务</p><p>TCP, UDP</p><p><strong>应用层:</strong>如何通过应用进程间的交互来完成特定网络应用。</p><p>FTP, SMTP, STTP</p><p><img src="/2019/05/19/计算机网络/8.png" alt></p><p>实体(entity) 表示任何可发送或接收信息的硬件或软件进程。 </p><p>协议是控制两个对等实体进行通信的规则的集合。 </p><p>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。</p><p>要实现本层协议，还需要使用下层所提供的服务。 </p><p>本层的服务用户只能看见服务而无法看见下面的协议。</p><p>下面的协议对上面的服务用户是透明的。 </p><p>协议是“水平的”，即协议是控制对等实体之间通信的规则。</p><p>服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。</p><p><img src="/2019/05/19/计算机网络/9.png" alt></p><h2 id="1-7计算机网络在我国发展"><a href="#1-7计算机网络在我国发展" class="headerlink" title="1.7计算机网络在我国发展"></a>1.7计算机网络在我国发展</h2><p>1994年4月20日我国用64kbit/s专线正式连入因特网。</p><h2 id="1-8两个重要的新兴网络技术"><a href="#1-8两个重要的新兴网络技术" class="headerlink" title="1.8两个重要的新兴网络技术"></a>1.8两个重要的新兴网络技术</h2><p>云计算</p><ul><li>基础设施即服务</li><li>平台即服务</li><li>软件即服务</li></ul><p>物联网</p><ul><li>对象识别</li><li>环境监控和对象跟踪</li><li>对象的自能控制</li></ul><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="2-1物理层的基本概念"><a href="#2-1物理层的基本概念" class="headerlink" title="2.1物理层的基本概念"></a>2.1物理层的基本概念</h2><p>物理层协议的主要任务就是确定与传输媒体的接口的一些特性</p><ul><li>机械特性</li><li>电器特性</li><li>功能特性</li><li>规程特性</li></ul><h2 id="2-2数据通信的基础知识"><a href="#2-2数据通信的基础知识" class="headerlink" title="2.2数据通信的基础知识"></a>2.2数据通信的基础知识</h2><p><strong>数据通信系统：</strong></p><p>源系统：源点、发送器</p><p>传输系统</p><p>目的系统：接收器、终点</p><p><img src="/2019/05/19/计算机网络/10.png" alt></p><p>通信的目的是传送消息。数据是信息的实体。信号是数据的电气或电磁表现。</p><p>编码：将数字数据转换成数字信号的过程。</p><p><img src="/2019/05/19/计算机网络/11.png" alt></p><p>调制：将数字数据转换成模拟信号的过程。</p><p><img src="/2019/05/19/计算机网络/12.png" alt></p><p><strong>提高数据传输速率的途径</strong></p><p>要使用更好的传输媒体，使用先进的编码和调制技术，但不管采用好的传输媒体和怎样先进的调制技术，数据传输速率总是受限的，不可能任意地提高，否则就会出现较多的差错。</p><p><strong>传输方式</strong></p><p><img src="/2019/05/19/计算机网络/13.png" alt></p><h2 id="2-3物理层下面的传输媒体"><a href="#2-3物理层下面的传输媒体" class="headerlink" title="2.3物理层下面的传输媒体"></a>2.3物理层下面的传输媒体</h2><p><strong>导引型传输媒体</strong></p><ol><li><p>双绞线</p><p>屏蔽双绞线 STP(Shielded Twisted Pair)</p><p>无屏蔽双绞线 UTP (Unshielded Twisted Pair) </p></li><li><p>同轴电缆</p><p>50 W 同轴电缆</p><p>75 W 同轴电缆</p></li><li><p>光纤</p></li></ol><p><strong>非导引型传输媒体</strong></p><p>无线传输所使用的频段很广。</p><p>短波通信主要是靠电离层的反射，但短波信道的通信质量较差。</p><p>微波在空间主要是直线传播。 </p><p>地面微波接力通信</p><p>卫星通信  </p><h2 id="2-4信道复用技术"><a href="#2-4信道复用技术" class="headerlink" title="2.4信道复用技术"></a>2.4信道复用技术</h2><p><strong>复用</strong>：通过一条物理线路同时传输多路用户的信号</p><p>频分复用：所有用户在同样的时间占用不同的带宽资源。</p><p>时分复用：所有用户在不同的时间占用同样的频带宽度</p><p>统计时分复用：</p><p><img src="/2019/05/19/计算机网络/14.png" alt></p><h2 id="2-5数字传输系统"><a href="#2-5数字传输系统" class="headerlink" title="2.5数字传输系统"></a>2.5数字传输系统</h2><p>将模拟电话信号转换为数字信号目前采用的都是脉冲编码调制PCM (Pulse Code Modulation)技术，将一路模拟电话信号转换为64 kbit/s的PCM数字脉冲信号。</p><p>为了充分利用高速传输线路的带宽，通常将多路PCM信号用TDM方法汇集成时分复用帧，按某种固定的复用结构进行长途传输。</p><p>两个互不兼容的PCM复用速率标准：即北美体制和欧洲体制</p><p>早期的数字传输系统存在许多缺点。主要由<strong>速率标准不统一和不是同步传输</strong>。</p><p>传统SDH/SONET传输网络由光传输系统和交换结点的电子设备组成。</p><p>全光网AON (All Optical Network) 用光网络结点代替原来交换结点的电子设备，组成以端到端光通道为基础的全光传输网，避免因光/电转换所带来的带宽瓶颈，而路由器等电信号处理设备在边缘网络连接用户终端设备。</p><h2 id="2-6互连网接入技术"><a href="#2-6互连网接入技术" class="headerlink" title="2.6互连网接入技术"></a>2.6互连网接入技术</h2><p>接入：将端系统连接到边缘路由器。接入技术解决的就是最终用户接入本地ISP“最后一公里”的问题。通常，人们将端系统连接到ISP边缘路由器的物理链路及相关设备的集合称为接入网AN(access<br>network)。</p><ul><li><p>通过拨号调制解调器接入（非带宽接入）</p><p>–允许最高56Kbps接入速率(通常会更低)</p><p>–不能同时上网和打电话</p><p>–不提供持续连接</p></li><li><p>ADSL接入</p><p>上行和下行带宽做成不对称的。</p><p>上行指从用户到 ISP，而下行指从 ISP 到用户。</p><p>ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。</p><p>我国目前采用的方案是离散多音调 <strong>DMT</strong> (Discrete Multi-Tone)调制技术。这里的“多音调”就是“多载波”或“多子信道”的意思。</p></li><li><p>光纤接入</p></li><li><p>以太网接入</p></li><li><p>无线接入</p></li></ul><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="3-1使用点对点信道的数据链路层"><a href="#3-1使用点对点信道的数据链路层" class="headerlink" title="3.1使用点对点信道的数据链路层"></a>3.1使用点对点信道的数据链路层</h2><p><strong>信道类型：</strong></p><ul><li>点对点信道：这种信道使用一对一点对点通信方式。</li><li>广播信道：这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。</li></ul><p>链路(link)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</p><p>数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p><p><strong>封装成帧</strong></p><p>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。首部和尾部的一个重要作用就是进行帧定界。  </p><p><strong>透明传输</strong></p><p>字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</p><p><img src="/2019/05/19/计算机网络/15.png" alt>**</p><p>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 </p><p><img src="/2019/05/19/计算机网络/16.png" alt></p><p>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。</p><p><strong>循环冗余检验的原理</strong></p><p>循环冗余检验 CRC 和帧检验序列 FCS并不等同。CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。FCS 可以用CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 仅用循环冗余检验CRC差错检出技术只能做到无差错接受。</p><p><strong>可靠传输</strong></p><p>要做到“可靠传输”就必须用到确认和重传机制。<img src="/2019/05/19/计算机网络/17.png" alt></p><p><strong>停止等待协议</strong></p><p><img src="/2019/05/19/计算机网络/18.png" alt></p><p>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。这种可靠传输协议常称为自动重传请求ARQ(Automatic Repeat reQuest).ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。 </p><p>在发送完一个帧后，必须暂时保留已发送的帧的副本。数据帧和确认帧都必须进行编号。只要超过了一段时间还没有收到确认，就认为已发送的帧出错或丢失了，因而重传已发送过的帧。这就叫做超时重传。超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 </p><p>停止等待协议不适合发送时延小于往返时延的情况。优点是简单，缺点是信道利用率低。</p><p><strong>流水线传输</strong></p><p>发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。</p><h2 id="3-2点对点协议PPP"><a href="#3-2点对点协议PPP" class="headerlink" title="3.2点对点协议PPP"></a>3.2点对点协议PPP</h2><p>特点：</p><ul><li>简单</li><li>封装成帧</li><li>透明性</li><li>多种网络层协议</li><li>多种类型链路</li><li>差错检测</li><li><p>检测连接状态</p><p><strong>PPP协议组成</strong></p></li></ul><ol><li>一个将IP数据包封装到串行链路的方法。</li><li>链路控制协议LCP</li><li>网络控制协议NCP</li></ol><p><strong>PPP协议的帧格式</strong></p><p><img src="/2019/05/19/计算机网络/19.png" alt></p><p><strong>透明传输问题</strong></p><p>当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充（和 HDLC 的做法一样）。 当 PPP 用在异步传输时，就使用一种特殊的字符填充法。</p><p><strong>零比特填充</strong></p><p>在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现5 个连续1时，就把这 5 个连续 1 后的一个 0 删除，</p><h2 id="3-3使用广播信道的数据链路层"><a href="#3-3使用广播信道的数据链路层" class="headerlink" title="3.3使用广播信道的数据链路层"></a>3.3使用广播信道的数据链路层</h2><p>由于用广播信道连接的计算机共享同一传输媒体，因此使用广播信道的局域网被称为共享式局域网。虽然交换式局域网在有线领域已完全取代了共享式局域网，但无线局域网仍然使用的是共享媒体技术。</p><p><strong>媒体接入控制（MAC）</strong></p><ul><li>静态划分信道：频分多址、时分多址、码分多址</li><li>动态接入控制：<ul><li>随机接入</li><li>受控接入</li></ul></li></ul><p><strong>局域网</strong></p><p>网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p><strong>局域网的数据链路层的两个子层</strong>：</p><ul><li>逻辑链路控制 LLC (Logical Link Control)子层。（与传输媒体无关）。</li><li>媒体接入控制 MAC (Medium Access Control)子层。</li></ul><h2 id="3-4共享式以太网"><a href="#3-4共享式以太网" class="headerlink" title="3.4共享式以太网"></a>3.4共享式以太网</h2><p><strong>为了通信的简便以太网采取了两种重要的措施</strong></p><p>采用较为灵活的无连接的工作方式，即不必先建立连接就可以直接发送数据。 </p><p>以太网对发送的数据帧不进行编号，也不要求对方发回确认。</p><p>这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的。 </p><p><strong>以太网提供的服务</strong></p><p>以太网的服务是不可靠的交付，即尽最大努力的交付。当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。差错的纠正由高层来决定。如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。  </p><p><strong>载波监听多点接入/碰撞检测  CSMA/CD</strong> </p><p>最先发送数据帧的站，在发送数据帧后至多经过时间 2<em>t</em> （两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。</p><p>以太网的端到端往返时延 2<em>t</em> 称为争用期，或碰撞窗口。</p><p>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。   </p><p><img src="/2019/05/19/计算机网络/20.png" alt></p><p>使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。</p><p>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 </p><p>当连接很多站点时，以太网的平均吞吐量要比以太网的最高数据率小很多.</p><p><strong>以太网的MAC帧格式</strong></p><p><img src="/2019/05/19/计算机网络/21.png" alt></p><h2 id="3-5网络和以太网交换机"><a href="#3-5网络和以太网交换机" class="headerlink" title="3.5网络和以太网交换机"></a>3.5网络和以太网交换机</h2><p><strong>用集线器扩展以太网</strong></p><p>优点：使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。</p><p><strong>扩大了局域网覆盖的地理范围。</strong></p><p>缺点：碰撞域增大了，但总的吞吐量并未提高。</p><p>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。  </p><p>由于争用期的限制，并不能无限扩大地理覆盖范围</p><p><strong>在数据链路层扩展以太网</strong></p><p>使用网桥。网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的<br>MAC 地址，然后再确定将该帧转发到哪一个接口。</p><p><strong>使用网桥优点</strong></p><p>过滤通信量</p><p>扩大了物理范围</p><p>提高了可靠性</p><p>可互连不同物理层、不同MAC子层和不同速率的局域网。</p><p><strong>使用网桥缺点</strong></p><p>存储转发增加了时延。 </p><p>在MAC 子层并没有流量控制功能。 </p><p>具有不同 MAC 子层的网段桥接在一起时时延更大。</p><p>网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。  </p><p>集线器在转发帧时，不对传输媒体进行检测。</p><p>网桥在转发帧之前必须执行 CSMA/CD 算法。</p><p>若在发送过程中出现碰撞，就必须停止发送和进行退避。</p><p>透明网桥是一种即插即用设备。</p><p><strong>网桥在转发表中登记以下三个信息</strong></p><p>在网桥的转发表中写入的信息除了<strong>地址</strong>和<strong>接口</strong>外，还有<strong>帧进入该网桥的时间</strong>。</p><p><strong>虚拟局域网</strong></p><p>虚拟局域网其实只是局域网给用户提供的一种服务，而不是一种新型局域网！</p><p>简化网络管理。</p><p>控制广播风暴。</p><p>增强网络的安全性。</p><h2 id="3-6以太网的演进"><a href="#3-6以太网的演进" class="headerlink" title="3.6以太网的演进"></a>3.6以太网的演进</h2><p>速率达到或超过 100 Mb/s 的以太网称为高速以太网。</p><h2 id="3-7无线局域网"><a href="#3-7无线局域网" class="headerlink" title="3.7无线局域网"></a>3.7无线局域网</h2><p><strong>有固定基础设施的无线局域网</strong></p><p>一个移动站若要加入到一个基本服务集 BSS，就必须先选择一个接入点 AP，并与此接入点建立关联。</p><p><strong>移动站与AP建立关联的方法</strong></p><p>被动扫描，即移动站等待接收接入站周期性发出的信标帧(beacon frame)。</p><p>主动扫描，即移动站主动发出探测请求帧(probe request frame)，然后等待从 AP 发回的探测响应帧(probe response frame)。</p><p><strong>使用CSMA/CA协议</strong></p><p>无线局域网不能使用CSMA/CD，而只能使用改进的CSMA协议。改进办法就是把CSMA增加一个碰撞避免功能。</p><p>无线局域网不能简单地搬用 CSMA/CD 协议。这里主要有两个原因。</p><p>对于无线信道，接收信号强度往往会远远小于发送信号强度。如要在无线局域网的适配器上实现碰撞检测，对硬件的要求非常高。。</p><p>即使我们能够实现碰撞检测的功能，并且当我们在发送数据时检测到信道是空闲的，在接收端仍然有可能发生碰撞（隐蔽站问题）。</p><p><img src="/2019/05/19/计算机网络/22.png" alt></p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="4-1网络层概述"><a href="#4-1网络层概述" class="headerlink" title="4.1网络层概述"></a>4.1网络层概述</h2><p><strong>分组转发和路由选择（转发表）</strong></p><p>电信网的成功经验让网络负责可靠交付</p><p><strong>虚电路服务</strong></p><p>面向连接，建立虚电路，使用可靠传输协议(虚电路是逻辑上的连接)</p><p><img src="/2019/05/19/计算机网络/23.png" alt></p><p><strong>因特网采用设计思路</strong></p><p>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。</p><p>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</p><p>网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。 </p><p><strong>数据报服务</strong></p><p><img src="/2019/05/19/计算机网络/24.png" alt></p><p><img src="/2019/05/19/计算机网络/25.png" alt></p><p><strong>虚电路转发表</strong></p><p>每台中间路由器在转发分组时必须用一个新的VC号替代原来的VC号。</p><h2 id="4-2网际协议IP"><a href="#4-2网际协议IP" class="headerlink" title="4.2网际协议IP"></a>4.2网际协议IP</h2><p><strong>网际层协议IP</strong></p><ul><li>地址解析协议ARP</li><li>逆地址解析协议RARP</li><li>网际控制报文协议ICMP</li><li>网际组管理协议IGMP</li></ul><p><img src="/2019/05/19/计算机网络/26.png" alt></p><p><strong>中间设备</strong></p><p>物理层：转发器</p><p>数据链路层：网桥或桥接器</p><p>网络层：路由器</p><p>网络层以上：网关</p><p><strong>虚拟互连网</strong></p><p>所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。   </p><p><strong>IP地址及编址方式</strong></p><p>点分十进制记法：32位二进制代码，每8位插入一个空格，转换成十进制，提高可读性。</p><ol><li><p>分类编址</p><p>IP地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}      ::=代表“定义为”</p><p><img src="/2019/05/19/计算机网络/27.png" alt></p><p>IP地址的使用范围</p><p>| 网络类别 | 最大网络数          | 第一个可用的网络号 | 最后一个可用的网络号 | 每个网络中最大的主机数 |<br>| ——– | ——————- | —————— | ——————– | ———————- |<br>| A        | 126（2^7-2）        | 1                  | 126                  | 16777214               |<br>| B        | 16383(2^14-1)       | 128.1              | 191.255              | 65534                  |<br>| C        | 2,097,151 (221 - 1) | 192.0.1            | 223.255.255          | 254                    |</p></li><li><p>划分子网</p><p>三级的IP地址</p><p>IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}       </p></li><li><p>无分类编址CIDR</p><p>IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}           </p></li></ol><p>在分类编址中，给定一个IP地址，就确定了它的网络号和主机号。但在无分类编址中，由于网络前缀是不定长，IP地址本身并不能确定其网络前缀和主机号。</p><p>使用子网掩码(subnet mask)可以找出 IP 地址中的网络部分(网络前缀)。</p><p>CIDR 还使用“斜线记法” ，它又称为CIDR记法，即在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数。</p><p><strong>地址解析协议ARP</strong></p><p>IP地址——&gt;ARP——&gt;物理地址</p><p>物理地址——&gt;RARP——&gt;IP地址</p><p>IP数据报由首部和数据两部分组成，首部前一部分是固定长度，共20字节，是所有IP数据报必须具有的。</p><p><strong>IP数据报分片</strong></p><p><img src="/2019/05/19/计算机网络/28.png" alt></p><h2 id="4-3网际控制报文协议ICMP"><a href="#4-3网际控制报文协议ICMP" class="headerlink" title="4.3网际控制报文协议ICMP"></a>4.3网际控制报文协议ICMP</h2><p>ICMP 不是高层协议，而是 IP 层的协议。</p><p>ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。  </p><p>前四个字节是统一的三个字段：类型、代码、检验和</p><p><strong>ICMP报文的种类</strong> </p><ul><li>差错报告报文</li><li>ICMP询问报文</li></ul><p><strong>PING</strong></p><p>PING用来测试两个主机之间的连通性</p><p>PING 使用了 ICMP 回送请求与回送回答报文。</p><p>PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或UDP。 </p><h2 id="4-4因特网的路由选择协议"><a href="#4-4因特网的路由选择协议" class="headerlink" title="4.4因特网的路由选择协议"></a>4.4因特网的路由选择协议</h2><p>静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。</p><p>动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。  </p><p>分层次的路由选择协议</p><p><strong>自治系统AS</strong></p><p>自治系统 AS 的定义：在单一的技术管理下的一组路由器，而这些路由器使用一种AS 内部的路由选择协议和共同的度量以确定分组在该AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在AS之间的路由。</p><p><strong>因特网两大路由选择协议</strong></p><p>内部网关协议IGP</p><p>RIP三个要点：</p><p>​    仅和相邻路由器交换信息。 </p><p>​    交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 </p><p>​    按固定的时间间隔交换路由信息，例如，每隔 30 秒。</p><p>OSPF三个要点：</p><p>​    向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。</p><p>​    发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。 </p><p>​    只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。  </p><p>外部网关协议EGP</p><p><strong>划分区域</strong></p><p>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。</p><h2 id="4-5路由器的工作原理"><a href="#4-5路由器的工作原理" class="headerlink" title="4.5路由器的工作原理"></a>4.5路由器的工作原理</h2><p><strong>转发和路由选择的区别</strong></p><p>“转发”(forwarding)就是路由器根据转发表将用户的 IP 数据报从合适的端口转发出去。</p><p>“路由选择”(routing)则是按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由。</p><p>路由表是根据路由选择算法得出的。而转发表是从路由表得出的。</p><p>在讨论路由选择的原理时，往往不去区分转发表和路由表的区别。</p><p>由输入端口、变换结构、输出端口</p><p><strong>交换机与路由器的比较</strong></p><p>交换机的优点是即插即用，并具有相对高的分组过滤和转发速度。缺点是：大型交换机网络要求交换机维护大的转发表，主机中维护大的ARP表，并可能产生广播风暴，逻辑拓扑被限制为树。</p><p>路由器的优点是能提供更加智能的路由选择，并能隔离广播域。缺点是：路由器不是即插即用的，对每个分组处理时间通常比交换机更长。</p><h2 id="4-6VPN与NAT"><a href="#4-6VPN与NAT" class="headerlink" title="4.6VPN与NAT"></a>4.6VPN与NAT</h2><p>用隧道技术实现虚拟专用网</p><h2 id="4-7IP多播"><a href="#4-7IP多播" class="headerlink" title="4.7IP多播"></a>4.7IP多播</h2><p><strong>IP多播的一些特点</strong></p><p>​    多播使用组地址—— IP 使用 D 类地址支持多播。多播地址只能用于目的地址，而不能用于源地址。  </p><p>​    永久组地址——由因特网号码指派管理局 IANA 负责指派。</p><p>​    动态的组成员 </p><pre><code>利用局域网的硬件多播</code></pre><p><strong>IP多播需要两种协议</strong></p><p>网际组管理协议IGMP</p><p>​    IGMP 并非在因特网范围内对所有多播组成员进行管理的协议。</p><p>​    IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上。</p><p>​    IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。 </p><p>多播路由器选择协议</p><p>​    多播转发必须动态地适应多播组成员的变化（这时网络拓扑并未发生变化）。请注意，单播路由选择通常是在网络拓扑发生变化时才需要更新路由。</p><p>​    多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，而是还要考虑这个多播数据报从什么地方来和要到什么地方去。 </p><p>​    多播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络。 </p><h2 id="4-9下一代的网际协议IPV6"><a href="#4-9下一代的网际协议IPV6" class="headerlink" title="4.9下一代的网际协议IPV6"></a>4.9下一代的网际协议IPV6</h2><p><strong>IPV6引进的主要变化</strong></p><p>IPv6 仍支持无连接的传送所引进的主要变化如下</p><p>更大的地址空间。IPv6 将地址从 IPv4 的 32 位 增大到了 128 位。 </p><p>扩展的地址层次结构。 </p><p>灵活的首部格式。 </p><p>改进的选项。 </p><p>允许协议继续扩充。 </p><p>支持即插即用（即自动配置） </p><p>支持资源的预分配。  </p><p><strong>IPv6 数据报的目的地址可以是以下三种基本类型地址之一：</strong></p><p>1.单播(unicast)     单播就是传统的点对点通信。</p><p>2.多播(multicast)   多播是一点对多点的通信。</p><p>3.任播(anycast)    这是 IPv6 增加的一种类型。任播的目的站是一组计算机，但数据报在交付时只交付其中的一个，通常是距离最近的一个。 </p><p><strong>从IPV4到IPV6的过渡</strong></p><p>双协议栈</p><p>隧道技术</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="5-1运输层协议概述"><a href="#5-1运输层协议概述" class="headerlink" title="5.1运输层协议概述"></a>5.1运输层协议概述</h2><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</p><p><img src="/2019/05/19/计算机网络/29.png" alt></p><p><strong>运输层协议和网络层协议的主要区别</strong></p><p>IP协议的作用范围是提供主机之间的逻辑通信</p><p>TCP（传输控制协议）和UDP（用户数据报协议）协议的作用范围是提供进程之间的逻辑通信</p><p><strong>运输层的主要功能</strong></p><p>运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）。</p><p>运输层还要对收到的报文进行差错检测。</p><p>可靠数据传输</p><p>流量控制</p><p>拥塞控制</p><h2 id="5-2用户数据报协议UDP"><a href="#5-2用户数据报协议UDP" class="headerlink" title="5.2用户数据报协议UDP"></a>5.2用户数据报协议UDP</h2><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。</p><p><strong>UDP 在某些方面有其特殊的优点</strong></p><p>发送数据之前不需要建立连接</p><p>UDP 的主机不需要维持复杂的连接状态表。</p><p>UDP 用户数据报只有 8 个字节的首部开销。</p><p>网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。     </p><p><strong>UDP的特点</strong></p><p>UDP是无连接的。</p><p>UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制，因此主机不需要维持具有许多参数的、复杂的连接状态表。</p><p>由于 UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。</p><p>UDP是面向报文的。</p><p>UDP支持一对一、一对多、多对一和多对多的交互通信。</p><h2 id="5-3传输控制协议TCP"><a href="#5-3传输控制协议TCP" class="headerlink" title="5.3传输控制协议TCP"></a>5.3传输控制协议TCP</h2><p>TCP的主要特点：</p><p>​    TCP 是面向连接的运输层协议。</p><p>​    每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 </p><p>​    TCP 提供可靠交付的服务。</p><p>​    TCP 提供全双工通信。</p><p>​    面向字节流。  </p><p>发送缓存和接收缓存</p><p>TCP 连接是一条虚连接而不是一条真正的物理连接。</p><p><strong>一对一通信</strong></p><p>TCP 把连接作为最基本的抽象。</p><p>每一条 TCP 连接唯一地被通信两端的两个端点所确定。即：</p><p><code>TCP 连接 ::= {(IP1: port1), (IP2: port2)}</code></p><p><strong>UDP与TCP复用的区别</strong></p><p><img src="/2019/05/19/计算机网络/31.png" alt></p><p><strong>TCP报文段结构</strong></p><p>TCP 报文段分为首部和数据两部分。</p><p>TCP 的全部功能都体现在它首部中各字段的作用。</p><p>TCP 报文段首部的前 20个 字节是固定的，后面有 4<em>N</em> 字节是根据需要而增加的选项(<em>N</em> 必须是整数)。因此 TCP 首部的最小长度是 20 字节。 </p><p><img src="/2019/05/19/计算机网络/32.png" alt></p><p><strong>TCP的可靠传输</strong></p><p>TCP在IP的不可靠的尽最大努力服务的基础上实现了一种可靠数据传输服务，保证数据无差错、无丢失、按序和无重复的交付。</p><p>由于TCP下面的传输数据的互联网的结构非常复杂，因此不能采用最简单的停止等待协议来实现可靠传输。</p><p>以字节为单位的滑动窗口</p><p><strong>流量控制</strong></p><p>•流量控制(flow control)就是让发送方的发送速率不要太快，既要让接收方来得及接收。</p><p>•利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 </p><p><img src="/2019/05/19/计算机网络/30.png" alt></p><p><strong>超时重传时间的选择</strong></p><ul><li>指数加权</li><li><p>karn算法（不采用重传）</p><p><code>新的 RTTS = (1 - a) * (旧的 RTTS) + a * (新的 RTT 样本)</code></p><p><code>RTO = RTTS + 4 *RTTD</code>                   </p></li></ul><p>新的 RTTD = (1 - b) <em> (旧的RTTD）+b</em>|RTTS - 新的 RTT样本|</p><p><strong>快速重传</strong></p><p><img src="/2019/05/19/计算机网络/33.png" alt></p><h2 id="5-4拥塞控制"><a href="#5-4拥塞控制" class="headerlink" title="5.4拥塞控制"></a>5.4拥塞控制</h2><p>如果网络中的负载(load)，即发送到网络中的分组数量，超过了网络的容量，即网络中能处理的分组数量，那么在网络中就会发生拥塞(congestion)。</p><p>所谓拥塞控制(congestion control)就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p><p><img src="/2019/05/19/计算机网络/34.png" alt></p><p><strong>开环控制和闭环控制</strong></p><p>开环控制方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。 </p><p>闭环控制是基于反馈环路的概念。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;h2 id=&quot;1-1-计算机网络在信息时代中的作用&quot;&gt;&lt;a href=&quot;#1-1-计算机网络在信息时代中的作用&quot; class=&quot;head
      
    
    </summary>
    
      <category term="学习" scheme="https://smallpotatody.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="study" scheme="https://smallpotatody.github.io/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>HTML-CSS基础</title>
    <link href="https://smallpotatody.github.io/2019/05/15/HTML-CSS%E5%9F%BA%E7%A1%80/"/>
    <id>https://smallpotatody.github.io/2019/05/15/HTML-CSS基础/</id>
    <published>2019-05-15T14:12:44.000Z</published>
    <updated>2019-05-31T13:11:18.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><ul><li>C/S：C(客户端，用户通过客户端来使用软件)，S表示服务器。一般软件都是C/S架构。<ul><li>软件使用前必须安装</li><li>软件更新时，服务器与客户端同时更新</li><li>不能跨平台使用</li><li>C/S架构的软件客户端和服务器通信采用的是自有协议，相对来说比较安全</li></ul></li><li>B/S：B(浏览器)，B/S架构软件通过使用浏览器访问网页的形式，来使用软件。<ul><li>软件不需要安装，直接使用浏览器访问指定网址即可；</li><li>软件更新时，客户端不需要更新</li><li>软件可以跨平台使用</li><li>客户端和服务器之间通信采用的是通用HTTP协议，相对来说不安全</li></ul></li></ul><h2 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h2><ol><li>网页设计师根据需求设计网页（PS）</li><li>前端工程师将设计做成静态网页（HTML）</li><li>后台工程师将静态网页修改为动态网页（JSP）</li></ol><h2 id="网页组成"><a href="#网页组成" class="headerlink" title="网页组成"></a>网页组成</h2><ol><li>结构（HTML用于描述页面的结构）</li><li>表现（CSS用于控制页面中元素的样式）</li><li>行为（JavaScript用于响应用户操作）</li></ol><h2 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h2><ul><li>编码：依据一定的规则，将字符转换为二进制编码的过程；</li><li>解码：一句一定的规则，将二进制编码转换为字符的过程；</li></ul><p>特殊符号称为实体（转义字符），转换用&amp;实体名字；</p><p><code>&lt; &amp;lt;</code></p><p><code>&amp;copy;</code></p><h2 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h2><p>JPEG（JPG）</p><ul><li>JPEG图片支持的颜色比较多，图片可以压缩，但是不支持透明</li><li>一般使用JPEG来保存照片等颜色丰富的图片</li></ul><p>GIF</p><ul><li>GIF支持的颜色少，只支持简单的透明，支持动态图</li><li>图片颜色单一或者是动态图时可以使用GIF</li></ul><p>PNG</p><ul><li>PNG支持颜色多，并且支持复杂的透明</li><li>可以用来显示颜色复杂的透明的图片</li></ul><h2 id="图片使用规则："><a href="#图片使用规则：" class="headerlink" title="图片使用规则："></a>图片使用规则：</h2><ul><li>效果不一致，使用效果好的</li><li>效果一致，使用容量小的</li></ul><h2 id="meta标记作用"><a href="#meta标记作用" class="headerlink" title="meta标记作用"></a>meta标记作用</h2><ul><li><p>可以用来设置网页关键字</p><p><code>&lt;meta name=&quot;keywords&quot; content=&quot;HTML5,JavaScript,前端，后端，Python&quot; /&gt;</code></p></li><li><p>用来指定网页的描述</p><p>搜索引擎在检索页面时，会同时检索页面中的关键词和描述，但是这两个值不会影响页面在搜索引擎中的排名</p><p><code>&lt;meta name=&quot;description&quot; content=&quot;子在川上曰：逝者如斯夫！&quot;</code></p></li><li><p>可以用作请求重定向</p><p><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;4(秒数);url=http:www.baidu.com(目标路径)&quot; /&gt;</code></p></li></ul><h2 id="src属性配置"><a href="#src属性配置" class="headerlink" title="src属性配置"></a>src属性配置</h2><p>src属性配置的是图片的路径，目前我们所要使用的路径全是相对路径</p><p>相对路径：相对路径指相对于当前资源所在目录的位置</p><h2 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h2><ul><li>HTML中不区分大小写</li><li>HTML中注释不能嵌套</li><li>HTML标签必须结构完整，要么成对出现，要么自结束标签</li><li>HTML标签可以嵌套，但是不能交叉嵌套</li><li>HTML标签中的属性必须有值，且值必须加引号</li></ul><p><strong>浏览器尽最大的努力正确的解析页面，你所有的不符合语法规范的内容，浏览器都会为你自动修正，但是有些情况会修正错误</strong></p><h2 id="内联框架"><a href="#内联框架" class="headerlink" title="内联框架"></a>内联框架</h2><p>使用内联框架可以引入一个外部的页面，使用iframe来创建一个内联框架，属性：</p><ul><li>src:指向一个外部页面的路径，可以使用相对路径</li><li>width:</li><li>height:</li><li>name:可以为内联框架指定一个name属性</li></ul><p>在现实开发中不推荐使用内联框架，因为内联框架的内容不会被搜索引擎所检索</p><p><code>&lt;iframe src=&quot;demo2.html&quot; name=&quot;tom&quot;&gt;&lt;/iframe&gt;</code></p><h2 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h2><p><code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code></p><p>如果链接地址设为#，则点击超链接以后，会自动跳转到当前页面顶部。id是html中属性作为标签的唯一标识，id属性在同一页面中只能有一个不能重复。</p><p>1.<code>&lt;a id=&quot;1&quot; href=&quot;#&quot;&gt;回到顶部&lt;/a&gt;</code></p><p>2.<code>&lt;a href=&quot;#1&quot;&gt;回到底部&lt;/a&gt;</code></p><p>通过2可以快速到1的地方</p><p>还可以发送电子邮件的超链接，点击超链接以后可以自动打开计算机中默认的邮件客服端href=”mailto:<a href="mailto:123@nik.com" target="_blank" rel="noopener">123@nik.com</a>“；当点击这个超链接时，会默认打开计算机的默认电子邮件客服端，并且将收件人设置为mailto后的邮件地址；</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>层叠样式表（Cascading Style Sheets）,css可以用来为网页创建样式表，通过样式表可以对网页进行装饰。</p><p>可以将CSS样式编写到元素的style属性中，将样式直接编写到style属性中，这种样式称为内联样式，内联样式只对当前的元素中的内容起作用，内联样式不方便复用，内联样式属于结构与表现耦合，不方便后期维护，不推荐使用</p><h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><ol><li><p>内联样式：<code>&lt;p style=&quot;color:red;font-size:20px;&quot;&gt;</code></p></li><li><p>内部样式：</p><figure class="highlight plain"><figcaption><span>type</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">p&#123;</span><br><span class="line">​color:red;</span><br><span class="line">​font-size:40px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>外部样式表：将样式表写到外部的CSS文件中，然后通过link标签来将外部的CSS文件引入到当前页面中，这样外部文件中的CSS样式表将会应用到当前页面中。将CSS样式统一编写到外部的样式表中，完全使结构和表现分离，可以是样式表可以在不同的页面使用，最大限度的使样式可以进行复用，将样式表统一写在样式表中，然后通过link标签引入，可以利用浏览器的缓存加快用户访问的速度提高用户体验，所以在开发中我们推荐使用的方式就是外部的CSS文件；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css(style文件)&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="CSS注释"><a href="#CSS注释" class="headerlink" title="CSS注释"></a>CSS注释</h2><p><code>/**/</code>作用和HTML注释类似，只不过它必须编写在style标签中，或者是css文件中</p><h2 id="CSS的语法"><a href="#CSS的语法" class="headerlink" title="CSS的语法"></a>CSS的语法</h2><ul><li><p>选择快</p><ul><li>通过选择器可以选中页面中指定的元素，并且将声明块中的样式应用到选择其对应的元素上</li></ul></li><li><p>声明块</p><ul><li>声明块紧跟在选择器的后边，使用一对{}括起来，声明块中实际上就是一组一组的名值对结构，这一组一组的名值对我们称为声明，在一个声明块中可以写多个声明，多个声明之间使用<code>;</code>隔开，声明的样式名和样式值之间使用<code>:</code>来连接。</li></ul></li></ul><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>nodep++</p><p>sublime</p><p>HBuilder（免费、国产）</p><p>webstorm（收费）</p><h2 id="块元素和内联元素"><a href="#块元素和内联元素" class="headerlink" title="块元素和内联元素"></a>块元素和内联元素</h2><ul><li>div就是一个块元素，块元素就是会独占一行的元素，无论有多少内容，他都会独占一行。</li><li>div标签没有任何语义，就是纯粹的块元素，并且不会为它里边的元素设置任何的默认样式，div元素主要用来对页面进行布局的。</li><li>p hn</li></ul><ol><li>span是一个内联元素（行内元素），所谓的行内元素，是指只占自身大小的元素，不会占用一行常见的内联元素</li><li>span没有任何语义，span标签专门用来选中文字，然后为文字来设置样式</li><li>a img iframe span</li></ol><p><strong>块元素主要用来做页面的布局，内联元素主要用来选中文本设置样式，一般情况下只使用块元素去包含内联元素，而不会使用内联元素去包含一个块元素。a元素可以包含任意元素，除了它本身。p元素不可以包含任何块元素。</strong></p><h2 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h2><ul><li>作用：通过元素选择器可以选择页面中的所有指定元素</li><li><p>语法：标签名{}</p></li><li><p>id选择器</p><ul><li>通过元素的id属性值选中唯一的一个元素</li><li>语法：#id属性值{}</li></ul></li><li><p>类选择器</p><ul><li>通过元素的class属性值选中一组元素</li><li>语法：.class属性值{}</li></ul></li><li><p>选择分组（并集选择器）</p><ul><li>通过选择器分组可以同时选中多个选择器对应的元素</li><li>语法：选择器1，选择器2，选择器N{}</li></ul></li><li><p>通配选择器</p><ul><li>他可以用来选中页面的所有元素</li><li>语法：*{}</li></ul></li><li><p>复合选择器（交集选择器）</p><ul><li>可以选中同时满足多个选择器的元素</li><li>语法：选择器1选择器2选择器N{}</li></ul></li><li></li></ul><h2 id="元素关系"><a href="#元素关系" class="headerlink" title="元素关系"></a>元素关系</h2><ul><li>父元素：直接包含子元素的元素</li><li>子元素：直接被父元素包含的元素</li><li>祖先元素：直接或间接包含后代元素的元素，父元素也是祖先元素</li><li>后代元素：直接或间接被祖先元素包含的元素，子元素也是后代元素</li><li><p>兄弟元素：拥有相同父元素的元素叫做兄弟元素</p></li><li><p>后代元素选择器</p><ul><li>作用：选中指定元素的指定后代元素</li><li>语法：祖先元素 后代元素{}</li></ul></li><li><p>子元素选择器</p><ul><li>作用：选中指定父元素的指定元素</li><li>语法：父元素 &gt; 子元素</li></ul></li></ul><h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>伪类专门用来表示元素的一种特殊的状态，当我们需要为处在这些特殊状态的元素设置样式时，就可以使用伪类</p><p><code>a:link{color:red;}</code>表示正常链接</p><p><code>a:visited{color:blue;}</code>表示访问过的链接</p><p><code>a:hover{color:yellow;}</code>表示鼠标滑过的链接</p><p>a:active{color:green;}表示的是超链接被点击的状态</p><p><em>浏览器是通过历史记录来判断一个链接是否访问过，由于涉及到用户的隐私问题，所以使用visited味蕾只能设置字体的颜色</em></p><p><strong>:hover和:active也可以对其他元素设置</strong></p><p>IE6中不支持对超链接外的元素设置:hover和:active</p><p><code>-:focus{}</code>表示获取焦点</p><p><code>-:before{}</code>表示指定元素前</p><p><code>-:after{}</code>表示指定元素后</p><p><code>-::selection{}</code>表示选中的元素</p><p><code>-:first-letter{}</code>表示首字母</p><p><code>-:first-line{}</code>表示首行</p><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>title属性，这个属性可以给任何标签指定，当鼠标移入到元素上时，元素中的title属性的值将会作为提示文字显示</p><ul><li>作用：可以根据元素中的属性或属性值来选取指定元素</li><li>语法：<ul><li>[属性名]选取含有指定属性的元素</li><li>[属性名=”属性值”]选择含有指定属性值的元素</li><li>[属性名^=”属性值”]选取属性值以指定内容开头的元素</li><li>[属性名$=”属性值”]选取属性值以指定内容结尾的元素</li><li>[属性名*=”属性值”]选取属性值以包含指定内容元素</li></ul></li></ul><p>例：<code>p[title]{background-color:red;}</code></p><p>​    <code>p[title=&quot;属性值&quot;]{color:red;}</code></p><p>​    <code>p[title^=&quot;属性值&quot;]{color:red;}</code></p><p>​    <code>p[title$=&quot;属性值&quot;]{color:red;}</code></p><h2 id="子元素的伪类"><a href="#子元素的伪类" class="headerlink" title="子元素的伪类"></a>子元素的伪类</h2><p><code>p:first-child{background-color:red}</code>可以选中第一个元素</p><p><code>p:last-child{background-color:red}</code>可以选中最后一个元素</p><p><code>p:nth-child（3）{background-color:red}</code>可以选中任意位置的元素，3表示是第三个元素，even表示偶数位置的元素，odd表示是奇数位置的元素。</p><p><strong>child是在所有的子元素中排列，而type是在当前类型的子元素中排列。</strong></p><p><code>p:first-of-type{background-color:red;}</code>表示第一个p元素背景设置为热点。</p><p><code>p:last-of-type{background-color:red;}</code>表示最后一个p元素背景设置为热点。</p><p><code>p:nth-of-type（even）{background-color:red;}</code>表示任意位置的p元素。</p><h2 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h2><p>–    查找后边一个兄弟元素<br>•    兄弟元素 + 兄弟元素{}</p><p>–    查找后边所有的兄弟元素<br>•    兄弟元素 ~ 兄弟元素{}</p><h2 id="否定伪类"><a href="#否定伪类" class="headerlink" title="否定伪类"></a>否定伪类</h2><ul><li>作用：可以从已选中的元素中剔出某些元素</li><li>语法：<code>p:not(.hello（选择器）){background-color：red；}</code></li></ul><h2 id="样式继承"><a href="#样式继承" class="headerlink" title="样式继承"></a>样式继承</h2><p>• 就像父亲的财产会遗传给儿子一样，在 CSS 中祖先元素的样式 同样也会被子元素继承。<br>• 继承是指应用在一个标签上的那些 CSS 样式会同时被应用到其 内嵌标签上。<br>• 比如为父元素设置了字体颜色，子也会应用上相同的。 比如为父元素设置了字体颜色，子也会应用上相同的。 比如为父元素设置了字体颜色，子也会应用上相同的。<br>• 当然并不是所有的样式都会被继承，这一点我们讲到具体时，再去讨论。</p><h2 id="权重（优先级）"><a href="#权重（优先级）" class="headerlink" title="权重（优先级）"></a>权重（优先级）</h2><p>当使用不同的选择器，选中同一个元素时并且设置相同的样式时，这样样式之间产生冲突，最终到底采用哪个选择器定义的样式，由选择器的优先级（权重）决定，优先级高的优先运行</p><p>优先级的规则</p><ul><li>内联样式：优先级1000</li><li>id选择器：优先级100</li><li>类和伪类：优先级10</li><li>元素选择器：优先级1</li><li>通配*：优先级0</li></ul><p><strong>继承的样式没有优先级</strong></p><p>当选择器中包含多种选择器时，需要将多种选择器的优先级相加然后再比较，但是选择器优先级计算不会超过他的最大数量级，如果选择器的优先级一样，则使用靠后的样式。</p><p>并集选择器的优先级是单独计算，可以在样式的最后添加一个<code>!important</code>,则此时该样式将会获得一个最高的优先级，将会优先于所有的样式显示甚至超过内联样式，但是在开发中尽量避免使用<code>!important</code></p><h2 id="伪类的顺序"><a href="#伪类的顺序" class="headerlink" title="伪类的顺序"></a>伪类的顺序</h2><p>l  v   h   a</p><h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><p><code>&lt;em&gt;</code>和<code>&lt;strong&gt;</code>这两个标签都表示一个强调的内容，<code>&lt;em&gt;</code>主要表示语气上的强调，<code>&lt;em&gt;</code>在浏览器中默认使用斜体显示</p><p><code>&lt;strong&gt;</code>表示强调的内容，比<code>&lt;em&gt;</code>更强烈，默认使用粗体显示</p><p><code>&lt;i&gt;</code>标签中的内容会以斜体显示,<code>&lt;b&gt;</code>标签中的内容会以粗体显示</p><p><code>&lt;small&gt;&lt;/small&gt;</code>表示比父元素小的字号。<code>&lt;cite&gt;&lt;/cite&gt;</code>标签可以指明对其内容的应用或参考。</p><p><code>&lt;q&gt;&lt;/q&gt;</code>表示加引号，<code>&lt;blockquote&gt;&lt;/blockquote&gt;</code>表示</p><p><img src="/2019/05/15/HTML-CSS基础/1.png" alt></p><p><code>&lt;sub&gt;&lt;/sub&gt;</code>和<code>&lt;sup&gt;&lt;/sup&gt;</code></p><p><img src="/2019/05/15/HTML-CSS基础/2.png" alt></p><p><code>&lt;ins&gt;&lt;/ins&gt;</code> 表示插入的内容，显时通常会加上下 划线。<br><code>&lt;del&gt;&lt;/del&gt;</code>表示删 除的内容，显时通常会加上除线</p><p><code>&lt;pre&gt;&lt;/pre&gt;</code>表示预格式，<code>&lt;code&gt;&lt;/code&gt;</code>表示代码，一般结合使用pre和code来表示一段代码</p><p><img src="/2019/05/15/HTML-CSS基础/3.png" alt></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li><p>无序列表</p><ul><li>disc默认值，实心的圆点</li><li>square实心的方块</li><li>circle空心的园</li></ul></li><li><p>有序列表</p><ul><li>1</li><li>默认值</li><li>a</li><li>i</li></ul></li><li><p>定义列表</p><ul><li><p><code>&lt;dl&gt;</code></p><ul><li><code>&lt;dt&gt;&lt;/dt&gt;</code></li><li><code>&lt;dd&gt;&lt;/dd&gt;</code></li></ul></li><li><p><code>&lt;/dl&gt;</code></p></li></ul></li></ul><p><code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>都是块元素，列表可以嵌套</p><p><img src="/2019/05/15/HTML-CSS基础/4.png" alt></p><p><img src="/2019/05/15/HTML-CSS基础/5.png" alt></p><h2 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h2><ul><li>像素px：是我们在网页中使用的最多一个单位，一个像素就相当于我们屏幕中的一个小店，我们的屏幕实际上就是由这些像素点构成的，但是这些像素点是不能直接看见的。不同显示器一个像素的大小也不相同，显示效果越好越清晰，像素越小，反之像素越大。</li><li>百分比%：也可以将单位设置成一个百分比的形式，这样浏览器将会根据其父元素的样式来计算该值。好处是当父元素发生变化时，子元素也会按照比例发生改变，我们创建一个自适应的页面时，经常使用百分比作为单位。</li><li>em：em和百分比相似，它是相对于当前元素的字体大小来计算的，1em = 1font-size。使用em时，当字体发生变化时，em也随之变化，当设置字体相关的样式时，经常会使用em。</li></ul><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p><code>rgb(255,255,255)</code></p><p><code>rgb(100%,100%100%)</code></p><p><code>#ffffff</code></p><h2 id="字体的样式"><a href="#字体的样式" class="headerlink" title="字体的样式"></a>字体的样式</h2><p>设置字体的颜色，使用color来设置文字的颜色<code>color:red;</code></p><p>设置字体的大小，浏览器中一般默认的文字大小都是16px，font-size设置的并不是文字本身的大小，在页面中每个文字都是处在一个看不见的框中，我们设置的font-size实际上是设置格的高度，并不是字体的大小，一般情况下文字都要比这个格要小一些，也有时会比格大。根据字体的不同，显示效果也不同。</p><p>通过font-family可以指定文字的字体，当采用某种字体时，如果浏览器支持则使用该字体，如果字体不支持，则使用默认字体，该样式可以同时指定多个字体，多个字体之间使用<code>,</code>分开，当采用多个字体时，浏览器会优先使用前边的字体，如果前边没有，再尝试下一个。</p><p>浏览器使用的字体默认是计算机中的字体，如果计算机中有，则使用，如果没有就不用。在开发中，如果字体太奇怪或用的太少了，尽量就不要使用。</p><p><img src="/2019/05/15/HTML-CSS基础/6.png" alt></p><h2 id="颜色单位"><a href="#颜色单位" class="headerlink" title="颜色单位"></a>颜色单位</h2><ul><li>颜色的单词</li><li>RGB(0~255,0~255,0~255)</li><li>RGB(1~100%,1~100%,1~100%)</li></ul><p><img src="/2019/05/15/HTML-CSS基础/7.png" alt></p><h2 id="字体分类"><a href="#字体分类" class="headerlink" title="字体分类"></a>字体分类</h2><ul><li><p>erif（衬线字体）</p></li><li><p>sans-serif（非衬线字体）</p></li><li><p>monospace （等宽字体）</p></li><li><p>cursive （草书字体）</p></li><li><p>fantasy （虚幻字体）</p><p>可以将这些字体设置为这些大的分类，当设置为大的分类以后，浏览器会自动选择指定的字体并应用样式。一般将字体的大分类，指定为font-family中的最后一个字体。</p></li></ul><p><img src="/2019/05/15/HTML-CSS基础/8.png" alt></p><p>font-style设置字体斜体</p><p><img src="/2019/05/15/HTML-CSS基础/9.png" alt></p><p>font-weight设置字体的粗细</p><p><img src="/2019/05/15/HTML-CSS基础/10.png" alt></p><p>font-variant用来设置小型大写字母，有normal和small-caps文本以小型大写字母显示。</p><p><img src="/2019/05/15/HTML-CSS基础/11.png" alt></p><p><strong>在css中还为我们提供了一个样式叫font，使用该样式可以同时设置字体相关的所有样式，可以将字体的样式的值，统一写在font样式中，不同的值之间使用空格隔开</strong></p><p>使用font设置字体样式时，斜体 加粗 小大字母没有顺序要求，甚至可写可不写，如果不写则使用默认值，但是要求文字的大小和字体必须写，而且字体必须是最后一个样式，大小必须是倒数第二个样式。</p><p>font可以一次性同时设置多个字体的样式。</p><p> 语法：<br>font:加粗 斜体 小型大写 大小/行高 字体<br><strong>这里前边几个加粗、斜体和小型大写的顺序无所谓，也可以不写，但是大小和字体必须写且必须写到后两个。</strong></p><p><img src="/2019/05/15/HTML-CSS基础/12.png" alt></p><h2 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h2><p>在CSS并没有为我们提供一个直接设置行间距的方式，我们只能通过设置行高来间接设置行间距，行高越大行间距越大。使用<code>line-height</code>来设置行高，网页中的文字实际上也是写在一个看不见的线中，而文字默认会在行高中垂直居中显示。</p><p>行间距 = 行高 - 字体</p><p>通过设置line-height可以间接的设置行高，可接受的值：直接接受一个大小；或指定一个百分数，则会相对于字体去计算行高；可以直接传一个数值，则行高会设置字体大小的相应倍数。</p><p>对于单行文本来说，可以将行高设置为和父元素的高度一致，这样可以是单行文本在父元素中垂直居中。</p><p><img src="/2019/05/15/HTML-CSS基础/13.png" alt></p><p>font:加粗 斜体 小型大写 大小/行高 字体，行高是可选的，如果不指定则会使用默认值。</p><h2 id="大写化"><a href="#大写化" class="headerlink" title="大写化"></a>大写化</h2><p>text-transform样式用于将元素中的字母全都变成大小。</p><ul><li>大写：text-transform:uppercase</li><li>小写：text-tansform:lowercase</li><li>首字母大写：text-transform:capitalize</li><li>正常：text-transform:none</li></ul><h2 id="文本的修饰"><a href="#文本的修饰" class="headerlink" title="文本的修饰"></a>文本的修饰</h2><p> text-decoration属性，用来给文本添加各种修饰。通过它可以为文本的上方、下方或者中间添加线条。<br>可选值：<br> underline<br> overline<br> line-through<br> none</p><p>字母间距和单词间距</p><p><code>letter-spacing</code>用来设置字符之间的间距</p><p><code>word-spacing</code>用来设置单词之间的间距</p><p><img src="/2019/05/15/HTML-CSS基础/14.png" alt></p><h2 id="对齐文本"><a href="#对齐文本" class="headerlink" title="对齐文本"></a>对齐文本</h2><p>text-align用于设置文本的对齐方式</p><p>可选值：</p><ul><li>left：左对齐</li><li>right：右对齐</li><li>justify：两边对齐</li><li>center：居中对齐</li></ul><h2 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h2><p>text-indent用来设置首行缩进</p><p>该样式需要指定一个长度，并且只对第一行生效。</p><p><img src="/2019/05/15/HTML-CSS基础/15.png" alt></p><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>CSS处理网页时，它认为每个元素都包含在一个不可见的盒子里。为什么要想象成盒子呢？因为如果把所有的元素都想象成盒子，那么我们对网页的布局就相当于是摆放盒子。</p><p>一个盒子会分成几个部分</p><ul><li>内容区（content）</li><li>内边距（padding）</li><li>边框（border）</li><li>外边距（margin）</li></ul><p><img src="/2019/05/15/HTML-CSS基础/16.png" alt></p><p>使用width来设置盒子<strong>内容区</strong>的宽度，使用height来设置盒子<strong>内容区</strong>的高度</p><h2 id="边框设置"><a href="#边框设置" class="headerlink" title="边框设置"></a>边框设置</h2><ul><li><p>border-width  表示边框宽度</p></li><li><p>border-color  表示边框颜色</p></li><li><p>border-style  表示边框样式</p><p>边框可以设置多种样式：<br>– none（没有边框）<br>– dotted（点线）<br>– dashed（虚线）<br>– solid（实线）<br>– double（双线）<br>– groove（槽线）<br>– ridge（脊线）<br>– inset（凹边）<br>– outset（凸边）</p></li></ul><p>当属性值只有一个时，则代表上、下、左、右一样，两个时代表上下、左右，当只有三个时，则代表上、左右、下，有四个时代表上、右、下、左。</p><p>例如：<code>border-width:20px 30px 40px 10px;</code></p><p>还可以使用border-xxx-width，xxx可以有top、right、bottom、left表示上、右、下、左各边的宽度。</p><p><strong>三者缺一不可，但大部分浏览器中，边框的宽度和颜色都是有默认值，而边框的样式默认值都是none，所有无法显示，必须要设置border-style</strong></p><p><code>border:red solid 10px</code>，三个属性值顺序不限，但border一指定就同时指定四个边，不能分别指定。但可以用border-xxx来表示某一边。</p><p><img src="/2019/05/15/HTML-CSS基础/17.png" alt></p><p>内边距指的就是元素内容区与边框以内的空间，默认情况下width和height不包含padding的大小。</p><p>内边距会影响盒子的可见框的大小，元素的背景会延伸到内边距，盒子的大小由内容区、内边距和边框共同决定</p><p>盒子可见框宽度 = border-left-width + padding-left + width +padding-right + border-right-width</p><h2 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h2><p>外边距指的是当前盒子与其它盒子之间的距离，不会影响可见框的大小，而会影响到盒子的位置。</p><p>盒子有四个方向的外边距</p><ul><li>margin-top</li><li>margin-right</li><li>margin-bottom</li><li>margin-left</li></ul><p>由于页面中的元素都是靠左靠上摆放的，所以注意当我们设置上和左外边距时，会导致盒子自身的位置发生改变。如果是设置右和下外边距会改变其它盒子的位置。如果外边距设置的是负值，则元素会向反方向移动。</p><p>margin还可以设置为auto，auto一般只设置给水平方向的margin，如果指定，左外边距或右外边距的margin为auto则会将外边距设置为最大值，垂直方向外边距如果设置为auto，则外边距默认就是0。</p><p>如果将left和right同时设置为auto，则会居中。</p><h2 id="垂直外边距的重叠"><a href="#垂直外边距的重叠" class="headerlink" title="垂直外边距的重叠"></a>垂直外边距的重叠</h2><p>在网页中<strong>相邻</strong>的<strong>垂直方向的外边距</strong>会发生外边距重叠，所谓外边距重叠是指兄弟元素之间相邻外边距会取最大值而不是取和。</p><ul><li><p>可以在相邻两个元素之间输入一个数</p></li><li><p>或者设置一个外边距和内边距</p><p><img src="/2019/05/15/HTML-CSS基础/18.png" alt></p></li></ul><h2 id="浏览器默认样式"><a href="#浏览器默认样式" class="headerlink" title="浏览器默认样式"></a>浏览器默认样式</h2><p>浏览器为了在页面中没有样式时，也可以有一个比较好的效果，所以为很多的元素设置一些默认的margin和padding，而它的这些默认样式，正常情况下我们是不需要使用的。所以我们往往在编写样式之前需要将浏览器中的默认的margin和padding统统的去掉。</p><p>清楚浏览器默认样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    padding:0;</span><br><span class="line">    margin:0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内联元素的盒模型"><a href="#内联元素的盒模型" class="headerlink" title="内联元素的盒模型"></a>内联元素的盒模型</h2><p>内联元素不能设置width和height，但可以设置水平方向的内边距，也可以设置垂直方向内边距，但是不会影响页面的布局。内联元素可以设置边框，但是垂直的边框不会影响到页面的布局，会影响水平方向的页面布局。</p><p>内联元素支持水平方向的外边距，水平方向的相邻外边距不会重叠，而是求和。内联元素不支持垂直方向外边距。</p><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><p>将一个内联元素变成块元素，通过display样式可以修改元素类型</p><ul><li><p>inline：可以将一个元素作为内联元素显示</p></li><li><p>block：可以将一个元素设置块元素显示</p></li><li><p>inline-block：将一个元素转换为行内块元素，可以使一个元素既有行内元素的特点又有块元素的特点，既可设置行高，又不会独占一行。</p></li><li><p>none：使用该方式隐藏元素，不会在页面中显示，并且不再占据页面的位置。</p><p><img src="/2019/05/15/HTML-CSS基础/19.png" alt></p></li></ul><h2 id="visibility"><a href="#visibility" class="headerlink" title="visibility"></a>visibility</h2><p>可以用来设置元素的隐藏和显示状态。visible默认值，元素默认会在页面中显示。hidden元素会隐藏不显示，但它的位置会依然保持。</p><p><img src="/2019/05/15/HTML-CSS基础/20.png" alt></p><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p>子元素默认是存在于父元素的内容区中，理论上讲子元素的大小超过了父元素的最大可以等于父元素的内容区，则超过的大小会在父元素意外的位置显示，超过父元素的内容，我们称为溢出内容，在父元素外边显示，通过overflow可以设置父元素如何处理溢出内容</p><p>可选值：</p><p>– scroll ：添加滚动条,不论内容是否溢出，都会添加水平和垂直方向的滚动条。<br>– auto ：根据需要添加滚动条<br>– hidden ：隐藏超出盒子的内容</p><p>– visible visible visible：默认值</p><p><img src="/2019/05/15/HTML-CSS基础/21.png" alt></p><p><img src="/2019/05/15/HTML-CSS基础/22.png" alt></p><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>文档流处在网页的最底层，它表示的是一个页面中位置，我们创建的元素默认都处在文档流中。</p><p><strong>元素在文档流中的特点</strong></p><p>块元素在文档流中会独占一行，块元素会自上向下排列。块元素在文档流中默认宽度是父元素的100%。块元素在文档流中的高度默认被内容撑开。</p><p>内联元素在文档流中只有自身的大小，会默认从左向右排列，如果在一行中不足以容纳所有的内联元素，则会到下一行，继续自左向右。内联元素的宽度和高度默认都被内容撑开。</p><p>当元素的宽度的值为auto时，此时指定内边距不会影响可见框的大小，而是会自动修改宽度，以适应内边距。</p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>块元素在文档流中默认垂直排列，所以这个三个div自上至下依次排开，如果希望块元素在页面中水平排列，可以是使块元素脱离文档流。使用float来使元素浮动，从而脱离文档流。</p><p>可选值：</p><p>– none：不浮动<br>– left：向左浮动<br>– right ：向右浮动</p><p>当为一个元素设置浮动以后（float属性是一个非none的值），元素会立即脱离文档流，元素脱离文档流以后，它下边的元素会立即向上移动看，元素移动后，会尽量向页面的左上或右上漂浮，直到遇到父元素的边框或者其他的浮动元素，如果浮动元素上边是一个没有浮动的元素，则浮动元素不会超过块元素。浮动的元素不会超过它上边的兄弟元素，最多最多一边齐。</p><p><img src="/2019/05/15/HTML-CSS基础/23.png" alt></p><p>浮动元素不会盖住文字，文字会自动环绕在浮动元素的周围，所以我们可以通过浮动来设置文字环绕图片的效果。</p><p><img src="/2019/05/15/HTML-CSS基础/24.png" alt></p><p>当元素设置浮动以后，会完全脱离文档流，块元素脱离文档流以后，高度和宽度都被内容撑开。内联元素脱离文档流以后会变成块元素。</p><p><img src="/2019/05/15/HTML-CSS基础/25.png" alt></p><h2 id="简单布局"><a href="#简单布局" class="headerlink" title="简单布局"></a>简单布局</h2><p><img src="/2019/05/15/HTML-CSS基础/26.png" alt></p><h2 id="高度塌陷问题"><a href="#高度塌陷问题" class="headerlink" title="高度塌陷问题"></a>高度塌陷问题</h2><p>在文档流中，父元素的高度默认就是被子元素撑开的，也就是说子元素多高，父元素就多高。但是为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。由于父元素高度塌陷，则父元素下的所有元素都会向上移动。这样将会导致页面布局混乱。所以在开发中一定要避免出现的高度塌陷的问题，我们可以将父元素的高度写死，以免塌陷的问题出现，但是一定高度写死，父元素的高度将不能自动适应子元素的高度，所以这种方案是不推荐使用的！</p><p><strong>解决高度塌陷问题</strong></p><p>根据W3C的标准，在页面中元素都一个隐含的属性叫做Block Formatting Context，简称BFC，该属性可以设置打开或者关闭，默认是关闭的。当开启元素的BFC以后，元素将会具有如下的特性：</p><ol><li>父元素的垂直外边距不会和子元素重叠</li><li>开启BFC的元素不会被浮动元素所覆盖</li><li>开启BFC的元素可以包含浮动的子元素</li></ol><p>如何开启元素的BFC</p><ol><li><p>设置元素浮动——使用这种方式开启，虽然可以撑开父元素，但是会导致父元素的宽度丢失，而且使用这种方式也会导致下边的元素上移，不能解决问题。</p></li><li><p>设置元素绝对定位</p></li><li><p>设置元素为inline-block——可以解决问题，但是会导致宽度丢失，不推荐使用这种方式。</p></li><li><p>将元素的overflow设置为一个非visible的值</p><p>推荐方式：将overflow设置为hidden是副作用最小的开启BFC的方式。</p></li></ol><p>但是在IE6及以下的浏览器中并不支持BFC，所以使用这种方式不能兼容IE6。在IE6中虽然没有BFC，但是具有另一个隐含的属性叫做haslayout，该属性的作用和BFC类似，所在IE6浏览器可以通过开haslayout来解决该问题。开启方式有很多，我们直接使用一种副作用最小的——直接将元素的zoom设置为1即可。</p><p>zoom表示放大的意思，后边跟着一个数值，写几就将元素放大几倍，zoom:1;表示不放大元素，但是通过该样式可以开启haslayout。zoom这个样式只在IE中支持，其他浏览器都不支持。</p><p>clear可以用来清除其他浮动元素对当前元素的影响，可选值：</p><ul><li>none：默认值，不清除浮动</li><li>left：清除左侧浮动元素对当前元素的影响</li><li>right：清除右侧浮动元素对当前元素的影响</li><li>both：清除两侧浮动元素对当前元素的影响，清除影响对它最大的那个元素的浮动。</li></ul><p>清除浮动以后，元素会回到其他元素浮动之前的位置。</p><p><img src="/2019/05/15/HTML-CSS基础/27.png" alt></p><p><strong>解决高度塌陷方案二</strong></p><p>可以直接在高度塌陷的父元素的最后，添加一个空白的div，由于这个div并没有浮动，所以它是可以撑开父元素的高度的，然后进行清除浮动，这样可以通过这个空白的div来撑开父元素的高度，基本没有副作用。或者通过after伪类向元素的最后添加一个空白的块元素，然后对其清除浮动，这样做和添加一个div的原理一样，可以达到一个相同的效果，而且不会在页面中添加多余的div，这是我们最推荐使用的方式，几乎没有副作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">    content:&quot;&quot;;</span><br><span class="line">    displayP:block;</span><br><span class="line">    clear:both;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&lt;div class=&quot;box1 clearfix&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="导航条练习"><a href="#导航条练习" class="headerlink" title="导航条练习"></a>导航条练习</h2><p><img src="/2019/05/15/HTML-CSS基础/28.png" alt></p><h2 id="开班信息练习"><a href="#开班信息练习" class="headerlink" title="开班信息练习"></a>开班信息练习</h2><p><img src="/2019/05/15/HTML-CSS基础/29.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">*&#123;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">body&#123;</span><br><span class="line">font: 12px/1 宋体;</span><br><span class="line">&#125;</span><br><span class="line">.outer&#123;</span><br><span class="line">width: 300px;</span><br><span class="line">margin: 50px auto;</span><br><span class="line">&#125;</span><br><span class="line">.title&#123;</span><br><span class="line">border-top:2px #019e8b solid;</span><br><span class="line">height: 36px;</span><br><span class="line">background-color: #f5f5f5;</span><br><span class="line">line-height: 36px;</span><br><span class="line">padding: 0 22px 0 16px;</span><br><span class="line">&#125;</span><br><span class="line">.title a&#123;</span><br><span class="line">float: right;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br><span class="line">.title h3&#123;</span><br><span class="line">font: 16px/36px &quot;微软雅黑&quot;;</span><br><span class="line">&#125;</span><br><span class="line">.content&#123;</span><br><span class="line">border: 1px solid #deddd9;</span><br><span class="line">padding: 0 28px 0 20px;</span><br><span class="line">&#125;</span><br><span class="line">.content a&#123;</span><br><span class="line">color: black;</span><br><span class="line">text-decoration: none;</span><br><span class="line">font-size: 12px;</span><br><span class="line">&#125;</span><br><span class="line">.content a:hover&#123;</span><br><span class="line">color: yellowgreen;</span><br><span class="line">text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">.content h3&#123;</span><br><span class="line">margin-top:14px ;</span><br><span class="line">margin-bottom: 16px;</span><br><span class="line">&#125;</span><br><span class="line">.content .right&#123;</span><br><span class="line">float: right;</span><br><span class="line">&#125;</span><br><span class="line">ul&#123;</span><br><span class="line">list-style: none;</span><br><span class="line">border-bottom:1px dashed #deddd9; </span><br><span class="line">&#125;</span><br><span class="line">.content .border&#123;</span><br><span class="line">border: none;</span><br><span class="line">&#125;</span><br><span class="line">.content .red&#123;</span><br><span class="line">color: red;</span><br><span class="line">font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line">.content li&#123;</span><br><span class="line">margin-bottom: 15px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;title&quot;&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;16年面授开班计划&lt;/a&gt;</span><br><span class="line">&lt;h3&gt;近期开班&lt;/h3&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">&lt;h3&gt;&lt;a href=&quot;&quot;&gt;JavaEE+云计算-全程就业班&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a class=&quot;right&quot; href=&quot;#&quot;&gt;&lt;span class=&quot;red&quot;&gt;预约报名&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;开班时间：&lt;span class=&quot;red&quot;&gt;2016-04-27&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a class=&quot;right&quot; href=&quot;#&quot;&gt;&lt;span class=&quot;red&quot;&gt;无座，名额爆满&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;开班时间：&lt;span class=&quot;red&quot;&gt;2016-04-27&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a class=&quot;right&quot; href=&quot;#&quot;&gt;&lt;span&gt;开班盛况&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;开班时间：&lt;span&gt;2016-04-27&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a class=&quot;right&quot; href=&quot;#&quot;&gt;&lt;span&gt;开班盛况&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;开班时间：&lt;span&gt;2016-03-15&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a class=&quot;right&quot; href=&quot;#&quot;&gt;&lt;span&gt;开班盛况&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;开班时间：&lt;span&gt;2016-02-25&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;h3&gt;&lt;a href=&quot;&quot;&gt;Android+人工智能-全程就业班&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a class=&quot;right&quot; href=&quot;#&quot;&gt;&lt;span class=&quot;red&quot;&gt;预约报名&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;开班时间：&lt;span class=&quot;red&quot;&gt;2016-04-10&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a class=&quot;right&quot; href=&quot;#&quot;&gt;&lt;span&gt;开班盛况&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;开班时间：&lt;span&gt;2016-03-17&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a class=&quot;right&quot; href=&quot;#&quot;&gt;&lt;span&gt;开班盛况&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;开班时间：&lt;span&gt;2016-02-20&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a class=&quot;right&quot; href=&quot;#&quot;&gt;&lt;span&gt;开班盛况&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;开班时间：&lt;span&gt;2015-12-23&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;h3&gt;&lt;a href=&quot;&quot;&gt;前端+HTML5-全程就业班&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">&lt;ul class=&quot;no-border&quot;&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a class=&quot;right&quot; href=&quot;#&quot;&gt;&lt;span class=&quot;red&quot;&gt;预约报名&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;开班时间：&lt;span class=&quot;red&quot;&gt;2016-05-10&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a class=&quot;right&quot; href=&quot;#&quot;&gt;&lt;span&gt;开班盛况&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;开班时间：&lt;span&gt;2016-03-16&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="相对定位与绝对定位"><a href="#相对定位与绝对定位" class="headerlink" title="相对定位与绝对定位"></a>相对定位与绝对定位</h2><p>定位：定位指的是将指定的元素放到页面的任意位置，通过定位可以任意的摆放元素。通过position属性来设置元素的定位</p><p>可选值：</p><ul><li><p>static：默认值，元素没有开启定位</p></li><li><p>relative：开启元素的相对定位</p><p>当开启了元素的相对定位以后，而不设置偏移量时，元素不会发生了变化。相对定位是相对于元素在文档流中原来的位置进行定位。相对定位的元素不会脱离文档流。相对定位会使元素提升一个层级。相对定位不会改变元素的性质，块还是块，内联还是内联。</p><p>通常偏移量只需要使用两个就可以对一个元素进行定位。</p><p><img src="/2019/05/15/HTML-CSS基础/30.png" alt></p></li><li><p>absolute：开启元素的绝对定位</p><p>开启绝对定位，会使元素脱离文档流。开启绝对定位以后，如果不设置偏移量，则元素的位置不会发生变化。绝对定位是相对于离他最近的开启了定位的祖先元素进行定位的（一般情况，开启了子元素的绝对定位都会同时开启父元素的相对定位），如果所有的祖先元素都没有开启定位，则会相对于浏览器窗口进行定位。绝对定位会使元素提升一个层级。绝对定位会改变元素的性质，内联元素变成块元素，块元素的宽度和高度默认都被内容撑开。</p></li><li><p>fixed：开启元素的固定定位（也是绝对定位的一种）</p><p>固定定位是一种绝对定位，它的大部分特点和绝对定位一样。不同的是固定定位永远都会相对于浏览器窗口进行定位，固定定位会固定在浏览器窗口某个位置，不会随滚动条滚动。IE6不支持固定定位。</p><p><img src="/2019/05/15/HTML-CSS基础/31.png" alt></p></li></ul><h2 id="元素层级"><a href="#元素层级" class="headerlink" title="元素层级"></a>元素层级</h2><p>如果定位元素的层级是一样的，则下边的元素会盖住上边的，通过z-index属性可以用来设置元素的层级，可以为z-index指定一个正整数作为值，该值将会作为当前元素的层级。层级越高，越优先显示。对于没有开启定位的元素不能使用z-index。父元素的层级永远盖不住子元素的层级。</p><p><img src="/2019/05/15/HTML-CSS基础/32.png" alt></p><h2 id="透明背景"><a href="#透明背景" class="headerlink" title="透明背景"></a>透明背景</h2><p>opacity可以用来设置元素背景的透明，它需要一个0~1之间的值，0表示全透明，1表示完全不透明，0.5表示半透明。opacity属性在IE8及以下的浏览器中不支持，IE8及以下的浏览器需要使用如下属性代替alpha(opacity=透明度)。透明度，需要一个0~100之间的值，0表示完全透明，100表示完全不透明，50为半透明。</p><p><img src="/2019/05/15/HTML-CSS基础/33.png" alt></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><code>background-color:red;</code></p><p>使用<code>background-image:url(相对路径);</code>来设置背景图片，如果</p><p>​    背景图片大于元素，默认会显示图片的左上角</p><p>​    背景图片和元素一样大，则会将背景图片全部显示</p><p>​    背景图小于元素大小，则会默认将背景图片平铺以充满元素</p><p>可以同时为一个元素指定背景颜色和背景图片，这样背景颜色将会作为背景图片的底色。</p><p>用<code>background-repeat:repeat;</code>来设置背景图片的重复方式，可选值：</p><ul><li>repeat：默认值，背景图片会双向重复（平铺）</li><li>no-repeat：背景图片不会重复，有多大就显示多大</li><li>repeat-x：背景图片沿水平方向重复</li><li>repeat-y：背景图片沿垂直方向重复</li></ul><p><img src="/2019/05/15/HTML-CSS基础/34.png" alt></p><p>用<code>background-position：center center；</code>来设置背景图片的位置（九宫格）用right、left、center、top、bottom。第一个值是左右，第二个值是上下。如果只给出一个值，则第二个值默认值是center。也可以直接指定两个偏移量，第一个值水平偏移量，第二个是垂直偏移量。如果是正值就向右或下偏移，如果是负值就向左或上偏移。</p><p><img src="/2019/05/15/HTML-CSS基础/35.png" alt></p><p>用<code>background-attachment:fixed;</code>来设置背景图片是否随页面一起滚动，可选值：</p><ul><li>scroll：默认值，背景图片随着窗口滚动</li><li>fixed：背景图片会固定在某一位置，不随页面滚动</li></ul><p><img src="/2019/05/15/HTML-CSS基础/36.png" alt></p><p>不随窗口滚动的图片，我们一般都是设置给body，而不设置给其他元素。</p><h2 id="按钮练习"><a href="#按钮练习" class="headerlink" title="按钮练习"></a>按钮练习</h2><p>产生闪烁的原因：背景图片是以外部资源加载进网页的，浏览器没加载一个外部资源就需要单独的发送一次请求，但是我们外部资源并不是同时加载，浏览器会在资源被使用采取才去加载资源。由于加载图片需要一定时间，所以在加载和显示过程会有一段时间，背景图片无法显示，导致出现闪烁的情况。</p><p>解决方法：通过将三张图片整合到一张图片上，这样就可以同时将三张图片一起加载，就不会出现闪烁问题，再用background-position来切换要显示的图片的位置，这种技术叫做图片整合技术（css-sprite）。</p><p>整合技术优点：</p><ul><li>将多个图片整合成一张图片里，浏览器只需要发送一次请求，可以同时加载多个图片，提高访问效率，提高了用户体验。</li><li>将多个图片整合为一张图片，减小了图片的总大小，提高请求的速度，增加了用户体验。</li></ul><p><img src="/2019/05/15/HTML-CSS基础/37.png" alt></p><p>背景简写方式</p><p><code>background: red url() center center no-repeat fixed;</code></p><p>没有顺序要求，也没有数量要求，不写就代表默认值。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>通过<code>border-spacing:0px</code>属性来设置table与td边框之间距离。</p><p>通过<code>border-collapse：collapse；</code>来设置表格边框合并。</p><p>设置了边框合并，则border-spacing自动失效。<img src="/2019/05/15/HTML-CSS基础/38.png" alt></p><p>在一些情况下表格是非常长的，这时就需要将表格分为三个部分，表头，表格主体，表格底部。thead、tbody、tfoot来区分表格的不同部分，他们都是table的子标签，都需要直接写到table中，tr需要写到这些标签中，并且thead中内容永远会显示到表格头部，tbody中内容永远都会显示在表格的底部，tfoot中的内容永远都会显示在表格底部。</p><p>如果表格中没有写tbody，浏览器会自动在表格中添加tbody，并且将所有的tr都放到tbody中，所以注意tr并不是table的子元素，而是tbody的子元素，通过table &gt; tr 无法选中进行，需要通过tbody &gt; tr 来选择设置。</p><h2 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h2><p>表格的列数由td最多的决定，表格可以嵌套，可以在td中放置一个表格。<img src="/2019/05/15/HTML-CSS基础/39.png" alt></p><p>已经被淘汰，不易维护。</p><h2 id="clearfix"><a href="#clearfix" class="headerlink" title="clearfix"></a>clearfix</h2><p>子元素和父元素相邻的垂直外边距会发生重叠，子元素的外边距会传递给父元素。使用空的table标签可以隔离父元素的外边距，阻止外边距的重叠。</p><p>即可解决高度塌陷，又可确保父元素和子元素的垂直外边距不会重叠</p><p><img src="/2019/05/15/HTML-CSS基础/40.png" alt></p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>使用 <code>&lt;form&gt; &lt;/form&gt;</code> 标签来创建一个表单<br>表单中必须要有两个属性 action和method，<br>action表示提交单到服务器中的地址 method 。</p><p>用户填写的消息会附在url地址的后边以查询字符串的形式发送给服务器url地址？查询字符串</p><p>格式：属性名=属性值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">用户名&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;admin&quot;&gt;</span><br><span class="line">密码&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;</span><br><span class="line">单选按钮：</span><br><span class="line">性别&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;man&quot; /&gt;男</span><br><span class="line">&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;woman&quot; /&gt;女</span><br><span class="line">多选框：</span><br><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;zq&quot;&gt;足球</span><br><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;ymq&quot;&gt;羽毛球</span><br><span class="line">&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;ppq&quot;&gt;乒乓球</span><br><span class="line">下拉列表：</span><br><span class="line">&lt;select name=&quot;char&quot;&gt;</span><br><span class="line">&lt;optgroup label=&quot;前两个&quot;&gt;</span><br><span class="line">&lt;option value=&quot;A&quot;&gt;a&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;B&quot; selected=&quot;selected&quot;&gt;b&lt;/option&gt;</span><br><span class="line">&lt;/optgroup&gt;</span><br><span class="line">&lt;optgroup label=&quot;后两个&quot;&gt;</span><br><span class="line">&lt;option value=&quot;C&quot;&gt;c&lt;/option&gt;</span><br><span class="line">&lt;option value=&quot;D&quot;&gt;d&lt;/option&gt;</span><br><span class="line">&lt;/optgroup&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">如果希望在单选框中或多选框中指定默认选项，则可以在希望选中的项中添加checked=&quot;checked&quot;属性。而在下拉列表option中添加selected=&quot;selected&quot;来设置默认选中项。在select添加一个multiple=&quot;multiple&quot;,则下拉列表变成一个多选的下拉列表。</span><br></pre></td></tr></table></figure><p>在select中可以使用optgroup对选项进行分组，可以通过lable属性来指定分组的名字。</p><p><code>&lt;label for=&quot;id中的值&quot;&gt;</code>文字<code>&lt;/label&gt;</code>用来设置点击文字就跳到该选项框中。</p><p>fieldset 、legend  、label<br>• fieldset 用来为表单项进行分组。<br>• legend 用于指定每组的名字。<br>• label 标签用来为表单项定义描述文字。</p><p><img src="/2019/05/15/HTML-CSS基础/41.png" alt></p><h2 id="框架集"><a href="#框架集" class="headerlink" title="框架集"></a>框架集</h2><p>框架集和内联框架的作用类似，都是用于在一个页面中引入其他的外部的页面，框架集可以同时引入多个页面，而内联框架只能引入一个，在h5标准中，推荐使用框架集，而不使用内联框架   。使用frameset来创建一个框架集，注意frameset不能和body出现在同一个页面中，所以要使用框架集，页面中就不可以使用body标签。</p><p>属性：</p><ul><li><p>rows：指定框架集中的所有的框架，一行一行的排列</p></li><li><p>cols：指定框架集中所有的页面，一列一列的排列</p><p>这两个属性frameset必须选择一个，并且需要在属性中指定每一部分所占的大小。</p></li></ul><p>franeset和iframe一样，它里边的内容都不会被搜索引擎所检索，所以如果使用框架集则意味着页面中不能有自己的内容，只能引入其他页面，而我们每单独加载一个页面，浏览器都需要重新发送一次请求，引入几个页面就需要发送几次请求</p><p><img src="/2019/05/15/HTML-CSS基础/42.png" alt></p><h2 id="IE6中png修复"><a href="#IE6中png修复" class="headerlink" title="IE6中png修复"></a>IE6中png修复</h2><p>在IE6中对图片格式png24，则会导致透明度效果无法正常显示</p><p>解决方法：</p><ol><li>可以使用png8来代替png24，即可解决问题，但是使用png8来代替png24以后，图片的清晰度会有所下降。</li><li>使用Javascript来解决问题，需要向页面中引入一个外部的Javascript文件然后再写一个简单的JS代码，来处理该问题。</li></ol><p>有一些情况，有一些特殊的代码我们只需要在某些特殊浏览器中执行，而其他的浏览器中不需要执行，这时就可以使用CSS Hack来解决该问题，CSS Hack实际上指的是一个特殊的代码，这段代码只在某些浏览器中可以识别，而其它浏览器不能识别，通过这种方式，来为一些浏览器设置特殊的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">条件HACK只对IE浏览器有效，其他浏览器都会将它识别为注释，IE10及以上的浏览器已经不支持这种方式。</span><br><span class="line">&lt;!--[if IE 6]&gt;</span><br><span class="line">.......</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><h2 id="属性级HACK"><a href="#属性级HACK" class="headerlink" title="属性级HACK"></a>属性级HACK</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.body&#123;</span><br><span class="line">    background-color:red;</span><br><span class="line">    /*在样式前添加一个下划线，则该样式只有IE6及以下的浏览器才可以识别*/</span><br><span class="line">    _background-color:yellow;</span><br><span class="line">    /*在样式前添加一个*的样式，只有在IE7及以下的浏览器才能识别*/</span><br><span class="line">    *background-color:blue;</span><br><span class="line">    /**/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CSS Hack一般情况下不使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h2&gt;&lt;h2 id=&quot;软件架构&quot;&gt;&lt;a href=&quot;#软件架构&quot; class=&quot;headerlink&quot; title=&quot;软件架构&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="html+css" scheme="https://smallpotatody.github.io/categories/html-css/"/>
    
    
      <category term="html+css" scheme="https://smallpotatody.github.io/tags/html-css/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式复习</title>
    <link href="https://smallpotatody.github.io/2019/04/26/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%A4%8D%E4%B9%A0/"/>
    <id>https://smallpotatody.github.io/2019/04/26/嵌入式复习/</id>
    <published>2019-04-26T03:00:43.000Z</published>
    <updated>2019-04-28T04:51:54.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p><strong>嵌入式系统概念：</strong>以应用为中心，以计算机为基础，软件、硬件可裁剪，功能、可靠性、成本、体积、功耗严格要求的专用计算机系统（国内）；用于控制、监控或辅助操作机器和设备的装置（IEEE）；</p><p><strong>嵌入式发展阶段：</strong>无操作系统阶段、简单操作系统阶段、实时操作系统阶段、面向Internet阶段；</p><p><strong>嵌入式应用领域：</strong>工业控制、交通管理、信息家电、家庭智能管理、网络及电子商务、环境监测和机器人等方面。</p><p><strong>嵌入式技术的发展趋势：</strong></p><ol><li><p>嵌入式应用软件的开发需要强大的开发工具和操作系统的支持；</p></li><li><p>联网成为必然趋势；</p></li><li><p>精简系统内核、算法，设备实现小尺寸、微功耗和低成本；</p></li><li><p>提供精巧的多媒体人机界面；</p><p>嵌入式系统的基本组成：</p></li></ol><p><img src="/2019/04/26/嵌入式复习/1.png" alt></p><p><img src="/2019/04/26/嵌入式复习/2.png" alt></p><p><strong>嵌入式系统的重要特征：</strong></p><ol><li><p>系统内核小</p></li><li><p>专用性强</p></li><li><p>系统精简和高实时性操作系统</p></li><li><p>高效率的设计</p></li><li><p>创新性和有效性</p></li><li><p>嵌入式软件开发走向标准化</p></li><li><p>嵌入式系统开发工具和环境</p></li></ol><p><strong>嵌入式系统的硬件组成：</strong></p><p>嵌入式系统基本硬件架构主要包括有处理器、外围电路及接口和外部设备三大部分。其中外围电路一般有时钟、复位电路、程序存储器、数据存储器和电源模块等部件组成；</p><p><img src="/2019/04/26/嵌入式复习/3.png" alt></p><p><strong>嵌入式处理器分类：</strong></p><p>​     嵌入式微控制器（MCU）：主要特点：单片化，体积大大减小，功耗和成本低、可靠性提高。</p><p>​      嵌入式DSP处理器（DSP）：专门用于信号处理方面的处理器，具有在系统结构和指令算法方面进行了特殊设计，执行DSP算法，编译效率较高，指令执行速度也很快。</p><p>​      嵌入式微处理器（MPU）：只保留和嵌入式应用紧密相关的功能硬件，去除冗余部分，体积小、重量轻、成本低、可靠性高的优点。</p><p>​      嵌入式片上系统（System On Chip）：成功实现了软/硬件无缝结合。可以直接在处理器片内嵌入操作系统的代码模块。可以用VHDL等硬件描述语言进行系统设计。只需要使用精确的编程语言，综合时序设计可直接在器件库中调用各种通用处理器标准。</p><p><img src="http://ww1.sinaimg.cn/large/005zgLb3gy1g2fuk0jeq3j30x50l0gmb.jpg" alt></p><p><strong>嵌入式系统好处：</strong>就是屏蔽了底层硬件的差别，给上层应用提供统一的接口，并管理进程调度和资源（如<strong><strong>CPU</strong></strong>时间、内存）分配等。</p><p><strong>主要有实时系统、分时系统（非实时系统）和顺序执行系统。</strong></p><p>（1）实时操作系统：系统内有多个程序运行，每个程序有不同的优先级，只有最高优先级的任务才能占有CPU的控制权。VXworks、UC/OS</p><p>（2）分时操作系统：系统内同时可以有多个程序运行，把CPU的时间分按顺序分成若干片，每个时间片内执行不同的程序，如UNIX，windows。</p><p>（3）顺序执行系统：系统内只含有一个程序，独占CPU的运行时间，按语句顺序执行该程序，直至执行完毕，另一程序才能启动运行。如DOS操作系统</p><p><strong>实时性：</strong></p><p>它的正确性不仅与系统的逻辑正确性相关，而且与系统的响应时间相关。</p><p>具有强(硬）实时特点的嵌入式操作系统</p><p>​      系统在指定的时间内未能实现某个确定的任务，会导致系统的全面失败，则被称为硬（强）实时系统。硬实时系统，其系统响应时间在毫秒或微秒级。一个硬实时系统通常在硬件上需要添加专门用于时间和优先级管理的控制芯片，uc/os和VxWorks是典型的实时操作系统。</p><p>具有弱（软）实时特点的嵌入式操作系统</p><p>​      在软实时系统中，虽然响应时间同样重要，但是超时却不会发生致命的错误。软实时系统则主要在软件方面通过编程实现现实的管理。比如Windows CE、uCLinux是一个多任务分时系统。一般软实时系统，其系统响应时间在毫秒或几秒的数量级上，其实时性的要求比强实时系统要差一些（电子菜谱的查询）。</p><p><strong>第一章：</strong></p><ol><li><strong>在日常生活中，你接触过哪些嵌入式产品？他们都有些什么功能?</strong></li></ol><p><strong>答：数字电视、手持通信、智能玩具。</strong></p><ol><li><strong>嵌入式硬实时操作系统与软实时操作系统的区别是什么？</strong></li></ol><p><strong>答：硬实时操作系统的系统在指定的时间内未能实现某个确定的任务，会导致系统的全面失败，一个硬实时系统通常在硬件上需要添加专门用于时间和优先级管理的控制芯片，响应时间在毫秒或微秒级上。在软实时系统中，虽然响应时间同样重要，但是超时却不会发生致命的错误。软实时系统则主要在软件方面通过编程实现现实的管理，系统响应时间在毫秒或几秒的数量级上</strong></p><ol><li><strong>嵌入式处理器是如何分类的？</strong></li></ol><p><strong>答：嵌入式微控制器（MCU）、嵌入式DSP处理器（DSP）、嵌入式微处理器（MPU）、嵌入式片上系统（System On Chip）。</strong></p><ol><li><strong>嵌入式操作系统的作用是什么？</strong></li></ol><p><strong>答：屏蔽了底层硬件的差别，给上层应用提供统一的接口，并管理进程调度和资源（如CPU**</strong>时间内存）分配等。**</p><ol><li><strong>交叉开发的概念。</strong></li></ol><p><strong>答：在一台通用计算机上进行软件的编辑、编译，然后下载到嵌入式系统中运行调试。</strong></p><ol><li><strong>主流的操作系统的特点</strong></li></ol><p><strong>答：windows：用户多；Linux：开源，免费；</strong></p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p><strong>嵌入式系统的硬件基本组成</strong></p><p>嵌入式系统的硬件是以嵌入式微处理器为核心，主要由嵌入式微处理器、总线、存储器以及I/O接口和设备组成。</p><p><strong>嵌入式微处理器的体系结构</strong></p><p><img src="/2019/04/26/嵌入式复习/2_4.png" alt>目前使用冯．诺依曼结构的CPU和微控制器品种有很多，例如Intel公司的8086系列及其他CPU，ARM公司的ARM7、MIPS公司MIPS处理器等。</p><p>目前使用哈佛结构的CPU和微控制器品种有很多，除DSP处理器外，还有摩托罗拉公司的MC68系列、Zilog公司的Z8系、ATMEL公司的AVR系列和ARM公司的ARM9、ARM10和ARM11等。</p><p><img src="/2019/04/26/嵌入式复习/2_5.png" alt></p><p><strong>总线</strong></p><ul><li><p>片内总线：与嵌入式微处理器集成在一起（如：AMBA、AVALON、OCP、ISHBONE等）。</p></li><li><p>片外总线：集成在嵌入式微处理器内或外接芯片扩展上，用于连接外部设备。</p><p><em>片内总线的选择取决于CPU core；片外总线的选择取决与应用；</em></p></li></ul><p><strong>存储器</strong></p><p>片内存储器:存储容量小、速度快、价格较高</p><p>可以做主存的存储器有：</p><p>​              ROM类：Nor Flash、EPROM、E2PROM、PROM等；</p><p>​              RAM类：SRAM、DRAM、SDRAM等；</p><p>外存：容量大、成本低</p><p> 在嵌入式系统中常用的外存有：</p><p>​               NandFlash</p><p>​               DOC（Disk On Chip）</p><p>​               CF（Compact Flash）</p><p>​               SD（Secure Digital）</p><p>​               MMC（Multi MediaCard）等</p><p>SRAM速度快、价格贵；</p><p>DRAM速度较SRAM慢、价格便宜；</p><p> NOR Flash具有随机存储速度快、电压低、功耗低、稳定性高等特点。</p><p>NandFlash具有容量大、回写速度快、芯片面积小等特点，主要用于外存。</p><p><strong>输入/输出接口和设备</strong></p><p>输入/输出接口主要有中断控制器、DMA、串行和并行接口等，设备主要有定时器（Timers）、计数器（counters）、看门狗（watchdog timers）、RTC、UARTs、PWM（Pulse width modulator）、AD/DA、显示器、键盘和网络等。</p><p><strong>嵌入式处理器分类</strong></p><p>按用途来分,嵌入式微处理器可以分为嵌入式DSP和通用的嵌入式微处理器两种；</p><p>在最普通的情况下，嵌入式微处理器包括：</p><p>片内存储器：部分嵌入式微处理器</p><p>外部存储器的控制器，外设接口(串口，并口)</p><p>LCD控制器：面向终端类应用的嵌入式微处理器</p><p>中断控制器，DMA控制器，协处理器</p><p>定时器，A/D、D/A转换器</p><p>多媒体加速器：当高级图形功能需要时</p><p>总线</p><p>其他标准接口或外设</p><p><strong>流水线</strong></p><p>通常采用单周期执行指令，可能导致比较长的流水线</p><p>流水线的概念：流水线，亦称管线，是现代计算机处理器中必不可少的部分，是指将计算机指令处理过程拆分为多个步骤，并通过多个硬件处理单元并执行来加快指令执行速度。</p><p><strong>嵌入式微处理器的功耗管理</strong></p><ul><li>降低工作电压</li><li>提供不同的时钟频率</li><li>关闭暂时不使用的功能块</li></ul><p><strong>提供功耗管理机制</strong> </p><p>运行模式（Running Mode）：处理器处于全速运行状态下。</p><p>待命模式（Standby Mode）：处理器不执行指令，所有存储的信息是可用的，处理器能在几个周期内返回运行模式。</p><p>时钟关闭模式（clock-off mode）：时钟完全停止，要退出这个模式系统需要重新启动。</p><p>影响功耗的其他因素还有总线和存储器的类型大小</p><p> ARM(Advanced RISC Machine)是专门从事基于RISC技术芯片设计开发的公司，主要出售芯片设计技术的授权，作为知识产权供应商，本身不直接从事芯片生产，靠转让设计许可由合作公司生产各具特色的芯片，半导体生产商从ARM公司购买其设计的ARM微处理器核，根据各自不同的应用领域，加入适当的外围电路，从而形成自己的ARM微处理器芯片进入市场。</p><p>ARM内核是一种32位RISC微处理器，具有功耗低、性价比高、代码密度高等三大特色。</p><p><strong>什么是Thumb指令？</strong></p><p>​       Thumb指令集可以看作是ARM指令压缩形式的子集，它是为减小代码量而提出，具有16bit的代码密度。</p><p><strong>什么是Thumb-2指令？</strong></p><p>​     Thumb-2是16位Thumb指令集的一个超集，在Thumb-2中，16位指令首次与32位指令并存，结果在Thumb状态下可以做的事情丰富了许多。</p><p>‘T’是Thumb指令或者Thumb-2指令；</p><p>‘E’提供DSP能力</p><p>‘J’增加了Jazelle扩展以支持Java加速技术</p><p><strong>数据类型</strong></p><ul><li>字节型类型（Byte）：数据宽度为8bits</li><li>半字数据类型（HalfWord）：数据宽度为16bits，存取式必须是以2字节对齐方式</li><li>字数据类型（Word）：数据宽度为32bits，存取时必须以4字节对齐的方式</li></ul><p>char：1</p><p>short：2</p><p>int：4</p><p>long：4</p><p>float：4</p><p>double：8</p><p><strong>什么叫字节对齐？</strong><br>   如果一个数据是以能被4或者2整除的地址开始的连续存储，那么它就是字节对齐，否则就是非字节对齐。</p><p><strong>为什么必须字节对齐？</strong></p><p>原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。如有些只能访问偶地址，有些只能访问4的倍数地址。字节对齐存储可提高CPU效率</p><p><strong>7种CPU模式</strong></p><p><img src="/2019/04/26/嵌入式复习/2_1.png" alt></p><p><img src="/2019/04/26/嵌入式复习/2_2.png" alt></p><p><strong>处理器工作状态：</strong></p><ul><li><p>ARM:32位，执行字对准的ARM指令（从能被4整除的存储器地址一次取4字节arm指令）</p></li><li><p>Thumb:16位，执行半字对准的Thumb指令（从能被2整除的存储器地址一次取2字节Thumb指令）</p><p>ARM和Thumb之间状态的切换不影响处理器的模式或寄存器的内容</p><p><strong>处理器为什么要有两种状态？</strong></p><p>在保证处理器性能的同时，更少的占用内存，更低的功耗</p></li></ul><p>ARM处理器有37个寄存器</p><p> 31个通用寄存器：程序计数器、堆栈及其他通用寄存器；6个状态寄存器</p><p>R8-R12各有两组物理寄存器：一组为FIQ模式，另一组是除FIQ以外的其他模式。</p><p>R13-R14各有6个分组的物理寄存器，一个用于用户模式和系统模式，其他5个分别用于5种异常模式。访问时需要指定它们的模式，如：R13_＜mode＞，R14_＜mode＞；其中：＜mode＞可以从usr、svc、abt、und、irq和fiq六种模式中选取一个</p><p><strong>程序状态寄存器</strong></p><p><img src="/2019/04/26/嵌入式复习/2_3.png" alt></p><p><strong>异常</strong></p><p>是由内部或者外部原因引起的，当异常发生时CPU将暂停执行当前指令自动到指定的向量地址读取指令并且执行。</p><p><img src="/2019/04/26/嵌入式复习/2_6.png" alt></p><p><img src="/2019/04/26/嵌入式复习/2_7.png" alt></p><p><img src="/2019/04/26/嵌入式复习/2_8.png" alt></p><p><strong>内存和I/O</strong></p><p>ARM的寻址空间是线性的地址空间，2^32=4G</p><p>ARM支持大端和小端的内存数据方式</p><p><img src="/2019/04/26/嵌入式复习/2_9.png" alt></p><p><img src="/2019/04/26/嵌入式复习/2_10.png" alt></p><p><img src="/2019/04/26/嵌入式复习/2_11.png" alt></p><p><strong>总线宽度、频率与总线带宽之间的关系</strong></p><p>答：总线带宽=（总线宽度/8）总线频率</p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p><img src="/2019/04/26/嵌入式复习/3_1.png" alt></p><ol><li><p>驱动层BSP</p><ul><li><p>BSP的概念：BSP是板级支持包，是介于主板硬件和操作系统之间的一层，属于操作系统的一部分，主要目的是为了支持操作系统，使之能够更好的运行与硬件主板。</p><p><strong>BSP对于不同的操作系统有不同的形式</strong></p></li></ul></li><li><p>操作系统层OS</p><ul><li>操作系统功能简单来说就是隐藏硬件细节，而只提供给应用程序开发人员一个个抽象的接口。</li><li>操作系统层包括嵌入式内核、嵌入式TCP/IP网络系统、嵌入式文件系统、嵌入式GUI系统和电源管理等部分。其中嵌入式内核是基础和必备的部分，其他部分要根据嵌入式系统的需要来确定。</li><li><strong>操作系统负责确定可在CPU上执行的程序及其执行时间的长短，此功能称为进程调度，调度的方法由操作系统所定的优先策略决定。</strong></li></ul></li><li><p>中间层</p><ul><li>中间层为上层软件提供了设备操作接口。</li></ul></li><li><p>应用层</p><ul><li>应用层软件主要由多个相对独立的应用任务组成。每个应用任务完成特定的工作。</li></ul></li></ol><p><strong>嵌入式软件运行流程：</strong></p><p><img src="/2019/04/26/嵌入式复习/3_2.png" alt></p><ol><li><p>上电复位、板级初始化阶段</p><p>嵌入式系统完成上电复位后完成板级初始化工作。板级初始化程序具有完全的硬件特性，一般采用汇编语言实现。不同的嵌入式系统，板级初始化时要完成的工作具有一定的特殊性，但以下工作一般是必须完成的：</p><ul><li>CPU中堆栈指针寄存器的初始化。</li></ul><ul><li>CPU芯片级的初始化：中断控制器、内存等的初始化。</li></ul></li><li><p>系统引导/升级阶段</p><p>根据需要分别进入系统软件引导阶段或系统升级阶段。通过测试通信端口数据或判断特定开关的方式分别进入不同阶段。</p><ul><li>远程升级：TFTP、FTP、HTTP</li><li>串口本地升级：超级终端、特定升级软件</li></ul></li><li><p>系统初始化阶段</p><p>系统初始化需要按特定顺序进行</p></li><li><p>应用初始化阶段</p><p>进行应用任务的创建，信号量、消息队列的创建和应用相关的其它初始化工作。</p></li><li><p>多任务应用运行阶段</p><p>系统进入多任务状态，操作系统按照已确定的算法进行任务调度，各应用任务分别完成特定功能。</p></li></ol><p><strong>操作系统可以简单的分为通用操作系统和实时操作系统（RTOS）</strong></p><p>实时操作系统就是”在给定时间内提供某种程度的服务，如果在规定的时间内没有得到结果，那整个的系统就是失败”。</p><p>实时操作系统特点：</p><ul><li>多任务</li><li>任务的事件驱动</li><li><p>中断与中断优先级</p><ul><li>异常中断的优先级</li><li>微处理器的异常中断响应过程</li><li>从异常中断处理程序中返回</li></ul></li><li><p>同步与异步</p></li><li>资源与临界资源</li><li>容错与安全</li></ul><p><strong>操作系统体系结构：</strong></p><p>体系结构是操作系统的基础，它定义了硬件与软件的界限、内核与操作系统其它组件的组织关系、系统与应用的接口。</p><p>目前操作系统的体系结构可分为：单块结构（Linux）、层次结构和客户/服务器（微内核）结构。</p><p><img src="/2019/04/26/嵌入式复习/3_3.png" alt></p><p>目前嵌入式操作系统主要采用分层和模块化相结合的结构或微内核结构。</p><p>分层和模块化相结合的结构将操作系统分为硬件无关层、硬件抽象层和硬件相关层，每层在划分功能模块。移植工作便集中在硬件相关层。微内核结构便于扩展。</p><p><img src="/2019/04/26/嵌入式复习/3_4.png" alt></p><p><img src="/2019/04/26/嵌入式复习/3_5.png" alt></p><ol><li><p>嵌入式操作系统的功能</p><p>负责嵌入式系统的全部软、硬件资源的分配、调度，将CPU时钟、I/O、中断等资源封装起来给用户提供一个标准的API接口，供用户调用。由应用程序接口、设备驱动程序接口、设备驱动、操作系统内核等组成。</p></li><li><p>嵌入式内核</p><ul><li>任务管理</li><li>内存管理</li><li>通信、同步和互斥机制</li><li>中断管理</li><li>时间管理任务扩展功能</li></ul></li></ol><p><strong>实时系统的评价指标</strong></p><p>在实时系统中主要有三个指标来衡量系统的实时性，即响应时间（Response Time）、生存时间（Survival Time）、吞吐量（Throughput）。</p><ul><li>响应时间：是计算机识别一个外部时间到作出响应的时间，在控制应用中它是最重要的指标，如果实践部能即时处理，系统可能就会崩溃。<ul><li>任务调度，这是操作系统内核的主要职责之一，它决定该轮到哪个任务运行了,调度是基于任务的优先级。</li></ul></li><li>生存时间：是数据有效等待时间，在这段时间里数据是有效的。</li><li>吞吐量：是在一给定时间内，系统可以处理的事件总数。</li></ul><p><img src="/2019/04/26/嵌入式复习/3_6.png" alt></p><p>非占先式内核的优缺点：</p><ul><li>优点：正在运行着的任务占有CPU，而不必单行被别的任务抢占。</li><li>缺点：其响应高优先级的任务慢。</li></ul><p><img src="/2019/04/26/嵌入式复习/3_7.png" alt></p><p><strong>常见的嵌入式操作系统特点：</strong></p><p>  1.uC/OS-II:公开源代码、代码结构清晰、注释详尽、组织有调理、可移植性好、可裁剪、可固化、抢占式内核、最多可管理60个任务。可用于8位，16/32位单片机或DSP。</p><p>  2.Linux:具有可移植性、一定的稳定性、各种性能的升级能力，开发更容易。开放源代码，不存在黑箱技术。内核小、功能强大、运行稳定、效率高。开放源代码的操作系统易于定制裁剪，在价格上极具竞争力。不支持X86CPU，还可支持其他数十种CPU芯片。有大量的且不断增加的开发工具和开发环境。其内核的结构在网络方面是非常完整的，提供了对多种互联网方式的全面支持。</p><p>  3.Windows  CE:其核心全是由C语言开发，内核提供内存管理、抢先多任务和中断处理功能。具有高度模块化，可在内核基础上添加各种模块，适合作为可裁剪的32位嵌入式操作系统，既适用于工业设备的嵌入式控制模块，也适用于消费类电子产品。其核允许每个进程有256个优先级，采用抢占式优先权调度法。它嚄没有DOS模式，不能运行现有的应用程序，有严格的内存限制，有精简的运行库和API，硬件并不十分标准化。</p><p>  4.VxWorks:具有可靠性、实时性和可裁剪性。支持多种处理器，如:x86、i960、Sun  Sparc、MIPS、PowerPC等。</p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><p><strong>嵌入式系统大致可以分为四个层次：</strong></p><ul><li><p>硬件层</p><p>特点：</p><ul><li>处理器体系结构不统一</li><li>硬件资源通常受限</li><li>外部设备的种类繁多</li><li>有实时性和可靠性要求</li></ul></li><li><p>OEM层</p><ul><li><p>Bootloader的功能：初始化硬件,加载操作系统映像（0S Image ）到内存，然后跳转到操作系统代码去执行。</p></li><li><p>BSP是介于主板硬件和操作系统之间的一层也可以说是属于操作系统的一部分，主要目的是为了支持操作系统使之能够正常地运行于硬件主板上。</p></li><li><p>bootLoader获得操作系统的方式：</p><p>​     方式一:串口、USB(U-BOOT)、以太网下载(E-BOOT)；</p><p>​    方式二：从本地的存储设备例如CF卡和硬盘中读取操作系统映像。</p></li></ul></li><li><p>操作系统层</p><ul><li><p>Windows CE 是一个微内核操作系统。操作系统的基本功能被放在多个独立的进程（EXE）里面实现。在运行的时候，这些进程大致有如下几个：</p><ul><li><p>内核NK. EXE ; </p></li><li><p>图形系统GWES. EXE ;</p></li><li><p>对象存储FILESYS .EXE ; </p></li><li><p>设备管理系统DEVICE .EXE ; </p></li><li><p>服务SERVICES. EXE</p></li></ul></li></ul></li><li><p>应用程序层</p><ul><li>应用程序层位于Windows CE层次结构的最顶层。从系统的角度看，每个应用程序都是Windows CE 中的单独的程。</li><li>在Windows CE中，应用程序与操作系统交互的接口同样是Win32 API <strong>。</strong></li></ul><p><img src="/2019/04/26/嵌入式复习/4_1.png" alt></p><p><strong>进程与线程</strong>：</p><ul><li>进程：进程即是程序的一次动态执行实例。</li><li>线程：线程是Windows CE中最小的可执行单元。</li></ul></li></ul><p>进程与程序的区别：</p><ul><li>进程是动态概念，而程序是静态的概念。</li><li>进程有创建、执行及结束完整的生命周期，而程序只是一个文件。</li><li>一个进程可以对应多个进程，而一个进程只能对应一个程序。</li></ul><p><strong>进程本身不参加系统的调度，也没有有优先级和上下文。真正参加系统调度的是线程，系统只识别和调度线程，每个进程在创建的时候都会创建一个主线程作为该进程默认的执行体。进程只是线程的容器。一个进程可拥有的线程数理论上是没有限制的，只与当前可用的内存有关。系统中同时最多只能有32个进程。</strong></p><p><strong>wince线程的状态</strong></p><p><img src="/2019/04/26/嵌入式复习/4_2.png" alt></p><p><strong>Windows CE开发流程：</strong></p><p><img src="/2019/04/26/嵌入式复习/4_3.png" alt></p><ol><li><p>硬件设计</p><ul><li>自己设计硬件：开发难度大、周期长，需要开发人员有很好的硬件基础。</li><li>从OEM厂商购买：难度最小，周期最短，需要一定的经费，有较好的售后支持。</li></ul></li><li><p>定制操作系统</p></li><li>应用程序开发<ul><li>安装包（像桌面Windows一样）</li><li>作为操作系统的一个组件，打包进入操作系统的运行时映像中。</li></ul></li></ol><p><strong>WinCE开发环境过程</strong></p><ol><li>安装.NET Framework</li><li>安装Platform Builder开发工具和升级包</li><li>安装开发板支持包根据具体的实验箱而定</li><li>建立并编译WinCE系统平台</li><li>定制软件开发工具包（SDK）</li><li>建立eMbedded Visual C++ 4.0开发环境（EVC文件夹）</li><li>安装同步软件</li></ol><p><strong>Windows CE开发中涉及到的工具</strong></p><ol><li>Platform Buider</li></ol><ul><li>功能：<ul><li>可对Windows CE操作系统进行定制、构建、下载、调试及发布；</li><li>可开发简单的基于Windows CE的应用程序；</li></ul></li></ul><ol start="2"><li>Visual Studio</li></ol><ul><li>功能：<ul><li>可编写Windows应用程序、Web应用程序和移动设备应用程序。</li></ul></li></ul><ol start="3"><li>eMbedded Visual C++</li></ol><ul><li><p>功能：</p><ul><li><p>可用C/C++语言来为Windows CE开发应用程序</p><p><em>如果使用EVC4为Windows CE5.0开发应用程序，那么就必须安装EVCSP4</em></p></li></ul></li></ul><ol start="4"><li><p>SDK</p><ul><li>SDK概念：软件开发工具包是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、操作系统等创建应用软件的开发工具的集合。</li><li>功能<ul><li>为某种特定的Windows CE平台开发应用程序，必须安装特定的SDK。</li></ul></li></ul></li><li><p>ACtiveSync</p><ul><li><p>简介：ActiveSync用来连接Windows CE设备和安装桌面Windows的PC机的工具。</p><p>主要功能：</p><ul><li><p>PC机可借助ActiveSync的通信功能查看Windows CE上的文件系统，以及安装软件。</p></li><li><p>对于开发人员，还可使用ActiveSync下载编写的应用程序和进行代码调试。</p></li></ul></li></ul></li></ol><p>依赖关系：对各种软件的安装必须按一定顺序；否则可能导致软件或则软件的部分功能不能使用。</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p>•    <strong>Wince的平台初始化文件 common．<em> 文件、 platform．</em> 文件、project．*文件的作用域；读懂.dat文件的代码，读懂.bib中 memory、modules、files的代码。</strong></p><p><strong>答：common．*文件的作用域是所有的OSDesign，对common．x文件的修改会影响到所有的OSDesign</strong></p><p>  <strong>platform．<em> 文件的作用范围是使用该BSP的OSDesign，因此一般把与硬件相关的配置信息放到platform．</em>文件中；</strong></p><p>  <strong>project．<em> 文件的作用范围仅仅是当前OS Design，一般在poject．</em>文件中只存放与本项目相关的一些配置信息。</strong></p><p><strong>;;创建根目录下子目录Program Files</strong></p><p><strong>root: -Directory (“Program Files”)</strong></p><p><strong>;;创建目录Program Files下一个子目录My Projects</strong></p><p><strong>Directory (“\Program Files”): -Directory (“My Projects”)</strong></p><p><strong>;;复制文件从\Windows\Myproj.exe到\Program Files\My Projects\My Project.exe</strong></p><p><strong>Directory (“\Program Files\My Projects”): -File (“My Project.exe”, “\Windows\My</strong></p><p><strong>proj.exe”)</strong></p><p><strong>;;复制文件从\Windows\control.lnk到\control.lnk</strong></p><p><strong>root: -File (“\control.lnk”, “\Windows\control.lnk”)</strong></p><p><strong>MEMORY</strong></p><p><strong>; Name     Start     Size      Type</strong></p><p><strong>modules</strong>、<strong>files</strong></p><p><strong>模块名称</strong>      <strong>路径</strong>                 <strong>内存块</strong>  <strong>类型</strong></p><p><strong>; @CESYSGEN IF CE_MODULES_DEVICE</strong></p><p><strong>device.exe $(_FLATRELEASEDIR) \device.exe NK SHM</strong></p><p>•    <strong>SDK的概念及作用</strong></p><p><strong>答：SDK是一系列头文件、库文件、文档、平台管理器和运行时库的总称。应用开发人员可使用SDK为某个特定平台开发应用程序。</strong></p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p><strong>Windows CE应用程序开发工具：</strong></p><p>1.Platform Builder</p><p>应用程序将被链接到OS内核中</p><p> 一旦修改代码，必须再重新编译镜像</p><p>容易调试OS内核,不容易调试应用程序</p><p>2.Embedded Visual C++</p><p>易于调试和测试</p><p>必须安装相应的为特定平台开发的SDK，从而开发相应的应用程序</p><p>3.VIsual Studio</p><p>目标平台上需要安装 .NET compact framework</p><p>易于调试和测试</p><p>必须安装相应的为特定平台开发的SDK，从而开发相应的应用程序</p><p>4.Embedded Visual Tools 3.0</p><p><strong>应用程序开发流程：</strong></p><p>1.安装合适的SDk</p><p>2.编写代码和调试</p><p>3.发布应用程序</p><p><strong>两种途径获得SDK：</strong></p><p>1.开发人员可以从微软或者第三方处获得SDK；</p><p>2.开发人员可以通过Platform Builder导出自己的SDK；</p><p><strong>应用程序发布涉及到代码签名和代码打包</strong></p><p><strong>Windows CE应用程序开发，代码的选择：</strong></p><p>1.托管代码：是指使用.NET compact framework开发的程序代码，执行时需要有.NET的运行时环境。</p><p>2.本地代码：是指用C++等高级语言开发的程序代码，可执行文件被编译成与CPU指令集有关的机器码，可以直接运行。</p><p><strong>托管代码主要的优缺点</strong></p><p>优点：与硬件平台无关；与编程语言无关；</p><p>缺点：执行效率低；</p><p><strong>托管代码优缺点与本地代码优缺点互补</strong></p><p><strong>Windows CE的应用编程接口（API）</strong></p><ol><li><p>Win32 API（应用程序接口）</p><p>包括源代码文件（.c/.cpp/.H等）和资源文件（.BMP/.ICO/.CUR/.FON）</p><p>源代码文件经过C/C++编译器编译后形成目标文件；资源文件经过资源编译器编译后形成.RES二进制资源。然后，链接器负责把目标文件、二进制资源及库文件等统一链接，最终形成可执行文件。</p></li><li><p>MFC与ATL</p></li><li><p>Microsoft .NET Framework精简版</p><p><strong>各种编程接口的比较</strong></p><p>资源大小：</p></li></ol><p><img src="/2019/04/26/嵌入式复习/6_1.png" alt></p><p>开发效率和执行时间：</p><p><img src="/2019/04/26/嵌入式复习/6_2.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;嵌入式系统概念：&lt;/strong&gt;以应用为中心，以计算机为基础，软件、硬件可裁剪，功能、可靠性、成本、体积、功耗严格
      
    
    </summary>
    
      <category term="嵌入式" scheme="https://smallpotatody.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
      <category term="嵌入式" scheme="https://smallpotatody.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>用VMware Workstation15安装Ubuntu19.04</title>
    <link href="https://smallpotatody.github.io/2019/04/25/%E7%94%A8VMware-Workstation15%E5%AE%89%E8%A3%85Ubuntu19-04/"/>
    <id>https://smallpotatody.github.io/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/</id>
    <published>2019-04-25T00:50:29.000Z</published>
    <updated>2019-04-25T03:16:36.287Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Ubuntu（友帮拓、优般图、乌班图）是一个以<a href="https://baike.baidu.com/item/%E6%A1%8C%E9%9D%A2" target="_blank" rel="noopener">桌面</a>应用为主的开源GNU/Linux操作系统，Ubuntu 是基于<a href="https://baike.baidu.com/item/Debian" target="_blank" rel="noopener">Debian</a>GNU/<a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>，支持x86、amd64（即x64）和<a href="https://baike.baidu.com/item/ppc/150" target="_blank" rel="noopener">ppc</a>架构，由全球化的专业开发团队（Canonical Ltd）打造的。</p></blockquote><h1 id="1-下载Ubuntu"><a href="#1-下载Ubuntu" class="headerlink" title="1.下载Ubuntu"></a>1.下载Ubuntu</h1><p>ubuntu下载地址：<a href="https://www.ubuntu.com/download/desktop" target="_blank" rel="noopener">官网</a></p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/1.png" alt></p><p>18是LTS版是长期支持（Long Term Support）的缩写。直到2023年四月，免费安全和维护更新。19只提供九个月到2020年1月，根据自己需求选择，我这里选择19。</p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h1><p>我相信大家都应该安装好了自己的Vmware Workstation15，如果没有安装好，可以参考一下我的另一篇博客：<a href="https://smallpotatody.github.io/2019/03/26/VMware-15%E7%A0%B4%E8%A7%A3%E7%89%88/">VMware Workstation pro 15破解版安装</a></p><h2 id="1-双击运行VMware-Workstation-Pro"><a href="#1-双击运行VMware-Workstation-Pro" class="headerlink" title="1.双击运行VMware Workstation Pro"></a>1.双击运行VMware Workstation Pro</h2><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/2.png" alt></p><h2 id="2-创建新的虚拟机"><a href="#2-创建新的虚拟机" class="headerlink" title="2.创建新的虚拟机"></a>2.创建新的虚拟机</h2><p>可以选择典型和自定义，我喜欢个性化，所以就选择了自定义。</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/3.png" alt></p><p>下一步</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/4.png" alt></p><p>选择安装程序光盘映像文件(iso)(M):，点击浏览选择刚刚下载的Ubuntu镜像</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/5.png" alt></p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/6.png" alt></p><p>进行简单的配置用户名和密码</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/7.png" alt></p><p>设置虚拟机名称和安装的位置</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/8.png" alt></p><p>根据自己电脑的CPU来设置处理器数量和内核数量</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/9.png" alt></p><p>设置内存</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/10.png" alt></p><p>默认选择，下一步</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/11.png" alt></p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/12.png" alt></p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/13.png" alt></p><p>创建新虚拟磁盘</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/14.png" alt></p><p>分配磁盘空间大小和选择将虚拟磁盘存储为单个文件</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/15.png" alt></p><p>默认，下一步</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/16.png" alt></p><p>完成</p><h2 id="3-开始安装ubuntu"><a href="#3-开始安装ubuntu" class="headerlink" title="3.开始安装ubuntu"></a>3.开始安装ubuntu</h2><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/18.png" alt></p><p>点击开启此虚拟机</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/19.png" alt></p><p>我们可以先看看，点击Try Ubuntu</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/20.png" alt></p><p>然后关闭重新启动进行安装</p><p>选择语言后进行安装</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/21.png" alt></p><p>直接点击继续</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/22.png" alt></p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/23.png" alt></p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/24.png" alt></p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/25.png" alt></p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/26.png" alt></p><p>简单的配置自己的用户名以及密码</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/27.png" alt></p><p>这个安装时间有点长</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/28.png" alt></p><p>安装完成后重启</p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/29.png" alt></p><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h1><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/30.png" alt></p><p>打开终端输入<code>sudo apt-get update</code></p><p><code>sudo apt-get upgrade</code></p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/31.png" alt></p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/32.png" alt></p><p><img src="/2019/04/25/用VMware-Workstation15安装Ubuntu19-04/33.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Ubuntu（友帮拓、优般图、乌班图）是一个以&lt;a href=&quot;https://baike.baidu.com/item/%E6%A1%8C%E9%9D%A2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;桌面&lt;/a&gt;应用为主的开
      
    
    </summary>
    
      <category term="linux" scheme="https://smallpotatody.github.io/categories/linux/"/>
    
    
      <category term="ubuntu" scheme="https://smallpotatody.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>kali安装中文搜狗输入法</title>
    <link href="https://smallpotatody.github.io/2019/04/21/kali%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    <id>https://smallpotatody.github.io/2019/04/21/kali安装中文搜狗输入法/</id>
    <published>2019-04-21T12:47:08.000Z</published>
    <updated>2019-04-21T13:36:53.723Z</updated>
    
    <content type="html"><![CDATA[<p>我们在使用大多数linux系统时，有些不提供中文输入法，这就导致我们在使用时存在一些困难，毕竟刚接触linux系统，还是图形界面，对我们这些初学Linux的人来说有许多？那么我们要坚持一个不懂就学懂好习惯，去网上查找答案，因为英语不是很好（英语大神请绕道），所以就需要中文输入法；</p><h2 id="kali安装搜狗输入法"><a href="#kali安装搜狗输入法" class="headerlink" title="kali安装搜狗输入法"></a>kali安装搜狗输入法</h2><h3 id="1-修改软件源"><a href="#1-修改软件源" class="headerlink" title="1.修改软件源"></a>1.修改软件源</h3><p><code>leafpad /etc/apt/sources.list</code></p><p><img src="/2019/04/21/kali安装中文搜狗输入法/1.png" alt>)</p><p>或</p><p><code>vim /etc/apt/sources.list</code>键盘输入e</p><p><img src="/2019/04/21/kali安装中文搜狗输入法/2.png" alt></p><p>进入下面界面</p><p><img src="/2019/04/21/kali安装中文搜狗输入法/3.png" alt></p><p>输入i键后，进行编辑，即下方显示“– 插入 –”</p><p><img src="/2019/04/21/kali安装中文搜狗输入法/4.png" alt></p><p>编辑完成后，按ESC键退出，然后再按”:wq”保存并退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#kali官方源</span><br><span class="line">deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">#中科大的源</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali-security kali-current/updates main contrib non-free</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali-security kali-current/updates main contrib non-free</span><br><span class="line">#阿里云源</span><br><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb http://mirrors.aliyun.com/kali-security/ kali-rolling main contrib non-free</span><br><span class="line">deb-src http://mirrors.aliyun.com/kali-security/ kali-rolling main contrib non-free</span><br></pre></td></tr></table></figure><p>从中任意选两个就ok了！</p><h3 id="2-安装fcitx"><a href="#2-安装fcitx" class="headerlink" title="2.安装fcitx"></a>2.安装fcitx</h3><p><code>sudo apt-get install fcitx</code></p><p><img src="/2019/04/21/kali安装中文搜狗输入法/5.png" alt></p><h3 id="3-下载并安装搜狗输入法"><a href="#3-下载并安装搜狗输入法" class="headerlink" title="3.下载并安装搜狗输入法"></a>3.下载并安装搜狗输入法</h3><p><a href="https://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener">搜狗输入法下载地址</a></p><p>根据自己的系统位数来下载搜狗输入法</p><p><img src="/2019/04/21/kali安装中文搜狗输入法/6.png" alt></p><p><img src="/2019/04/21/kali安装中文搜狗输入法/7.png" alt></p><p>切换到下载目录，先直接安装</p><p><code>dpkg -i sogoupinyin_2.2.0.0108_amd64.deb</code></p><p><img src="/2019/04/21/kali安装中文搜狗输入法/8.png" alt></p><p><strong>注意：出现错误时，输入<code>apt-get -f install</code></strong></p><p>安装成功后，桌面上会出现Fcitx和Fcitx配置两个企鹅图标</p><p>点开Fcitx配置，看输入法中是否会出现搜狗拼音，有就成功了，没有就手动导入一下</p><p><img src="/2019/04/21/kali安装中文搜狗输入法/9.png" alt></p><h3 id="4-最后使用搜狗输入法"><a href="#4-最后使用搜狗输入法" class="headerlink" title="4.最后使用搜狗输入法"></a>4.最后使用搜狗输入法</h3><p>重启电脑后，ctrl+空格键变换输入法</p><p>测试结果，有多种皮肤供选择，选择自己觉得最好看的一个作为皮肤</p><p><img src="/2019/04/21/kali安装中文搜狗输入法/10.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在使用大多数linux系统时，有些不提供中文输入法，这就导致我们在使用时存在一些困难，毕竟刚接触linux系统，还是图形界面，对我们这些初学Linux的人来说有许多？那么我们要坚持一个不懂就学懂好习惯，去网上查找答案，因为英语不是很好（英语大神请绕道），所以就需要中文输
      
    
    </summary>
    
      <category term="Linux" scheme="https://smallpotatody.github.io/categories/Linux/"/>
    
    
      <category term="kali" scheme="https://smallpotatody.github.io/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>Git和Node.js重新安装</title>
    <link href="https://smallpotatody.github.io/2019/04/18/Git%E5%92%8CNode-js%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85/"/>
    <id>https://smallpotatody.github.io/2019/04/18/Git和Node-js重新安装/</id>
    <published>2019-04-18T10:30:43.000Z</published>
    <updated>2019-04-18T14:14:38.337Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近误删了一个东西，导致Windows10系统崩溃，好像是把系统引导给搞坏了，看了网上一大堆的方法来拯救，最终还是嫌麻烦，就直接重装系统，那么问题就来了，导致我的Git和Node.js也出现了一些问题，不能直接导出，就很麻烦，然后又去下载这两个东西和安装以及配置。</p><h1 id="1-Git安装教程"><a href="#1-Git安装教程" class="headerlink" title="1.Git安装教程"></a>1.Git安装教程</h1><p>下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git下载地址</a></p><p>开始安装</p><h3 id="第一步：点击next"><a href="#第一步：点击next" class="headerlink" title="第一步：点击next"></a>第一步：点击next</h3><p><img src="/2019/04/18/Git和Node-js重新安装/1.png" alt></p><h3 id="第二步：根据自己想安装软件的位置来选者路径-我这里选择的是D-app-blog-software"><a href="#第二步：根据自己想安装软件的位置来选者路径-我这里选择的是D-app-blog-software" class="headerlink" title="第二步：根据自己想安装软件的位置来选者路径(我这里选择的是D:\app\blog_software)"></a>第二步：根据自己想安装软件的位置来选者路径(我这里选择的是D:\app\blog_software)</h3><p><img src="/2019/04/18/Git和Node-js重新安装/2.png" alt></p><h3 id="第三步：安装配置文件，更具自己需要选择"><a href="#第三步：安装配置文件，更具自己需要选择" class="headerlink" title="第三步：安装配置文件，更具自己需要选择"></a>第三步：安装配置文件，更具自己需要选择</h3><p><img src="/2019/04/18/Git和Node-js重新安装/3.png" alt></p><h3 id="第四步：不创建启动文件夹（勾选Don’t-create-a-Star-Menu-folder）"><a href="#第四步：不创建启动文件夹（勾选Don’t-create-a-Star-Menu-folder）" class="headerlink" title="第四步：不创建启动文件夹（勾选Don’t create a Star Menu folder）"></a>第四步：不创建启动文件夹（勾选Don’t create a Star Menu folder）</h3><p><img src="/2019/04/18/Git和Node-js重新安装/4.png" alt></p><h3 id="第五步：选择默认编辑器"><a href="#第五步：选择默认编辑器" class="headerlink" title="第五步：选择默认编辑器"></a>第五步：选择默认编辑器</h3><p><img src="/2019/04/18/Git和Node-js重新安装/5.png" alt></p><h3 id="第六步：点击Next"><a href="#第六步：点击Next" class="headerlink" title="第六步：点击Next"></a>第六步：点击Next</h3><p><img src="/2019/04/18/Git和Node-js重新安装/6.png" alt></p><h3 id="第七步：使用默认设置就行"><a href="#第七步：使用默认设置就行" class="headerlink" title="第七步：使用默认设置就行"></a>第七步：使用默认设置就行</h3><p><img src="/2019/04/18/Git和Node-js重新安装/7.png" alt></p><h3 id="第八步：默认"><a href="#第八步：默认" class="headerlink" title="第八步：默认"></a>第八步：默认</h3><p><img src="/2019/04/18/Git和Node-js重新安装/8.png" alt></p><h3 id="第九步：在终端模拟器选择页面，默认即可，配置后Git"><a href="#第九步：在终端模拟器选择页面，默认即可，配置后Git" class="headerlink" title="第九步：在终端模拟器选择页面，默认即可，配置后Git"></a>第九步：在终端模拟器选择页面，默认即可，配置后Git</h3><p><img src="/2019/04/18/Git和Node-js重新安装/9.png" alt></p><h3 id="第十步：最后配置Git额外选择默认安装"><a href="#第十步：最后配置Git额外选择默认安装" class="headerlink" title="第十步：最后配置Git额外选择默认安装"></a>第十步：最后配置Git额外选择默认安装</h3><p><img src="/2019/04/18/Git和Node-js重新安装/10.png" alt></p><h3 id="第十一步：安装完成"><a href="#第十一步：安装完成" class="headerlink" title="第十一步：安装完成"></a>第十一步：安装完成</h3><p><img src="/2019/04/18/Git和Node-js重新安装/11.png" alt></p><p><strong>检验 </strong>：</p><p><img src="/2019/04/18/Git和Node-js重新安装/12.png" alt></p><p><img src="/2019/04/18/Git和Node-js重新安装/13.png" alt></p><h1 id="2-Node-js安装"><a href="#2-Node-js安装" class="headerlink" title="2.Node.js安装"></a>2.Node.js安装</h1><p>下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js官网下载地址</a></p><h3 id="第一步：下载完成后，开始安装"><a href="#第一步：下载完成后，开始安装" class="headerlink" title="第一步：下载完成后，开始安装"></a>第一步：下载完成后，开始安装</h3><p><img src="/2019/04/18/Git和Node-js重新安装/2_1.png" alt></p><h3 id="第二步：接受协议"><a href="#第二步：接受协议" class="headerlink" title="第二步：接受协议"></a>第二步：接受协议</h3><p><img src="/2019/04/18/Git和Node-js重新安装/2_2.png" alt></p><h3 id="第三步：根据自己要安装的地方选择安装目录-我这里选择D-app-blog-software-Node-js路径下"><a href="#第三步：根据自己要安装的地方选择安装目录-我这里选择D-app-blog-software-Node-js路径下" class="headerlink" title="第三步：根据自己要安装的地方选择安装目录(我这里选择D:\app\blog_software\Node.js路径下)"></a>第三步：根据自己要安装的地方选择安装目录(我这里选择D:\app\blog_software\Node.js路径下)</h3><p><img src="/2019/04/18/Git和Node-js重新安装/2_3.png" alt></p><h3 id="第四步：选择安装项，一般默认"><a href="#第四步：选择安装项，一般默认" class="headerlink" title="第四步：选择安装项，一般默认"></a>第四步：选择安装项，一般默认</h3><p><img src="/2019/04/18/Git和Node-js重新安装/2_4.png" alt></p><h3 id="第五步：点击“Install”按钮，开始安装"><a href="#第五步：点击“Install”按钮，开始安装" class="headerlink" title="第五步：点击“Install”按钮，开始安装"></a>第五步：点击“Install”按钮，开始安装</h3><p><img src="/2019/04/18/Git和Node-js重新安装/2_7.png" alt></p><h3 id="第六步：过程"><a href="#第六步：过程" class="headerlink" title="第六步：过程"></a>第六步：过程</h3><p><img src="/2019/04/18/Git和Node-js重新安装/2_5.png" alt></p><h3 id="完成安装"><a href="#完成安装" class="headerlink" title="完成安装"></a>完成安装</h3><p><img src="/2019/04/18/Git和Node-js重新安装/2_6.png" alt></p><p><strong>检验</strong>：</p><p>　1.node -v 查看 node 版本</p><p>​    2.npm -v 查看 npm 版本</p><p><img src="/2019/04/18/Git和Node-js重新安装/2_8.png" alt></p><h1 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3.环境配置"></a>3.环境配置</h1><p>说明：这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\Users\用户名\AppData\Roaming\npm】路径中，占C盘空间。<br>例如：我希望将全模块所在路径和缓存路径放在我node.js安装的文件夹中，则在我安装的文件夹【D:\app\blog_software\Node.js】下创建两个文件夹【node_global】及【node_cache】如下图：</p><p><img src="/2019/04/18/Git和Node-js重新安装/15.png" alt></p><p>创建完两个空文件夹之后，打开cmd命令窗口，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;D:\app\blog_software\Node.js\node_global&quot;</span><br><span class="line">npm config set prefix &quot;D:\app\blog_software\Node.js\node_cache&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/18/Git和Node-js重新安装/14.png" alt></p><p>接下来设置环境变量，“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”</p><p><img src="/2019/04/18/Git和Node-js重新安装/16.png" alt></p><p>在用户变量里选择Path，点击新建，在弹出的框中点击新建，然后在其中添加node_modules文件夹的位置。</p><p><img src="/2019/04/18/Git和Node-js重新安装/17.png" alt></p><p><strong>完成所有的操作，可以在任意地方测试</strong></p><p><img src="/2019/04/18/Git和Node-js重新安装/18.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于最近误删了一个东西，导致Windows10系统崩溃，好像是把系统引导给搞坏了，看了网上一大堆的方法来拯救，最终还是嫌麻烦，就直接重装系统，那么问题就来了，导致我的Git和Node.js也出现了一些问题，不能直接导出，就很麻烦，然后又去下载这两个东西和安装以及配置。&lt;/p
      
    
    </summary>
    
      <category term="Node.js" scheme="https://smallpotatody.github.io/categories/Node-js/"/>
    
    
      <category term="Git" scheme="https://smallpotatody.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>WebStorm的安装与破解</title>
    <link href="https://smallpotatody.github.io/2019/04/09/WebStorm%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%A0%B4%E8%A7%A3/"/>
    <id>https://smallpotatody.github.io/2019/04/09/WebStorm的安装与破解/</id>
    <published>2019-04-09T10:32:22.000Z</published>
    <updated>2019-04-09T13:17:42.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-WebStorm介绍"><a href="#1-WebStorm介绍" class="headerlink" title="1.WebStorm介绍"></a>1.WebStorm介绍</h2><p>在学习了html+css基础后，想做一些简单的html实战项目，以前在学习html为了方便记忆且容易上手用了Notepad++，现在进行项目实战，难免不了要大量代码以及更多的功能来操作与编写，所以就去下载了WebStorm这种重量级软件来进行学习与开发。</p><p><strong>html提示</strong></p><p><strong>联想查询</strong></p><p><strong>代码重构</strong></p><p><strong>代码检查和快速修复</strong></p><p><strong>代码调试</strong></p><p><strong>代码结构浏览</strong></p><p><strong>代码折叠</strong></p><p><strong>包裹或者去掉外围代码</strong></p><p>对于WebStorm的叙述就到这儿了，“工欲善其事必先利其器”，下面来看看如何安装与破解WebStorm。</p><h2 id="2-WebStorm的下载"><a href="#2-WebStorm的下载" class="headerlink" title="2. WebStorm的下载"></a>2. WebStorm的下载</h2><p>去官网下载</p><p><a href="http://www.jetbrains.com/webstorm/" target="_blank" rel="noopener">WebStorm官网</a></p><p><img src="/2019/04/09/WebStorm的安装与破解/1.png" alt="WebStorm官网"></p><p>点击DOWNLOAD进行下载</p><p>下载完成后双击打开进行安装</p><p><img src="/2019/04/09/WebStorm的安装与破解/2.png" alt></p><p>点击Next</p><p><img src="/2019/04/09/WebStorm的安装与破解/3.png" alt></p><p>选择自己的安装路径</p><p><img src="/2019/04/09/WebStorm的安装与破解/4.png" alt></p><p>根据自己电脑的位数选择，和添加到环境变量，.js .css .html勾选后之后js css html文件默认会用webstorm打开,然后点击Next。</p><p><img src="/2019/04/09/WebStorm的安装与破解/5.png" alt></p><p>点击Install</p><p><img src="/2019/04/09/WebStorm的安装与破解/6.png" alt></p><p><img src="/2019/04/09/WebStorm的安装与破解/7.png" alt></p><p>完成安装，选择I want to manually reboot later，然后点击Finsh。</p><h2 id="3-破解"><a href="#3-破解" class="headerlink" title="3. 破解"></a>3. 破解</h2><p>双击打开程序,选择Do not import settings,点击ok</p><p><img src="/2019/04/09/WebStorm的安装与破解/8.png" alt></p><p>点击Skip</p><p><img src="/2019/04/09/WebStorm的安装与破解/9.png" alt></p><p><strong>方法一：</strong></p><p>注册时，在打开的License Activation窗口中选择“License server”，在输入框输入下面的网址：</p><p><a href="http://idea.imsxm.com/" target="_blank" rel="noopener">http://idea.imsxm.com/</a>或<a href="http://idea.yangyusb.com" target="_blank" rel="noopener">http://idea.yangyusb.com</a></p><p>点击：Activate即可。</p><p><strong>方法二：</strong></p><p>选择Activation code,在其中填入注册码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2RRJMBXW33-eyJsaWNlbnNlSWQiOiIyUlJKTUJYVzMzIiwibGljZW5zZWVOYW1lIjoi5b285bK4IHNvZnR3YXJlMiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJGb3IgZWR1Y2F0aW9uYWwgdXNlIG9ubHkiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAxOS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDE5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxOS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMTktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAxOS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAxOS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDE5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMTktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxOS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDE5LTA3LTA3In1dLCJoYXNoIjoiOTUyNzQwMS8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-WBR8xuiXaXLeV0obFYbBfUUQ02r54Vj3fE9ImtuXKSP+NuvvnR6lH6gWcVm9PZt67eqdDZa+Deej1NsoGRPDZS5UB6WEt4YVahlOhmG3rgvXPlP98hsfgFUcjr3OQVY7wk5slJ+Q2G9lkpsqwezO+SFIk9yA6pjxyT+U7FjpU8SY5ilsHskq4FG8FoKPYLsfsuwtXrJimRBxVcDClw/QsnCSwgtjuunc8Te37rHb08ZAxtJJieIsjhWnnzrQ3LmxmsR4xstkZOSqD4bYgeNz+m2nbmCWJ5lfP+pnqWfSsUCVri2TUxTpzzTMe4Cx8UhGeJgIgUyBXjq05/0nq3YoVg==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==</span><br></pre></td></tr></table></figure><p>或者打开网址（<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">IntelliJ IDEA 注册码</a>）跳转到,点击获得注册码</p><p><img src="/2019/04/09/WebStorm的安装与破解/11.png" alt></p><p>将注册码复制到</p><p><img src="/2019/04/09/WebStorm的安装与破解/10.png" alt></p><p><strong>如果没成功，请换一个旧一点的版本，旧的注册码对新版本不管用。</strong></p><p>用破解补丁来破解：</p><p>下载破解补丁<a href="http://idea.lanyus.com/jar/JetbrainsIdesCrack-4.2-release-sha1-3323d5d0b82e716609808090d3dc7cb3198b8c4b.jar" target="_blank" rel="noopener">破解补丁无需使用注册码，下载地址</a>或者去（<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">IntelliJ IDEA 注册码</a>）下载</p><p><img src="/2019/04/09/WebStorm的安装与破解/13.png" alt></p><p>将下载的文件移动到WebStorm安装目录的bin目录下</p><p><img src="/2019/04/09/WebStorm的安装与破解/14.png" alt></p><p>修改安装目录下的 WebStorm.exe.vmoptions 和WebStorm64.exe.vmoptions，这两个文件一个是32位的，一个是64位的，建议同步修改。用文本编辑器打开之后，在文件最上面加一行代码 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:安装目录/破解补丁名字.jar</span><br></pre></td></tr></table></figure><p><img src="/2019/04/09/WebStorm的安装与破解/15.png" alt></p><p>配置好之后，保存文件。在此再次启动WebStorm，选择Activation code，在其中输入<code>-javaagent:安装目录/破解补丁名字.jar</code>,点击ok完成。</p><p><img src="/2019/04/09/WebStorm的安装与破解/12.png" alt></p><p><img src="/2019/04/09/WebStorm的安装与破解/16.png" alt></p><p>成果：一个八卦图</p><p><img src="/2019/04/09/WebStorm的安装与破解/18.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-WebStorm介绍&quot;&gt;&lt;a href=&quot;#1-WebStorm介绍&quot; class=&quot;headerlink&quot; title=&quot;1.WebStorm介绍&quot;&gt;&lt;/a&gt;1.WebStorm介绍&lt;/h2&gt;&lt;p&gt;在学习了html+css基础后，想做一些简单的html实战项
      
    
    </summary>
    
      <category term="software" scheme="https://smallpotatody.github.io/categories/software/"/>
    
    
      <category term="html+css" scheme="https://smallpotatody.github.io/tags/html-css/"/>
    
  </entry>
  
  <entry>
    <title>CSS部分</title>
    <link href="https://smallpotatody.github.io/2019/04/05/CSS%E9%83%A8%E5%88%86/"/>
    <id>https://smallpotatody.github.io/2019/04/05/CSS部分/</id>
    <published>2019-04-05T02:52:25.000Z</published>
    <updated>2019-04-05T14:25:34.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-HTML-lt-DOCTYPE-gt-声明标签"><a href="#1-HTML-lt-DOCTYPE-gt-声明标签" class="headerlink" title="1.HTML&lt;!DOCTYPE&gt;声明标签"></a>1.HTML&lt;!DOCTYPE&gt;声明标签</h2><p><code>&lt;!doctype&gt;</code>声明必须是HTML文档是的第一行，位于<html>标签之前。<br><code>&lt;!doctype&gt;</code>声明不是HTML标签；它是指示web浏览器关于页面使用的哪个HTML版本进行编写的指令。</html></p><p>HTML5为<code>&lt;!doctype html&gt;</code>,<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></p><p>在html4.01中单标记必须闭合，单属性必须必须添加属性值，标记和属性必须使用小写，属性的属性值必须使用””。</p><h2 id="2-使用CSS样式的方式"><a href="#2-使用CSS样式的方式" class="headerlink" title="2.使用CSS样式的方式"></a>2.使用CSS样式的方式</h2><p>a.内链样式表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--内链样式表--&gt;</span><br><span class="line">&lt;body style=&quot;background-color:green; margin:0; padding:0;&quot; &gt;</span><br></pre></td></tr></table></figure><p>b.嵌入式样式表：</p><p>需要放在<code>&lt;head&gt;&lt;/head&gt;</code>中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--嵌入式样式表--&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">p&#123;</span><br><span class="line">background-color:yellow;</span><br><span class="line">color:black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p是<code>&lt;p&gt;&lt;/p&gt;</code>标记，如果是<code>&lt;h1&gt;&lt;/h1&gt;</code>标记就为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--嵌入式样式表--&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">h1&#123;</span><br><span class="line">background-color:yellow;</span><br><span class="line">color:black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c.引入式样式表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入式样式表--&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; herf=&quot;style.css&quot;&gt;</span><br></pre></td></tr></table></figure><p>style.css为新建的css文件，表示要设置属性内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">background-color:green;</span><br><span class="line">color:yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/05/CSS部分/1.png" alt></p><h2 id="3-定义样式表"><a href="#3-定义样式表" class="headerlink" title="3.定义样式表"></a>3.定义样式表</h2><p><code>&lt;h1&gt;&lt;h1&gt;</code>,h1{属性:属性值; 属性:属性值:},h1为选择器，定义那个标记中的内容执行其中的样式，一个选择器可以控制若干个样式属性，属性之间用英语“;”隔开。</p><p>a.Class定义：</p><p><code>&lt;p class=&quot;p&quot;&gt;&lt;/p&gt;</code>,class定义是以“.”开始</p><p>p{属性1:属性值; 属性2:属性值;}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.p&#123;color:green;font-size:10px&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class=&quot;p&quot;&gt;小土豆很强&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>b.id定义：</p><p><code>&lt;p id=&quot;pp&quot;&gt;&lt;/p&gt;</code>,id定义是#开始的。#pp{属性1:属性值1; 属性2:属性值2;},id只能出现一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#PP&#123;background-color:green; color:blue; font-size:20px;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p id=&quot;pp&quot;&gt;...&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>优先级为id&gt;class&gt;html，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p&#123;......&#125;</span><br><span class="line">.p&#123;......&#125;</span><br><span class="line">#pp&#123;......&#125;</span><br></pre></td></tr></table></figure><p>不管顺序如何，结果都为#pp{……}中的内容设置。</p><p>同级时选择离元属最近一个的，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pp&#123;color:red&#125;</span><br><span class="line">#pp&#123;color:white&#125;</span><br></pre></td></tr></table></figure><p>则执行颜色为白色的。</p><p>组合选择器（同时控制多个元素）</p><p><code>h1,h2,h3{font-size:20px; color:red;}</code>,选择器组合可以使用“.”隔开</p><p>超链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:link&#123;color:red&#125;;        正常连接的样式</span><br><span class="line">a:hover&#123;color:yellow&#125;;    鼠标放上去的样式</span><br><span class="line">a:active&#123;color:blue&#125;;     选择链接时的样式</span><br><span class="line">a:visited&#123;color:yellow&#125;;  已经访问过的链接的样式</span><br></pre></td></tr></table></figure><p><img src="/2019/04/05/CSS部分/2.png" alt></p><p>上面的内容纯属不要年放上去的啊！装了一波，哈哈哈！</p><h2 id="4-CSS常见属性"><a href="#4-CSS常见属性" class="headerlink" title="4.CSS常见属性"></a>4.CSS常见属性</h2><ol><li>颜色属性：</li></ol><p>color属性定义文本的颜色，可以有以下格式：</p><p>a. color:green</p><p>b. color:#ff6600或color:f60       ff(red)66(green)00(blue)</p><p>c. RGB——- color:rgb(0~255,0~255,0~255)</p><p>d. RGBA——color:rgba(0~255,0~255,0~255,1) #其中A代表Alpha的（色彩空间）透明</p><p><img src="/2019/04/05/CSS部分/3.png" alt></p><ol start="2"><li>字体属性<ol><li>font-size字体大小，格式为：<code>font-size:内容;</code>内容有px:设置一个固定的值。%:父元素的百分比。smaller:比父元素更小。larger:比父元素更大。inherit:继承父元素的。</li><li>font-family字体类型，格式为：<code>font-family:微软雅黑, serif;</code>可以用<code>&quot;,&quot;</code>隔开，以确保当字体不存在的时候直接使用下一个。</li><li>font-weight字体加粗，格式为：<code>font-weight:内容</code>，内容有normal（默认值）、bold（粗）、bolder（更粗）、lighter（更细），也可以用100~900之间的整百数来表示，其中400=normal，700=bold。</li><li>font-style字体样式，<code>font-style:内容</code>，内容有normal（正常）、italic（斜体）、oblique（倾斜）、inherit（继承）。</li><li>font-variant小型大写字母显示文本，格式为：<code>font-variant:内容</code>，内容有normal（标准）、small-caps（小型大写字母显示文本）、inherit（继承）。</li></ol></li></ol><p><img src="/2019/04/05/CSS部分/4.png" alt></p><ol start="3"><li><p>背景属性</p><ol><li><p>背景颜色：background-color</p></li><li><p>背景图片：background-image</p><p>background-image:url(图片路径)</p><p>background-image:none</p></li><li><p>背景重复：background-repeat</p><p>background-repeat:repeat 重复平铺满</p><p>background-repeat:repeat-x 向x轴重复</p><p>background-repeat:repeat-y 向y轴重复</p><p>background-repeat:no-repeat 不重复</p></li><li><p>背景位置：background-position:(x)(y)</p><p>横向（left,center,right）</p><p>纵向（top,center,bottom）</p><p>也可以为像素px。简写方式background:背景颜色 url(图像) 重复 位置</p><p>background:#f60 url(图片路径) no-repeat top center</p><p><img src="/2019/04/05/CSS部分/5.png" alt></p></li></ol></li><li><p>文本属性</p><ol><li><p>横向排列<code>text-align:left</code>,left、center、right</p></li><li><p>文本行高<code>line-height:</code>,%基于字体大小的百分比行高，数值来设置固定的值。</p></li><li><p>首行缩进<code>text-indent:</code>,%父元素的百分比，px固定值，默认为0，inherit继承。</p></li><li><p>字符间距<code>letter-spacing:</code>,normal默认，length设置具体的数值（可以设置为负值），inherit继承。</p></li><li><p>单词间距<code>word-spacing:</code>,normal标准间距，px固定值，inherit继承。</p></li><li><p>文本方向<code>direction:</code>,ltr从左到右，rtl从右到左，inherit继承。</p></li><li><p>文本大小写<code>text-transform:</code>,none默认，capitalize每个单词以大写字母开头，uppercase定义仅有大写字母，lowercase定义无大写字母，仅有小写字母，inherit规定应该从父元素继承text-transform属性的值。</p><p><img src="/2019/04/05/CSS部分/6.png" alt></p></li></ol></li><li><p>边框属性</p><ol><li>边框风格<code>border-style:</code>,统一风格border-style:，none无边框，solid直线边框，dashed虚线边框，dotted点状边框，double双线边框，groove凸槽边框，ridge垄状边框，inset inset边框，outset outset边框，inherit继承。单独定义某一方向的边框样式:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border-bottom-style 下边边框样式</span><br><span class="line">border-top-style 上边框样式</span><br><span class="line">border-left-style 左边边框样式</span><br><span class="line">border-right-style 右边边框样式</span><br></pre></td></tr></table></figure><ol start="2"><li><p>边框宽度<code>border-width:</code>,统一风格<code>border-width:</code>,单独风格border-top-width上边边框宽度,border-bottom-width下边边框宽度,border-left-width左边边框宽度,border-right-width右边边框宽度。边框宽度属性值：thin 细边框、medium 中等边框、thick 粗边框、px 固定值边框、inherit 继承。</p></li><li><p>边框颜色<code>border-color:</code>,统一风格<code>border-color:</code>,单独风格border-top-color 上边框颜色，border-bottom-color 下边框颜色，border-left-color 左边框颜色，border-right-color 右边框颜色。边框颜色属性值：rgb(255,255,255)、rgba(255,255,255,0~1)、十六进制 #ff0000、继承inherit。属性值的四种情况：一个值：border-color:（上、下、左、右）；两个值：border-color:（上下）（左右）；三个值：border-color:（上）、（左、右）、（下）；四个值：border-color:（上）（下）（左）（右）；简写方式：border:solid 2px #f60。</p><p><img src="/2019/04/05/CSS部分/7.png" alt></p></li></ol></li><li><p>列表属性</p><ol><li><p>标记类型<code>list-style-type:</code>；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">none 无标记</span><br><span class="line">disc 默认，标记是实心圆</span><br><span class="line">circle 标记是空心圆</span><br><span class="line">square 标记是实心方快</span><br><span class="line">decimal 标记是数字</span><br><span class="line">decimal-leading-zero 0开头的数字标记（01，02，03等）</span><br><span class="line">lower-roman 小写罗马数字（i，ii，iii，iv，v等）</span><br><span class="line">upper-roman 大写罗马数字（I，II，III，IV，V等）</span><br><span class="line">lower-alpha 小写英文字母（a，b，c等）</span><br><span class="line">upper-alpha 大写英文字幕（A，B，C等）</span><br><span class="line">lower-greek 小写希纳字母（alpha，beta，gamma等）</span><br><span class="line">lower-latin 小写拉丁字母（a，b，c，d，e等）</span><br><span class="line">upper-latin 大写拉丁字母（A,B,C，D，E等）</span><br><span class="line">hebrew 传统的希伯来编号方式</span><br><span class="line">armenian 传统的亚美尼亚编号方式</span><br><span class="line">georgian 传统的乔治亚编号方式（an，ban，gan等）</span><br><span class="line">cjk-ideographic 简单的表意数字</span><br><span class="line">hiragana 标记是：a，i，u，e，o，ka，ki等。</span><br><span class="line">katakana 标记是：A，I，U，E，O，KA，KI等。</span><br><span class="line">hiragana-iroha 标记是：i，ro，ha，ni，ho，he，to等。</span><br><span class="line">katakana-iroha 标记是：I，RO，HA，NI，HO，HE，TO等。</span><br></pre></td></tr></table></figure></li><li><p>标记的位置<code>list-style-position:</code>,inside列表项目标记放置在文本内，且环绕文本根据标记对齐。outside是默认值，保持标记位于文本的左侧。列表项目标记放置在文本以外，且环境文本不根据标记对齐。inherit规定应该从父元素继承list-style-position属性的值。</p></li><li><p>设置图像列表标记<code>list-style-image:</code>,url(图像路径)，none默认，无图形被显示。inherit规定应该从父元素继承list-style-image属性的值。</p><p>简写方式：<code>list-style:square inside url(&#39;/i/arrow.jpg&#39;);</code></p><p><img src="/2019/04/05/CSS部分/8.png" alt>    </p></li></ol></li></ol><h2 id="5-div-css布局"><a href="#5-div-css布局" class="headerlink" title="5.div+css布局"></a>5.div+css布局</h2><ol><li><p>div和span，div和span在整个HTML标记中，没有任何意义，他们的存在就是为了应用CSS样式，div和span的区别在于，span是内联元素，div是块级元素。div是块状，而span只是内容大小。</p></li><li><p>盒模型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">margin 盒子外边框</span><br><span class="line">padding 盒子内边框</span><br><span class="line">border 盒子边框宽度</span><br><span class="line">width 盒子宽度</span><br><span class="line">height 盒子高度</span><br></pre></td></tr></table></figure><p><img src="/2019/04/05/CSS部分/9.png" alt></p></li></ol><p><img src="/2019/04/05/CSS部分/10.png" alt></p><ol start="3"><li><p>布局相关的属性</p><ol><li><p>定位方式position</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">relative 正常定位</span><br><span class="line">absolute 根据父元素进行定位</span><br><span class="line">fixed 根据浏览窗口进行定位</span><br><span class="line">static 没有定位</span><br><span class="line">inherit 继承2.</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="2"><li><p>定位left（左）、right（右）、top（上）、bottom（下）离页面顶点的距离。如：<code>right:20px;</code>为距离右边边框20像素。</p></li><li><p>z-index层覆盖先后顺序（优先级）如：z-index:2。</p></li><li><p>display显示属性，层不显示display:none;块状显示，在元素后面换行，显示下一个块元素display:block;内联显示，多个快可以显示在一行内display:inline;从内联式到块样式之间的转换。</p></li></ol><ol start="5"><li><p>float浮动属性，left左浮动；right右浮动；</p></li><li><p>clear 清除浮动，clear:both;</p></li><li><p>overflow溢出处理，hidde影藏超出层大小的内容；scroll无法显示内容是否超出层大小都添加滚动条；auto超出时自动添加滚动条。</p><p><img src="/2019/04/05/CSS部分/11.png" alt></p></li></ol><ol start="4"><li><p>兼容问题</p><ol><li>兼容性测试工具：IE Tester、Multibrowser</li><li>常用的浏览器：Google chrome、Firefox、opera</li><li>高效开发工具：轻量级工具：Notepad++、sbulime Text、记事本，重量级的：WebStorm、Dreamweaver。</li><li>网页设计工具：fireworks、photoshop。</li><li>判断IE的方法：</li></ol><p>条件判断格式<code>&lt;!--[if 条件 版本]&gt; 那么显示 &lt;![endif]--&gt;</code>。</p><ul><li>不等于[if !IE 8]表示出来IE8都可以显示</li><li>小于[if lt IE 8]表示如果IE浏览器版本小于8的显示</li><li>大于[if gt IE 8]表示如果IE浏览器版本大于8的显示</li><li>小于或等于[if lte IE 8]表示如果IE浏览器版本小于8的显示</li><li>大于或等于[if gte IE 8]表示如果IE浏览器版本大于8的显示</li><li>大于和小于之间[if (gt IE 5)&amp;(lt IE 7)]表示如果IE浏览器版本大于IE5小于7的显示</li><li>或[if (IE 6)|(IE 7)]表示如果是IE6或者IE7显示</li><li>仅&lt;!–[if IE 8]&gt;表示如果是IE8</li></ul></li></ol><p><strong>注意：条件注释只有在IE浏览器下才能执行，这样就达到了我们的效果</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-HTML-lt-DOCTYPE-gt-声明标签&quot;&gt;&lt;a href=&quot;#1-HTML-lt-DOCTYPE-gt-声明标签&quot; class=&quot;headerlink&quot; title=&quot;1.HTML&amp;lt;!DOCTYPE&amp;gt;声明标签&quot;&gt;&lt;/a&gt;1.HTML&amp;lt;
      
    
    </summary>
    
      <category term="CSS" scheme="https://smallpotatody.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://smallpotatody.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo源码上传到Github上同一仓库</title>
    <link href="https://smallpotatody.github.io/2019/04/01/Hexo%E6%BA%90%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0Github%E4%B8%8A%E5%90%8C%E4%B8%80%E4%BB%93%E5%BA%93/"/>
    <id>https://smallpotatody.github.io/2019/04/01/Hexo源码上传到Github上同一仓库/</id>
    <published>2019-04-01T05:55:42.000Z</published>
    <updated>2019-04-01T14:36:17.849Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 Hexo 来写博客的时候，我们想在其他电脑操作上很难，那么我们如果将其放在GitHub上托管，那么就没有那么多麻烦。我们将博客搭建在 GitHub 上后，当我们使用 hexo g -d 部署到 GitHub 上以及网页上，其实没有把我们编写的 xxx.md 原博客文档上传到Github，而只是生成一些博客需要的静态的页面。但我们万事都想安全一点，假设我们硬盘坏了，数据无法恢复，那么我们的博客源文档也会不见，所以最好我们是把源代码也托管到 GitHub 上， 这个也有一个好处就是你在其他电脑上也可以同步编写博客。</p><p>你如果想把源代码上传至GitHub，那么可以上传至GitHub上的仓库，但是我们在建立博客时就已经创建了一个仓库，再创仓库就不方便管理与规划。本文说的前提是你已经建立了github pages——就是利用github搭建了个人博客。</p><h2 id="在你的仓库下创建分支"><a href="#在你的仓库下创建分支" class="headerlink" title="在你的仓库下创建分支"></a>在你的仓库下创建分支</h2><p><img src="/2019/04/01/Hexo源码上传到Github上同一仓库/1.png" alt></p><p><img src="/2019/04/01/Hexo源码上传到Github上同一仓库/2.png" alt></p><h2 id="更改默认分支"><a href="#更改默认分支" class="headerlink" title="更改默认分支"></a>更改默认分支</h2><p><img src="/2019/04/01/Hexo源码上传到Github上同一仓库/3.png" alt></p><h2 id="创建本地分支目录"><a href="#创建本地分支目录" class="headerlink" title="创建本地分支目录"></a>创建本地分支目录</h2><p>在本地磁盘新建一个文件夹（文件夹名随便只要你自己能找到和辨别出就行）用作放即将上传至仓库新建分支sourse（我建立的分支，即你自己建立分支的名字），进入文件夹，鼠标右键选择Git Bash Here</p><p><img src="/2019/04/01/Hexo源码上传到Github上同一仓库/4.png" alt></p><p><img src="/2019/04/01/Hexo源码上传到Github上同一仓库/6.png" alt></p><p>将你要上传的源代码文件和你想上传的文件粘贴到刚才创建的文件夹。</p><h2 id="添加项目"><a href="#添加项目" class="headerlink" title="添加项目"></a>添加项目</h2><p>我在这里添加了几张图片和hello-world.md文件</p><p><img src="/2019/04/01/Hexo源码上传到Github上同一仓库/5.png" alt></p><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>进入上面的Git Bash Here里面输入以下命令</p><p>你可以直接克隆你的项目到目录下。</p><p><code>git clone https://github.com/yourname/yourname.github.io.git</code></p><p>然后将文件移动到新建的yourname.github.io（就是执行上面命令后产生的）文件夹里面，再在这里面打开Git Bash Here，再输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/yourname/yourname.github.io.git</span><br><span class="line">如果出错提示你已经有了origin可以输入以下命令</span><br><span class="line">git remote rm origin</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;your description&quot;</span><br><span class="line">git push origin sourse</span><br><span class="line">如果出错就可以输入以下命令</span><br><span class="line">git pull origin sourse</span><br><span class="line">或者直接强行输入</span><br><span class="line">git push origin sourse -f</span><br></pre></td></tr></table></figure><p><img src="/2019/04/01/Hexo源码上传到Github上同一仓库/7.png" alt></p><p><img src="/2019/04/01/Hexo源码上传到Github上同一仓库/8.png" alt></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>确认你的 _config.yml 配置是提交到 master 分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/2019/04/01/Hexo源码上传到Github上同一仓库/9.png" alt></p><p>通过结果可以看出来在sourse文件夹下面的yourname.github.io文件夹里面的内容军上传至Github上yourname仓库的sourse分支下。</p><h2 id="新增文件上传方法"><a href="#新增文件上传方法" class="headerlink" title="新增文件上传方法"></a>新增文件上传方法</h2><p>将添加文件放入到本地仓库分支里面也就是sourse文件夹下面的yourname.github.io文件夹下</p><p>然后在里面进行Git Bash Here输入以下命令</p><figure class="highlight plain"><figcaption><span>add .</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;your description&quot;</span><br><span class="line">git push origin sourse -f</span><br></pre></td></tr></table></figure><p><img src="/2019/04/01/Hexo源码上传到Github上同一仓库/11.png" alt></p><p><img src="/2019/04/01/Hexo源码上传到Github上同一仓库/10.png" alt></p><p>我相信大家已经配置好了博客，如果没配置可以参考我的另一篇<a href="https://smallpotatody.github.io/2019/03/11/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#more">Hexo+GitHub搭建博客</a></p><p>文件参考：<a href="https://blog.csdn.net/u011642663/article/details/70182774" target="_blank" rel="noopener">保存 Hexo 博客源码到 GitHub</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用 Hexo 来写博客的时候，我们想在其他电脑操作上很难，那么我们如果将其放在GitHub上托管，那么就没有那么多麻烦。我们将博客搭建在 GitHub 上后，当我们使用 hexo g -d 部署到 GitHub 上以及网页上，其实没有把我们编写的 xxx.md 原博客文
      
    
    </summary>
    
      <category term="hexo" scheme="https://smallpotatody.github.io/categories/hexo/"/>
    
    
      <category term="github" scheme="https://smallpotatody.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>用python网络爬虫爬取英雄联盟英雄图片</title>
    <link href="https://smallpotatody.github.io/2019/03/28/python%E7%88%AC%E5%8F%96lol%E7%9A%AE%E8%82%A4/"/>
    <id>https://smallpotatody.github.io/2019/03/28/python爬取lol皮肤/</id>
    <published>2019-03-28T09:34:00.068Z</published>
    <updated>2019-03-26T13:41:11.063Z</updated>
    
    <content type="html"><![CDATA[<p>用python爬虫爬取lol皮肤。</p><p>这也用python网络爬虫爬取lol英雄皮肤，忘了是看哪个大神的博客（由于当时学了下就一直放在这儿，现在又才拿出来，再加上马上要考二级挺忙的。），代码基本上是没改，还望大神原谅。本人小白，没学过Python，只是去尝试体python爬虫的感觉和经验，正准备学python。忘大神勿喷。来一句：“人生苦短，我用python”。</p><p>先上一波图</p><p><img src="/2019/03/28/python爬取lol皮肤/imagesAkali8.jpg" alt></p><p><img src="/2019/03/28/python爬取lol皮肤/imagesAkali9.jpg" alt></p><p><img src="/2019/03/28/python爬取lol皮肤/imagesAkali10.jpg" alt></p><p><img src="/2019/03/28/python爬取lol皮肤/imagesAkali14.jpg" alt></p><p><img src="/2019/03/28/python爬取lol皮肤/imagesAlistar4.jpg" alt></p><p><img src="/2019/03/28/python爬取lol皮肤/imagesAlistar5.jpg" alt></p><p><img src="/2019/03/28/python爬取lol皮肤/imagesAlistar6.jpg" alt></p><p><img src="/2019/03/28/python爬取lol皮肤/imagesAlistar7.jpg" alt></p><p><img src="/2019/03/28/python爬取lol皮肤/imagesAlistar11.jpg" alt></p><p><img src="/2019/03/28/python爬取lol皮肤/imagesAmumu0.jpg" alt></p><p><img src="/2019/03/28/python爬取lol皮肤/imagesAmumu1.jpg" alt></p><p><img src="/2019/03/28/python爬取lol皮肤/imagesAmumu2.jpg" alt></p><p>个人感觉还是挺好的。下面我们就来学习一下怎样爬取？</p><p>所需要的函数库有json re（正则表达式库） requests和time是python自带的</p><p>其中只有requests需要通过cmd命令行安装，安装方法就是在python安装目录下用cmd命令行输入下面字符</p><p><code>pip Install requests</code></p><p><img src="/2019/03/28/python爬取lol皮肤/1.png" alt></p><p>由于我已经安装过了，所以提示我已经安装了。</p><p>第一步是获取英雄id</p><p>ID的获取地址是从英雄联盟官网F12后在Network里找到champion.js，具体地址如下</p><p><a href="http://lol.qq.com/biz/hero/champion.js" target="_blank" rel="noopener">http://lol.qq.com/biz/hero/champion.js</a></p><p><img src="/2019/03/28/python爬取lol皮肤/2.png" alt></p><figure class="highlight plain"><figcaption><span>json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line">def getLOLImages():</span><br><span class="line">    header = &#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.62 Safari/537.36&apos;&#125;</span><br><span class="line">    url_js = &apos;http://lol.qq.com/biz/hero/champion.js&apos;</span><br><span class="line">    #获取JS源代码 Str bytes</span><br><span class="line">    res_js = requests.get(url_js).content</span><br><span class="line">    #转码 转成字符串</span><br><span class="line">    html_js = res_js.decode()</span><br><span class="line">    #正则表达式</span><br><span class="line">    req = &apos;&quot;keys&quot;:(.*?),&quot;data&quot;&apos;</span><br><span class="line">    list_js = re.findall(req,html_js)</span><br><span class="line">    #转成dict</span><br><span class="line">    dict_js = json.loads(list_js[0])</span><br><span class="line">    print(type(dict_js)) #定义图片列表</span><br><span class="line">    pic_list = []</span><br><span class="line">    for key in dict_js: </span><br><span class="line">    printkey)#英雄ID</span><br></pre></td></tr></table></figure><p>第二步就是拼接URL了，通过发现英雄皮肤url的取名方式，我们可以方向最后的数字是不同的。让后通过此方法来获取图片地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i in range(20):</span><br><span class="line">    number = str(i)</span><br><span class="line">    if len(number) == 1:</span><br><span class="line">        hero_num = &quot;00&quot;+number</span><br><span class="line">    elif len(number) == 2:</span><br><span class="line">        hero_num = &quot;0&quot;+number</span><br><span class="line">    numstr = key+hero_num</span><br><span class="line">    url = &quot;http://ossweb-img.qq.com/images/lol/web201310/skin/big&quot;+numstr+&quot;.jpg&quot;</span><br><span class="line">    #http://ossweb-img.qq.com/images/lol/web201310/skin/big81000.jpg</span><br><span class="line">    pic_list.append(url)</span><br></pre></td></tr></table></figure><p><img src="/2019/03/28/python爬取lol皮肤/3.png" alt></p><p>第三步是获取图片名称，path那行是放置图片的地址，注意结尾的<code>\\</code>不能丢。路径要设置成自己的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list_filepath = []</span><br><span class="line">    path = &quot;D:\Pycharmdaima\Pachong\LOLTU\\&quot;</span><br><span class="line">for name in dict_js.values():</span><br><span class="line">    for i in range(20):</span><br><span class="line">        file_path = path+name+str(i)+&apos;.jpg&apos;</span><br><span class="line">        list_filepath.append(file_path)</span><br></pre></td></tr></table></figure><p>第四步就是下载图片了，注释掉time.sleep（1）后会加速爬取速度 但是可能被腾讯中断爬取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n = 0</span><br><span class="line">for picurl in pic_list:</span><br><span class="line">    res = requests.get(picurl)</span><br><span class="line">    n += 1</span><br><span class="line">    #获取状态码</span><br><span class="line">    if res.status_code == 200:</span><br><span class="line">        print(&quot;正在下载%s&quot;%list_filepath[n])</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        with open(list_filepath[n],&apos;wb&apos;) as f:</span><br><span class="line">            f.write(res.content)</span><br></pre></td></tr></table></figure><p>下面是全部代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line">#获取JS源代码 获取英雄ID</span><br><span class="line">#拼接URL地址</span><br><span class="line">#获取图片下载地址</span><br><span class="line">#下载图片</span><br><span class="line"></span><br><span class="line">#驼峰命名法</span><br><span class="line">#获取英雄图片</span><br><span class="line">def getLOLImages():</span><br><span class="line">    header = &#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.62 Safari/537.36&apos;&#125;</span><br><span class="line">    url_js = &apos;http://lol.qq.com/biz/hero/champion.js&apos;</span><br><span class="line">    #获取JS源代码 Str bytes</span><br><span class="line">    res_js = requests.get(url_js).content</span><br><span class="line">    #转码 转成字符串</span><br><span class="line">    html_js = res_js.decode()</span><br><span class="line">    #正则表达式</span><br><span class="line">    req = &apos;&quot;keys&quot;:(.*?),&quot;data&quot;&apos;</span><br><span class="line">    list_js = re.findall(req,html_js)</span><br><span class="line">    #转成dict</span><br><span class="line">    dict_js = json.loads(list_js[0])</span><br><span class="line">    # print(type(dict_js))</span><br><span class="line">​    #定义图片列表</span><br><span class="line">​    pic_list = []</span><br><span class="line">​    for key in dict_js:</span><br><span class="line">        # print(key)#英雄ID</span><br><span class="line">​        #拼接URL</span><br><span class="line">​        for i in range(20):</span><br><span class="line">​            number = str(i)</span><br><span class="line">​            if len(number) == 1:</span><br><span class="line">​                hero_num = &quot;00&quot;+number</span><br><span class="line">​            elif len(number) == 2:</span><br><span class="line">​                hero_num = &quot;0&quot;+number</span><br><span class="line">​            numstr = key+hero_num</span><br><span class="line">​            url = &quot;http://ossweb-img.qq.com/images/lol/web201310/skin/big&quot;+numstr+&quot;.jpg&quot;</span><br><span class="line">​            #http://ossweb-img.qq.com/images/lol/web201310/skin/big81000.jpg</span><br><span class="line">​            pic_list.append(url)</span><br><span class="line">​         #获取图片名称</span><br><span class="line">​        list_filepath = []</span><br><span class="line">​        path = &quot;D:\Pycharmdaima\Pachong\LOLTU\\&quot;</span><br><span class="line">​    for name in dict_js.values():</span><br><span class="line">​        for i in range(20):</span><br><span class="line">​            file_path = path+name+str(i)+&apos;.jpg&apos;</span><br><span class="line">​            list_filepath.append(file_path)</span><br><span class="line">​    #下载图片</span><br><span class="line">​    n = 0</span><br><span class="line">​    for picurl in pic_list:</span><br><span class="line">​        res = requests.get(picurl)</span><br><span class="line">​        n += 1</span><br><span class="line">​        #获取状态码</span><br><span class="line">​        if res.status_code == 200:</span><br><span class="line">​            print(&quot;正在下载%s&quot;%list_filepath[n])</span><br><span class="line">​            time.sleep(1)</span><br><span class="line">​            with open(list_filepath[n],&apos;wb&apos;) as f:</span><br><span class="line">​                f.write(res.content)</span><br><span class="line">getLOLImages()</span><br></pre></td></tr></table></figure><p>以下是我的部分代码</p><p><img src="/2019/03/28/python爬取lol皮肤/4.png" alt></p><p>我对以上代码也是有点懵毕竟刚接触，如果大家有意要LOL皮肤的可以给在评论去找我。展示一下，我下了所有的哈哈。。。。。。。。</p><p><img src="/2019/03/28/python爬取lol皮肤/5.png" alt></p><p>最后：大家学爬虫一定要遵守法律，切勿用作商用。</p><p>来自博主的忠告：博主提醒你，爬虫不规范，牢底坐穿，亲人两行泪！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用python爬虫爬取lol皮肤。&lt;/p&gt;
&lt;p&gt;这也用python网络爬虫爬取lol英雄皮肤，忘了是看哪个大神的博客（由于当时学了下就一直放在这儿，现在又才拿出来，再加上马上要考二级挺忙的。），代码基本上是没改，还望大神原谅。本人小白，没学过Python，只是去尝试体py
      
    
    </summary>
    
      <category term="python" scheme="https://smallpotatody.github.io/categories/python/"/>
    
    
      <category term="python爬虫" scheme="https://smallpotatody.github.io/tags/python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub搭建博客</title>
    <link href="https://smallpotatody.github.io/2019/03/28/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://smallpotatody.github.io/2019/03/28/Hexo-Github搭建个人博客/</id>
    <published>2019-03-28T09:34:00.060Z</published>
    <updated>2019-03-15T09:00:58.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo-GitHub搭建博客"><a href="#hexo-GitHub搭建博客" class="headerlink" title="hexo+GitHub搭建博客"></a>hexo+GitHub搭建博客</h2><a id="more"></a><h3 id="1-下载并安装Git-Node-js"><a href="#1-下载并安装Git-Node-js" class="headerlink" title="1.下载并安装Git,Node.js"></a>1.下载并安装Git,Node.js</h3><p><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git(官网)</a><br><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js（官网）</a><br>下载就不说了。<br>安装就傻瓜式安装，直接默认就行了！</p><h3 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h3><pre><code>计算机---属性---高级系统设置---环境变量----打开用户变量---点击编辑---输入变量名和将node.js安装路径粘贴到变量值中---确定完成环境配置</code></pre><p><img src="/2019/03/28/Hexo-Github搭建个人博客/0.png" alt title="示例图片">     </p><h3 id="3-新建空博客文件夹"><a href="#3-新建空博客文件夹" class="headerlink" title="3.新建空博客文件夹"></a>3.新建空博客文件夹</h3><p>安装hexo，在空文件夹中点击鼠标右键点击Git bash here进入命令行,输入以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p><p><img src="/2019/03/28/Hexo-Github搭建个人博客/1.PNG" alt title="示例图片"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure></p><p><img src="/2019/03/28/Hexo-Github搭建个人博客/2.PNG" alt title="示例图片"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p><img src="/2019/03/28/Hexo-Github搭建个人博客/3.PNG" alt title="示例图片"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p><p><img src="/2019/03/28/Hexo-Github搭建个人博客/4.PNG" alt title="示例图片"><br>界面上会有一个类似<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>的网站,界面如下：<br><img src="/2019/03/28/Hexo-Github搭建个人博客/4.jpg" alt title="示例图片"></p><h3 id="4-注册github账号"><a href="#4-注册github账号" class="headerlink" title="4.注册github账号"></a>4.注册github账号</h3><p><a href="https://github.com" target="_blank" rel="noopener">github</a><br><img src="/2019/03/28/Hexo-Github搭建个人博客/6.PNG" alt title="示例图片"></p><h3 id="5-创建一个仓库"><a href="#5-创建一个仓库" class="headerlink" title="5.创建一个仓库"></a>5.创建一个仓库</h3><p>#####注：<br> GithubPages的Repository名字是特定的，比如我Github账号是abc，那么我Github Pages Repository名字就是abc.github.io。<br><img src="/2019/03/28/Hexo-Github搭建个人博客/7.PNG" alt title="示例图片"></p><h3 id="6-设置github-pages"><a href="#6-设置github-pages" class="headerlink" title="6.设置github pages"></a>6.设置github pages</h3><p>点击进入你刚刚创建好的仓库，接着点击settings，进入仓库管理，选择主题，和选择来源为master，试试在浏览器的地址栏输入”你github的用户名.github.io”吧！<br><img src="/2019/03/28/Hexo-Github搭建个人博客/8.GIF" alt title="示例图片"></p><h3 id="7-SSH授权"><a href="#7-SSH授权" class="headerlink" title="7.SSH授权"></a>7.SSH授权</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>接着3次回车，这样就会在C盘用户目录下生成id_rsa和id_rsa.pub这两个文件<br><img src="/2019/03/28/Hexo-Github搭建个人博客/9.PNG" alt title="示例图片"><br>打开id_rsa.pub，复制其中的全部内容，点击github头像，再点击setting选择SSH and GPG keys，再点击NEW SSH key，将刚才复制的内容粘贴到其中<br><img src="/2019/03/28/Hexo-Github搭建个人博客/11.PNG" alt title="示例图片"><br><img src="/2019/03/28/Hexo-Github搭建个人博客/12.PNG" alt title="示例图片"><br><img src="/2019/03/28/Hexo-Github搭建个人博客/13.PNG" alt title="示例图片"><br><img src="/2019/03/28/Hexo-Github搭建个人博客/14.PNG" alt title="示例图片"></p><h3 id="8-在-config-yml中添加"><a href="#8-在-config-yml中添加" class="headerlink" title="8.在_config.yml中添加"></a>8.在_config.yml中添加</h3><p>复制clone or download下的git地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:github用户名/github用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p><img src="/2019/03/28/Hexo-Github搭建个人博客/10.PNG" alt title="示例图片"></p><h3 id="9-回到命令窗口"><a href="#9-回到命令窗口" class="headerlink" title="9.回到命令窗口"></a>9.回到命令窗口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure></p><p><img src="/2019/03/28/Hexo-Github搭建个人博客/15.PNG" alt title="示例图片"><br>最后访问<a href="https://yourname.github.io" target="_blank" rel="noopener">https://yourname.github.io</a><br>例如：<br><img src="/2019/03/28/Hexo-Github搭建个人博客/16.PNG" alt title="示例图片"><br>博客搭建初步完成</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hexo-GitHub搭建博客&quot;&gt;&lt;a href=&quot;#hexo-GitHub搭建博客&quot; class=&quot;headerlink&quot; title=&quot;hexo+GitHub搭建博客&quot;&gt;&lt;/a&gt;hexo+GitHub搭建博客&lt;/h2&gt;
    
    </summary>
    
      <category term="software" scheme="https://smallpotatody.github.io/categories/software/"/>
    
    
      <category term="心得" scheme="https://smallpotatody.github.io/tags/%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>VMware Workstation pro 15破解版安装</title>
    <link href="https://smallpotatody.github.io/2019/03/26/VMware-15%E7%A0%B4%E8%A7%A3%E7%89%88/"/>
    <id>https://smallpotatody.github.io/2019/03/26/VMware-15破解版/</id>
    <published>2019-03-26T10:14:43.000Z</published>
    <updated>2019-03-26T12:58:47.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么要下载vmware？以及vmware是什么？"><a href="#1-为什么要下载vmware？以及vmware是什么？" class="headerlink" title="1.为什么要下载vmware？以及vmware是什么？"></a>1.为什么要下载vmware？以及vmware是什么？</h1><p>俗话说“工欲善其事，必先利其器”，所以不管是学习Python还是运维以及网络安全，最好在Linux系统上。但是我们有只有一台电脑，装双系统又麻烦，所以选择在Windows上装一个虚拟机来分配一个假想的“电脑”。虚拟机主要有vxbox和vmware这两种，这里我们选择vmware，至于原因不说了。看看维基百科上面怎么说</p><blockquote><p>VMware Workstation是VMware公司销售的<a href="https://zh.wikipedia.org/wiki/%E5%95%86%E4%B8%9A%E8%BD%AF%E4%BB%B6" target="_blank" rel="noopener">商业软件</a>产品之一。该工作站软件包含一个用于<a href="https://zh.wikipedia.org/wiki/%E8%8B%B1%E7%89%B9%E5%B0%94" target="_blank" rel="noopener">英特尔</a><a href="https://zh.wikipedia.org/wiki/X86" target="_blank" rel="noopener">x86</a>兼容计算机的<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">虚拟机</a>套装，其允许用户同时创建和运行多个x86虚拟机。每个虚拟机可以运行其安装的操作系统，如（但不限于）<a href="https://zh.wikipedia.org/wiki/Microsoft_Windows" target="_blank" rel="noopener">Windows</a>、<a href="https://zh.wikipedia.org/wiki/Linux" target="_blank" rel="noopener">Linux</a>、<a href="https://zh.wikipedia.org/wiki/BSD" target="_blank" rel="noopener">BSD变生版本</a>。用简单术语来描述就是，VMware Workstation允许一台真实的计算机在一个<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1" target="_blank" rel="noopener">操作系统</a>中同时打开并运行数个操作系统，其它VMware产品帮助在多个宿主计算机之间管理或移植VMware虚拟机。免费版本为<a href="https://zh.wikipedia.org/wiki/VMware_Workstation_Player" target="_blank" rel="noopener">VMware Workstation Player</a>。</p></blockquote><p>也可以看看百度百科：</p><blockquote><p>VMware Workstation（中文名“威睿工作站”）是一款功能强大的桌面<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E8%AE%A1%E7%AE%97%E6%9C%BA/5732003" target="_blank" rel="noopener">虚拟计算机</a>软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的最佳解决方案。VMware Workstation可在一部实体机器上模拟完整的网络环境，以及可便于携带的<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">虚拟机</a>器，其更好的灵活性与先进的技术胜过了市面上其他的虚拟计算机软件。对于企业的 IT开发人员和系统管理员而言， VMware在虚拟网路，实时快照，拖曳<a href="https://baike.baidu.com/item/%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9/7258865" target="_blank" rel="noopener">共享文件夹</a>，支持 PXE 等方面的特点使它成为必不可少的工</p></blockquote><p>好了废话不多说了，有什么不懂自行百度就ok啦！下面言归正传</p><h1 id="2-下载VMware-Workstation-Pro-15"><a href="#2-下载VMware-Workstation-Pro-15" class="headerlink" title="2.下载VMware Workstation Pro 15"></a>2.下载VMware Workstation Pro 15</h1><p><a href="http://www.zdfans.com/html/23250.html" target="_blank" rel="noopener">ZD423</a><br><a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html" target="_blank" rel="noopener">官网</a>或者直接去百度上搜索。<br>先看一下官网。。。。。哈哈<br><img src="/2019/03/26/VMware-15破解版/1.png" alt></p><h1 id="3-安装"><a href="#3-安装" class="headerlink" title="3.安装"></a>3.安装</h1><p>1.在下载目录下找到安装包并以管理员运行</p><p><img src="/2019/03/26/VMware-15破解版/3.png" alt></p><p>2.在弹出的界面选择下一步</p><p><img src="/2019/03/26/VMware-15破解版/11.png" alt></p><p>3.然后勾选我接受许可协议，然后点击下一步</p><p>4.点击更改选择自己要安装的位置</p><p><img src="/2019/03/26/VMware-15破解版/4.png" alt></p><p>5.点击下一步</p><p>6.点击下一步</p><p><img src="/2019/03/26/VMware-15破解版/5.png" alt></p><p>7.点击安装</p><p><img src="/2019/03/26/VMware-15破解版/6.png" alt></p><p>9.点击许可证</p><p><img src="/2019/03/26/VMware-15破解版/7.png" alt></p><p>10.输入许可证,在下面随便找一个注册码填到其中，再点击完成，完成安装</p><p><img src="/2019/03/26/VMware-15破解版/8.png" alt></p><h1 id="4-使用"><a href="#4-使用" class="headerlink" title="4.使用"></a>4.使用</h1><p>1.在桌面找到vmware workstation pro的快捷方式</p><p><img src="/2019/03/26/VMware-15破解版/9.png" alt></p><p>2.vmware界面</p><p><img src="/2019/03/26/VMware-15破解版/10.png" alt></p><h1 id="5-成果"><a href="#5-成果" class="headerlink" title="5.成果"></a>5.成果</h1><p>我安装了国产deepin系统以及kali和ubuntu，给大家展示一下deepin国产系统</p><p>deepin介绍看百度百科</p><blockquote><p>[1]  Deepin 原名Linux Deepin，在2014年4月改名<a href="https://baike.baidu.com/item/Deepin" target="_blank" rel="noopener">Deepin</a>。Deepin团队基于Qt/C++（用于前端）和Go（用于后端）开发了的全新深度桌面环境（DDE），以及音乐播放器，视频播放器，软件中心等一系列特色软件。</p><p>Deepin是由武汉深之度科技有限公司开发的Linux发行版。Deepin 是一个基于 Linux 的操作系统，专注于使用者对日常办公、学习、生活和娱乐的操作体验的极致，适合笔记本、桌面计算机和一体机。它包含了所有您需要的应用程序，网页浏览器、幻灯片演示、文档编辑、电子表格、娱乐、声音和图片处理软件，即时通讯软件等等。Deepin 的历史可以追溯到 2004年，其前身 Hiweed Linux 是中国第一个基于 Debian的本地化衍生版，并提供轻量级的可用LiveCD，旨在创造一个全新的简单、易用、美观的 Linux 操作系统。</p><p>Deepin拥有自主设计的特色软件：深度软件中心、深度截图、深度音乐播放器和深度影音，全部使用自主的DeepinUI，其中有深度桌面环境，DeepinTalk（深谈）等。</p><p>Deepin是中国最活跃的 Linux 发行版，Deepin 为所有人提供稳定、高效的操作系统，强调安全、易用、美观。其口号为“免除新手痛苦，节约老手时间”。在社区的参与下，“让 Linux 更易用”也不断变成可以触摸的现实。 [2] </p></blockquote><p><img src="/2019/03/26/VMware-15破解版/12.png" alt></p><p>应用商店有很多windows上常用的软件,甚至还有steam，这可以说非常适合热衷于游戏党了！可以看到他还有编程开发分类页，这上面有很多软件像Pycharm等这些软件，这不需要太多Linux命令，还是汉语，上面还有终端，可以说非常适合小白和新手入门Linux。</p><p><img src="/2019/03/26/VMware-15破解版/13.png" alt></p><p>让我们来看一下deepin上的终端</p><p><img src="/2019/03/26/VMware-15破解版/14.png" alt></p><p>可以说相当漂亮还有多种主题选择</p><p>最后给一个deepin系统下载地址：<a href="https://www.deepin.org/download/" target="_blank" rel="noopener">deepin镜像</a></p><p>注册码：</p><p><code>AZ7MK-44Y1J-H819Z-WMYNC-N7ATF</code></p><p><code>CU702-DRD1M-H89GP-JFW5E-YL8X6</code></p><p><code>YY5EA-00XDJ-480RP-35QQV-XY8F6</code></p><p><code>UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA</code></p><p><code>VF750-4MX5Q-488DQ-9WZE9-ZY2D6</code></p><p><code>UU54R-FVD91-488PP-7NNGC-ZFAX6</code></p><p><code>YC74H-FGF92-081VZ-R5QNG-P6RY4</code></p><p><code>YC34H-6WWDK-085MQ-JYPNX-NZRA2</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-为什么要下载vmware？以及vmware是什么？&quot;&gt;&lt;a href=&quot;#1-为什么要下载vmware？以及vmware是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.为什么要下载vmware？以及vmware是什么？&quot;&gt;&lt;/a&gt;1.为什么
      
    
    </summary>
    
      <category term="虚拟机" scheme="https://smallpotatody.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="虚拟机" scheme="https://smallpotatody.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Html+css基础语法</title>
    <link href="https://smallpotatody.github.io/2019/03/22/html-css%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://smallpotatody.github.io/2019/03/22/html-css基础语法/</id>
    <published>2019-03-22T10:47:44.000Z</published>
    <updated>2019-03-22T11:56:07.833Z</updated>
    
    <content type="html"><![CDATA[<p>Html标记语言<br>目录<br>Html标记语言<br>1.Html语法<br>1.什么是html语言<br>2.Html的标记和属性    </p><ol start="3"><li>语法不区分大小写<br> 2.html的基本结构<br> 1.<code>&lt;html&gt;</code>内容<code>&lt;/html&gt;</code><br> 2.<code>&lt;head&gt;</code>内容<code>&lt;/head&gt;</code><br> 3.<code>&lt;title&gt;</code>内容<code>&lt;/title&gt;</code><br> 4.<code>&lt;body&gt;</code>内容<code>&lt;/body&gt;</code><br> 5.<code>&lt;meta&gt;</code><br> 3.文档设置标记<br> 1.格式标记<br> 2.文本标记<br> 4.图形标记    </li><li>使用方法<br> 2.注意<br> 3.<code>&lt;img&gt;</code>标记属性<br> 5.超链接的使用<br> 6.表格<br> 1.<code>&lt;table&gt;…&lt;/table&gt;</code>标记<br> 2.<code>&lt;caption&gt;…&lt;/caption&gt;</code>标记<br> 3.<code>&lt;tr&gt;…&lt;/tr&gt;</code>表记<br> 7.框架<br> 1.<code>&lt;frameset&gt;</code>划分框架标记：<br> 2.<code>&lt;frame&gt;</code>子窗口标记：<br> 8.表单<br> 1.表单标记：<br> 2.文本域和密码：<br> 3.提交、重置、普通按钮：<br> 4.单选框和复选框：<br> 5.隐藏域：<br> 6.多行文本域：<br> 7.菜单下拉域：    </li></ol><p>1.Html语法<br>1.什么是html语言<br>超文本标记语言，标准通用标记语言下的一个应用。是 网页制作必备的编程语言。超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。超文本标记语言的结构包括“头”部分（英语：Head）、和“主体”部分（英语：Body），其中头”部提供关于网页的信息，“主体”部分提供网页的具体内容。<br>2.Html的标记和属性<br>HTML保存格式</p><ol><li>.html</li><li>.htm</li><li>.xhtml<br>标记和被标记的内容构建出HTML文档<ol><li>&lt;标记&gt; 内容 &lt;/标记&gt;<br>标记属性</li><li>就是用来控制我们的内容如何显示</li><li>格式：&lt;标记 属性1=属性值 属性2=属性值……….&gt;内容&lt;/标记&gt;</li></ol></li><li>语法不区分大小写<pre><code>a. &lt;HTML&gt;,&lt;Html&gt;,&lt;html&gt;都是一样的意义，但是尽量使用小写</code></pre></li><li>文档注释<pre><code>a.&lt;!—注释内容--&gt;</code></pre></li><li>代码格式<pre><code>a.空格键和回车键在网页中都不起作用b.使用Tab键进行缩进！</code></pre></li><li>字符实体<br>a.什么是字符实体？<br>字符实体通俗讲就是网页文件中复杂的符号代码和一些标点的代码。例如小于号 &lt; 大于号 &gt; 双引号 “这些符号要在浏览器中显示，在HTML文档中都必需被转化成字符实体。字符实体有三部分：一个和号 (&amp;)，一个实体名称及一个分号（；），或者 # 和一个实体编号，以及一个分号 (;)。<br>b.常见字符实体<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">显示结果描述实体名称实体编号</span><br><span class="line">  空格  &amp;nbsp;&amp;#160;</span><br><span class="line">&lt;小于号&amp;lt;&amp;#60;</span><br><span class="line">&gt;大于号&amp;gt;&amp;#62;</span><br><span class="line">&amp;和号&amp;amp;&amp;#38;</span><br><span class="line">&quot;引号&amp;quot;&amp;#34;</span><br><span class="line">&apos;撇号 &amp;apos; (IE不支持)&amp;#39;</span><br><span class="line">￠分（cent）&amp;cent;&amp;#162;</span><br><span class="line">£镑（pound）&amp;pound;&amp;#163;</span><br><span class="line">¥元（yen）&amp;yen;&amp;#165;</span><br><span class="line">€欧元（euro）&amp;euro;&amp;#8364;</span><br><span class="line">§小节&amp;sect;&amp;#167;</span><br><span class="line">©版权（copyright）&amp;copy;&amp;#169;</span><br><span class="line">®注册商标&amp;reg;&amp;#174;</span><br><span class="line">™商标&amp;trade;&amp;#8482;</span><br><span class="line">×乘号&amp;times;&amp;#215;</span><br><span class="line">÷除号&amp;divide;&amp;#247;</span><br></pre></td></tr></table></figure></li></ol><p>2.html的基本结构<br>1.<code>&lt;html&gt;</code>内容<code>&lt;/html&gt;</code><br>Html文档的文档标记，也称为html的开始标记。分别位于网页最前端和最后段，<code>&lt;html&gt;</code>表示网页开始，<code>&lt;/html&gt;</code>表示网页的结束。<br>2.<code>&lt;head&gt;内容&lt;/head&gt;</code><br>Html文件头标记，也称为html头信息开始标记。用来包含文件的基本信息，比如网页的标题、关键字。在其中可以放入<code>&lt;title&gt;……&lt;/title&gt;、&lt;meta&gt;、&lt;style&gt;……&lt;/style&gt;</code>等标记。<br>3.<code>&lt;title&gt;</code>内容<code>&lt;/title&gt;</code><br>Html文件标题标记，网页的“主题”，显示在浏览器的窗口的左上角，应当注意网页的标题不能太长，像百度这种短小精悍。<br>4.<code>&lt;body&gt;</code>内容<code>&lt;/body&gt;</code><br>HTML文档的主体标记，可以包含多个标记。例如：<code>&lt;p&gt;&lt;/p&gt;、&lt;h1&gt;&lt;/h1&gt;、&lt;br&gt;&lt;/br&gt;</code>等标记来组成我们看见的网页。Body标记常见属性：<br>bgcolor—————–设置背景颜色———<code>&lt;body bgcolor=&quot;blue&quot;&gt;&lt;/body&gt;</code><br>text——————–设置文本颜色———-<code>&lt;body text=&quot;red&quot;&gt;&lt;/body&gt;</code><br>link———————设置连接颜色———<code>&lt;body link=&quot;red&quot;&gt;&lt;/body&gt;</code><br>vlink——————–已经访问了的链接颜色–<code>&lt;body vlink=&quot;yellow&quot;&gt;&lt;/body&gt;</code><br>alink——————–正在被点击的链接颜色–<code>&lt;body alink=&quot;red&quot;&gt;&lt;/body&gt;</code><br>5.<code>&lt;meta&gt;</code><br>页面的元信息，提供有关页面的元信息，比如针对搜索引擎和更新频度的描述和关键词</p><p>`</p><p><meta name="”keyworlds”" content="”内容”">`<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其中常用的name属性有author、keyworlds、description、others。&lt;meta&gt;必须放在head元素里面。&lt;meta charset=”utf-8”&gt;来设置编码格式。</span><br></pre></td></tr></table></figure></p><p>3.文档设置标记<br>1.格式标记<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;br&gt;强制换行标记</span><br><span class="line">&lt;p&gt;换段落标记</span><br><span class="line">&lt;center&gt;居中对齐标记</span><br><span class="line">&lt;pre&gt;预格式化标记</span><br><span class="line">&lt;li&gt;列表项目标记</span><br><span class="line">&lt;ul&gt;无序列表标记</span><br><span class="line">&lt;ol&gt;有序列表标记---&#123; &lt;ol type=”符号类型”&gt;</span><br><span class="line">                     &lt;li type=”符号类型“&gt;&lt;/li&gt;</span><br><span class="line"> &lt;li type=”符号类型”&gt;&lt;/li&gt;</span><br><span class="line">                     …………………………………</span><br><span class="line">………………………………</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">&#125;</span><br><span class="line">Type属性值：1、A、a、I、i</span><br><span class="line">Value定义一个新的序列数字起始值，列表可以嵌套。</span><br><span class="line">&lt;dl&gt;&lt;dt&gt;&lt;dd&gt;对列表条目进行简短的说明，格式：</span><br><span class="line">&lt;dl&gt;</span><br><span class="line">&lt;dt&gt;软件说明：&lt;/dt&gt;</span><br><span class="line">&lt;dd&gt;简单介绍软件的功能及基本应用&lt;/dd&gt;</span><br><span class="line">&lt;dt&gt;软件界面&lt;/dt&gt;</span><br><span class="line">&lt;dd&gt;用于选择软件的外观&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br><span class="line">&lt;hr&gt;分割线————————————————————————————</span><br><span class="line">&lt;div&gt;分区显示标记，也称之为层标记，常用来编排一大段的html段落，也可以用于格式化表，和&lt;p&gt;很相似，可以多层嵌套使用。</span><br></pre></td></tr></table></figure></p><p>2.文本标记<br><code>&lt;hn&gt;&lt;/hn&gt;</code>，标题标记，n为1到6个级别，h1最大，h6最小；<br><code>&lt;font&gt;&lt;/font&gt;</code>，字体设置标记，有size（字体大小）、color（颜色）、face（字体）。例如：<font size="”3”" color="”red”" face="”宋体”"></font>。Size从1到7；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;&lt;/b&gt;粗体标记；</span><br><span class="line">&lt;i&gt;&lt;/i&gt;斜体标记；</span><br><span class="line">&lt;cite&gt;&lt;/cite&gt;引用方式的字体，斜体；</span><br><span class="line">&lt;em&gt;&lt;/em&gt;表示强调，斜体；</span><br><span class="line">&lt;sub&gt;&lt;/sub&gt;文字下标字体标记；</span><br><span class="line">&lt;sup&gt;&lt;/sup&gt;文字上标字体标记；</span><br><span class="line">&lt;strong&gt;&lt;/strong&gt;表示强调，粗体；</span><br><span class="line">&lt;small&gt;&lt;/small&gt;小型字体标记；</span><br><span class="line">&lt;big&gt;&lt;/big&gt;大型字体标记;</span><br><span class="line">&lt;u&gt;&lt;/u&gt;下划线字体标记；</span><br></pre></td></tr></table></figure></p><p>4.图形标记<br><code>&lt;img&gt;</code>图像标记</p><ol><li>使用方法<br>&lt;img src=”路径/文件名.图片格式或者图片网址” width=”属性值” height=”属性值” border=”属性值” alt=”属性值”&gt;<br>2.注意<br><code>&lt;img&gt;</code>为单标记；<br>3.<code>&lt;img&gt;</code>标记属性<br>1.src属性：指定我们要加载的图片的路径和图片名称和格式<br>2.width属性：指定图片的宽度，单位为px、em、cm、mm。<br>3.height属性：指定图片高度，单位为px、em、cm、mm。<br>4.border属性：指定图片的边框宽度，单位为px、em、cm、mm。<br>5.alt属性：当网页上的图片被加载完成后，鼠标移动到上面去，会显示这个图片指定的属性文字。如果图像没有下载或者加载失败，会用文字来代替图像显示。搜索引擎可以通个这个属性的文字来抓取图片。<br>5.超链接的使用<br>1.基本语法<br><code>&lt;a href=” ” target=”打开方式” name=“页面锚点名称” &gt;链接文字或者图片&lt;/a&gt;</code><br>2.属性<br>1.href属性：链接的的地址，链接的地址可以是一个网页，也可以是一个视频、图片、音乐等等。<br>2.target属性：<br>定义超链接的打开方式<br>_blank 在一个新的窗口中打开链接；<br>_seif(默认值)在当前页面打开；<br>_parent 在父窗口中打开页面<br>_top 在顶层窗口中打开文件<br>3.name属性：<br>指定页面的的锚点名称；<br><img src="/2019/03/22/html-css基础语法/1.1.png" alt><br><img src="/2019/03/22/html-css基础语法/1.2.png" alt><br>6.表格<br>1.<code>&lt;table&gt;…&lt;/table&gt;</code>标记<br>1.基本格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   &lt;table width=&quot;960&quot; …… height=&quot;300&quot;(属性=”属性值”) &gt;</span><br><span class="line">&lt;caption&gt;表格标题&lt;/caption&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;th&gt;班级&lt;/th&gt;</span><br><span class="line">&lt;th&gt;姓名&lt;/th&gt; </span><br><span class="line">&lt;th&gt;年龄&lt;/th&gt; </span><br><span class="line">&lt;th&gt;成绩&lt;/th&gt; </span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;四年级一班&lt;/td&gt;</span><br><span class="line">&lt;td&gt;张三&lt;/td&gt;</span><br><span class="line">&lt;td&gt;16&lt;/td&gt;</span><br><span class="line">&lt;td&gt;80&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></li></ol><p>2.table标记的属性：<br>    1.width表示表格宽度，单位px、%。<br>    2.height 表示表格的高度，单位px、%。<br>    3.border 表示表格外边框的宽度，单位<br>    4.align属性 表格显示的位置。如：align=“left”，其中left可以为center、right，默认是left。<br>    5.cellspacing 单元格之间的间距，默认值是2px，单位为px像素。<br>    6.cellpadding 单元格内容与单元格边框的显示距离，单位像素。<br>    7.frame 控制表格边框最外层的四条线框：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.void：默认值，表示无边框</span><br><span class="line">2.above：表示仅有顶部边框</span><br><span class="line">3.below：表示仅有底部边框</span><br><span class="line">4.hsides：表示仅有顶部和底部边框</span><br><span class="line">5.lhs：表示仅有左侧边框</span><br><span class="line">6.rhs：表示仅有右侧边框</span><br><span class="line">7.vsides：表示仅有左右侧边框</span><br><span class="line">8.box：表示包含全部4个边框</span><br><span class="line">9.border：表示包含全部4个边框</span><br></pre></td></tr></table></figure></p><p>8.rules 控制单元是否显示以及如何显示单元格之间的分割线：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.none 表示无分割线</span><br><span class="line">2.all 表示包括所有分割线</span><br><span class="line">3.rows 表示仅有行分割线</span><br><span class="line">4.clos 表示仅有列分割线</span><br><span class="line">5.groups 表示仅在行组和列祖之间有分割线</span><br></pre></td></tr></table></figure></p><p>2.<code>&lt;caption&gt;…&lt;/caption&gt;</code>标记<br>即表格标题标记，位于<code>&lt;table&gt;</code>之后，<code>&lt;tr&gt;</code>之前。有align属性，使用格式为<code>&lt;caption align=”top”&gt;</code>。top可以为bottom（表格的下部）、left（表格的左部）、right（表格的右部）。<br>3.<code>&lt;tr&gt;…&lt;/tr&gt;</code>标记<br>定义表格的一行，对于每一个表格行，都是由一对<tr>…</tr>标记表示，每一行<tr>标记内可以嵌套多个<td>或者<th>标记。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.bgcolor 设置背景颜色，bgcolor=”颜色值”</span><br><span class="line">2.align 设置垂直方向对齐方式，align=“值”，值为top（靠底部对齐）、bottom（靠顶端对齐）、middle（居中对齐）。</span><br><span class="line">3.valign 设置水平方向对齐方式，valign=”值”，值为left（靠左对齐）、right（靠右对齐）、center（居中对齐）。</span><br></pre></td></tr></table></figure></th></td></tr></p><p>4.<code>&lt;td&gt;和&lt;th&gt;</code>标记<br><code>&lt;td&gt;和&lt;th&gt;</code>都是单元格的标记，其必须嵌套在<code>&lt;tr&gt;</code>标签内，是成对出现的，<code>&lt;th&gt;</code>是表头标记，通常位于首行或者首列，<code>&lt;th&gt;</code>中的文字默认会被加粗，而<code>&lt;td&gt;</code>不会，<code>&lt;td&gt;</code>是数据标记，表示该单元格的具体数据。属性有bgcolor、align、valign、width、height、rowspan(单元格所占行数)、colspan（单元格所占列数）。<br><img src="/2019/03/22/html-css基础语法/3.png" alt><br>7.框架<br>框架将浏览器划分成不同的部分，每一个部分加载不同的网页，实现在同一浏览器窗口中加载多个页面的效果。<br>格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;HTML框架&lt;/title&gt;</span><br><span class="line">&lt;meta=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;frameset rows=&quot;90,*,90&quot; frameborder=&quot;1&quot; border=&quot;1&quot;&gt;</span><br><span class="line">&lt;frame name=&quot;top&quot; src=&quot;top.html&quot;/&gt;</span><br><span class="line">&lt;frameset cols=&quot;30%,70%&quot;&gt;</span><br><span class="line">&lt;frame name=&quot;left&quot; src=&quot;left.html&quot;/&gt;</span><br><span class="line">&lt;frame name=&quot;right&quot; src=&quot;right.html&quot; scrolling=&quot;auto&quot;/&gt;</span><br><span class="line">&lt;/frameset&gt;</span><br><span class="line">&lt;frame name=&quot;bottom&quot; src=&quot;bottom.html&quot;/&gt;</span><br><span class="line">&lt;/frameset&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>1.<code>&lt;frameset&gt;</code>划分框架标记：<br>cols：分割左右窗口，<code>’*’</code>表示剩余部分，<code>’*’,’*’</code>表示均分成两个，<code>’*,’*’,’*’</code>表示均分成三个，单位为像素和%比。<br>rows：分割上下窗口，<code>’*’</code>表示剩余部分，<code>’*’,’*’</code>表示均分成两个<code>，’*,’*’,’*’</code>表示均分成三个，单位为像素和%比。<br>frameborder：指定是否显示边框，0表示不显示边框，1表示显示边框。<br>border：设置边框的大小，默认值为5像素。<br>2.<code>&lt;frame&gt;</code>子窗口标记：<br>在<code>&lt;frameset&gt;</code>中设置了几个窗口，就必须对应使用几个<code>&lt;frame&gt;</code>框架，而且还必须使用src属性指定一个网页。<br>src：加载网页文件的URL地址；<br>name: 框架名称，是链接标记的target所要参数；<br>noresize：表示不能调节框架大小，没有设置时可以调整；<br>scrolling：是否需要滚动条，根据需要可以选择yes（表示有滚动条）、no（表示无滚动条）、auto（表示根据需要自动出现）。<br>frameborder：是否需要边框，1表示显示边框，0表示不显示边框。<br><img src="/2019/03/22/html-css基础语法/2..png" alt><br><img src="/2019/03/22/html-css基础语法/2.png" alt><br><img src="/2019/03/22/html-css基础语法/2.1.png" alt><br>8.表单<br>1.表单标记：</p><p><code>&lt;form&gt; &lt;/form&gt;</code>定义表单开始和结束位置，表单提交时的内容就是<code>&lt;form&gt;</code>表单中的内容。<br>基本格式<code>&lt;form action=”服务器端地址（接受表单内容的地址）” name=”表单名称” method=“post或者get“&gt;…&lt;/from&gt;</code>。name为表单名称，method为传送数据的方式，分为post和get两种方式，get方式提交时，会将表单的内容附加在URL地址的后面，所以限制了提交内容的长度，不超过8192个字符，且不具备保密性。post方式提交时，将表单中的数据一并包含在表单主体中，一起传送到服务器中处理，没有数据大小限制，且具有保密性,默认是get方式。action是指表单数据的处理程序的URL地址，如果为空则使用当前文档的URL地址，如果表单中不需要使用action属性也要指定其属性为”no”。enctype设置表单的资料的编码方式。Target用来指定目标窗口，和超链接的属于类似。<br>2.文本域和密码：<br><code>&lt;input&gt;</code>标记是单标记没有结束标记。<code>&lt;input type=”” name=”” value=”” size=”” maxlength=””&gt;</code>。type属性有text和password两种，type=”text”时，<code>&lt;input&gt;</code>表示一个文本输入域，type=”password”时，<code>&lt;input&gt;</code>表示一个密码域。name属性定义控件的名称。value属性表示初始化值，打开浏览器时，文本框中的内容。size属性设置控件的长度。maxlenght属性表示输入框中最大允许输入的字符数。<br>3.提交、重置、普通按钮：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提交按钮： &lt;input type=”submit”&gt;;</span><br><span class="line">重置按钮： &lt;input type=”reset”&gt;</span><br><span class="line">普通按钮： &lt;input type=”button”&gt;</span><br></pre></td></tr></table></figure></p><p>4.单选框和复选框：<br><code>&lt;input type=”radio”&gt;</code>   ————&gt;除了初值为两个都没选，其余要选则必须选一个，且只能是一个；<br><code>&lt;input type=”checkbox”&gt;</code>  ———&gt;可以选一个也可取消，或可两个都选和不选；<br><code>&lt;input type=”radio” checked=”checked”&gt;</code> ——&gt;checked为默认选项；<br>5.隐藏域：<br><code>&lt;input type=”hidden”&gt;</code> ————&gt;隐藏表单域；<br>6.多行文本域：<br><code>&lt;textarea name=”name” rows=”n” cols=”n” value=”……”&gt;…&lt;/textarea&gt;</code>，n指数值，rows属性指行数，cols属性指列数，单位是字符个数。<br>7.菜单下拉域：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;select name=”” size=”value” multiple&gt; ——&gt;multiple表示多选</span><br><span class="line">&lt;option value=”value” selected&gt; value &lt;/option&gt;</span><br><span class="line">&lt;option value=”value”&gt; value &lt;/option&gt;</span><br><span class="line">&lt;option value=”value”&gt; value &lt;/option&gt;</span><br><span class="line">…………………………………………………………</span><br><span class="line">&lt;option value=”value”&gt; value &lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p><code>&lt;option&gt;</code>标记用来指定列表中的的一个选项，需要放在<code>&lt;select&gt;&lt;/select&gt;</code>之间，给选项赋值，指定传送到服务器上面的值，selected指定默认选项值。</p><p><img src="/2019/03/22/html-css基础语法/1.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Html标记语言&lt;br&gt;目录&lt;br&gt;Html标记语言&lt;br&gt;1.Html语法&lt;br&gt;1.什么是html语言&lt;br&gt;2.Html的标记和属性    &lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;语法不区分大小写&lt;br&gt; 2.html的基本结构&lt;br&gt; 1.&lt;code&gt;&amp;lt
      
    
    </summary>
    
      <category term="html+css" scheme="https://smallpotatody.github.io/categories/html-css/"/>
    
    
      <category term="html+css" scheme="https://smallpotatody.github.io/tags/html-css/"/>
    
  </entry>
  
  <entry>
    <title>SecureCRT的安装与破解</title>
    <link href="https://smallpotatody.github.io/2019/03/15/SecureCRT/"/>
    <id>https://smallpotatody.github.io/2019/03/15/SecureCRT/</id>
    <published>2019-03-15T07:04:30.000Z</published>
    <updated>2019-03-15T10:14:49.084Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="1-下载securecrt"><a href="#1-下载securecrt" class="headerlink" title="1.下载securecrt"></a>1.下载securecrt</h1><p>securecrt下载地址:</p><p><a href="https://pan.baidu.com/s/1cOSa11PBETc_fq3jAmWcFQ/" target="_blank" rel="noopener">百度网盘</a> 提取码: fbmi 复制这段内容后打开百度网盘手机App，操作更方便哦!<br>软件资源取自ZD423,也可以去ZD423去下载!<br><a href="http://www.zdfans.com/html/16750.html" target="_blank" rel="noopener">ZD423</a><br><a href="https://www.vandyke.com/cgi-bin/releases.php?product=securecrt" target="_blank" rel="noopener">官网</a><br>找到自己要下的对应的版本下载<br><img src="/2019/03/15/SecureCRT/8.png" alt></p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><ul><li><p>将下载下来的软件解压，然后安装scrt_sfx833-x64</p><p><img src="/2019/03/15/SecureCRT/1.png" alt></p></li></ul><ul><li>选择complete</li></ul><p><img src="/2019/03/15/SecureCRT/2.png" alt></p><ul><li>添加桌面快捷方式</li></ul><p><img src="/2019/03/15/SecureCRT/3.png" alt></p><ul><li><p>安装完成</p><p><img src="/2019/03/15/SecureCRT/4.png" alt></p></li><li><p>安装完成后，可以看到桌面已经有了快捷方式，先别忙打开软件</p><p>将Crack文件夹或者keygen.exe复制到SecureCRT安装路径：c &gt; program &gt; VanDyke Software &gt; Clients</p><p><img src="/2019/03/15/SecureCRT/5.png" alt></p></li><li><p>以管理员身份运行keygen.exe</p><p><img src="/2019/03/15/SecureCRT/6.png" alt></p></li></ul><ul><li><p>点击Patch，如果出现We are sorry ……………,那么就关掉重新点击注册机上的Generate按钮更换注册码，直到成功出现Path has been done successfully!字样代表成功了。</p><p><img src="/2019/03/15/SecureCRT/7.png" alt></p></li></ul><p><strong>注意：</strong> 点击确定按钮后会再弹出一个界面选择LicenseHelper.exe,然后会出现同样成功的字样。</p><ul><li>再点击桌面上的快捷方式就会弹出 一个服务器连着电脑的图形界面就成功了。<h1 id="3-SecureCRT的使用"><a href="#3-SecureCRT的使用" class="headerlink" title="3.SecureCRT的使用"></a>3.SecureCRT的使用</h1></li></ul><ul><li>在连接之前，你与要到你的Linux系统上去开启sshd服务在终端输入<br><code>sudo apt-get install openssh-server</code></li></ul><ul><li>终端上显示:<code>ssh start/running, process 2425</code>就表示安装好了。<br><img src="/2019/03/15/SecureCRT/10.png" alt></li></ul><ul><li>在终端上输入命令<code>ifconfig</code></li></ul><ul><li>找到你虚拟机的ip，然后将IP复制到以下界面中的Hostname<br><img src="/2019/03/15/SecureCRT/9.png" alt></li></ul><ul><li>然后连接进行测试，由于我使用的是ubuntu<br><img src="/2019/03/15/SecureCRT/11.png" alt></li></ul><ul><li>找到SecureCRT的设置及Session Options进行设置<br><img src="/2019/03/15/SecureCRT/12.png" alt></li></ul><ul><li>文件传输Zmodem<br>先在终端上输入命令进行安装：<code>sudo apt-get install lrzsz</code></li></ul><ul><li>从windows上传文件至linux：<code>rz</code> </li></ul><ul><li>从linux上传文件至windows：<code>sz filename</code>,然后在windows上的Downloads<br><img src="/2019/03/15/SecureCRT/13.png" alt><br><img src="/2019/03/15/SecureCRT/14.png" alt></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-下载securecrt&quot;&gt;&lt;a href=&quot;#1-下载securecrt&quot; class=&quot;headerlink&quot; title=&quot;1.下载securecrt&quot;&gt;&lt;/a&gt;1.下载securecrt&lt;/h1&gt;&lt;p&gt;securecr
      
    
    </summary>
    
      <category term="software" scheme="https://smallpotatody.github.io/categories/software/"/>
    
    
      <category term="软件安装" scheme="https://smallpotatody.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法的介绍</title>
    <link href="https://smallpotatody.github.io/2019/03/11/markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://smallpotatody.github.io/2019/03/11/markdown语法/</id>
    <published>2019-03-11T10:50:38.923Z</published>
    <updated>2019-03-11T12:11:27.531Z</updated>
    
    <content type="html"><![CDATA[<p>怎样在网站上书写我们的第一篇博客吧<br><a id="more"></a></p><h1 id="一、创建文章"><a href="#一、创建文章" class="headerlink" title="一、创建文章"></a>一、创建文章</h1><p>在站点文件夹中打开 git bash，输入如下命令创建文章，其中 name 为文章的标题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;name&quot;</span><br></pre></td></tr></table></figure></p><p>当输入命令后，就会在 source/_post 文件夹下创建一个文件，命名为：name.md<br>这个文件就是将要发布到网站上的原始文件，用于记录文章内容</p><h1 id="二、编写文章（基于-Markdown）"><a href="#二、编写文章（基于-Markdown）" class="headerlink" title="二、编写文章（基于 Markdown）"></a>二、编写文章（基于 Markdown）</h1><h2 id="1、Markdown-简介"><a href="#1、Markdown-简介" class="headerlink" title="1、Markdown 简介"></a>1、Markdown 简介</h2><p>Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式<br>基于 Markdown 语法的简洁性，它已经成为目前世界上最流行的用于书写博客的语言</p><h2 id="2、Markdown-语法"><a href="#2、Markdown-语法" class="headerlink" title="2、Markdown 语法"></a>2、Markdown 语法</h2><p>Typora-Markdown编辑器<br>简单而强大，支持原生的语法，也支持对应的快捷键，还可以 实时预览<br> Typora 的下载地址：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></p><h1 id="三、常用的-Markdown-语法"><a href="#三、常用的-Markdown-语法" class="headerlink" title="三、常用的 Markdown 语法"></a>三、常用的 Markdown 语法</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h2><p>Markdown 语法：</p><p> #一级标题</p><p> ##二级标题</p><p> ###三级标题</p><p> ####四级标题</p><p> #####五级标题</p><p> ######六级标题<br>Typora 快捷键：<br>Ctrl+1：一级标题<br>Ctrl+2：二级标题<br>Ctrl+3：三级标题<br>Ctrl+4：四级标题<br>Ctrl+5：五级标题<br>Ctrl+6 ：六级标题<br>Ctrl+0：段落</p><h2 id="2-粗体、斜体、删除线和下划线"><a href="#2-粗体、斜体、删除线和下划线" class="headerlink" title="2.粗体、斜体、删除线和下划线"></a>2.粗体、斜体、删除线和下划线</h2><p>Markdown 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure></p><p>Typora 快捷键：<br>Ctrl+I：斜体<br>Ctrl+B：粗体<br>Ctrl+U：下划线<br>Alt+Shift+5：删除线</p><h2 id="3-引用块"><a href="#3-引用块" class="headerlink" title="3.引用块"></a>3.引用块</h2><p>Markdown 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 文字引用</span><br><span class="line">Typora 快捷键： Ctrl+Shift+Q</span><br></pre></td></tr></table></figure></p><h2 id="4-代码块"><a href="#4-代码块" class="headerlink" title="4.代码块"></a>4.代码块</h2><p>Markdown 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`行内代码`</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``` 多行代码  ```</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>行内代码：Ctrl+Shift+`</p><p>多行代码：Ctrl+Shift+K</p><h2 id="5-公式块"><a href="#5-公式块" class="headerlink" title="5.公式块"></a>5.公式块</h2><p>Markdown 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$ </span><br><span class="line">  数学公式</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></p><p>Typora 快捷键： Ctrl+Shift+M</p><h2 id="6-分割线"><a href="#6-分割线" class="headerlink" title="6.分割线"></a>6.分割线</h2><p>Markdown 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一:---</span><br><span class="line"></span><br><span class="line">方法二:+++</span><br><span class="line"></span><br><span class="line">方法三：***</span><br></pre></td></tr></table></figure></p><h2 id="7-列表"><a href="#7-列表" class="headerlink" title="7.列表"></a>7.列表</h2><p>Markdown 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.有序列表项</span><br><span class="line"></span><br><span class="line">*无序列表项</span><br><span class="line"></span><br><span class="line">+无序列表项</span><br><span class="line"></span><br><span class="line">-无序列表项</span><br></pre></td></tr></table></figure></p><p>Typora 快捷键：</p><p>有序列表项：Ctrl+Shift+[</p><p>无序列表项：Ctrl+Shift+]</p><h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h2><p>Markdown 语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头1|表头2</span><br><span class="line">-|-|-</span><br><span class="line">内容11|内容12</span><br><span class="line">内容21|内容22</span><br></pre></td></tr></table></figure></p><p>Typora 快捷键： Ctrl+T</p><h2 id="9-超链接"><a href="#9-超链接" class="headerlink" title="9.超链接"></a>9.超链接</h2><p>Markdown语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一[](链接地址 &quot;链接描述&quot;)</span><br><span class="line">如[](https://www.example.com/ &quot;示例链接&quot;)</span><br><span class="line"></span><br><span class="line">方法二：&lt;链接地址&gt;</span><br><span class="line">如：&lt;https://www.example.com/&gt;</span><br></pre></td></tr></table></figure></p><p>Typora快捷键： Ctrl+K</p><p>##10.图片<br>Markdown语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片文字](图片地址 &quot;图片描述&quot;)</span><br><span class="line">如：![示例图片](https://www.example.com/example.PNG &quot;示例图片&quot;)</span><br></pre></td></tr></table></figure></p><p>Typora快捷键： Ctrl+Shift+I</p><p>注:</p><p>安装插件 npm install hexo-asset-image –save</p><p>将 站点配置文件 中的 post_asset_folde: true</p><p>这样，当使用 hexo new name文章时，将同时在 source/_post 文件夹中生成一个 name文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown语法写入<br>如：在资源文件夹（就是那个与 name文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![示例图片](title/example.PNG &quot;示例图片&quot;)</code>添加图片</p><h1 id="四、高级设置"><a href="#四、高级设置" class="headerlink" title="四、高级设置"></a>四、高级设置</h1><h2 id="1-模板设置"><a href="#1-模板设置" class="headerlink" title="1.模板设置"></a>1.模板设置</h2><p>当我们使用命令 hexo new “title” 创建文章时，Hexo 会根据 /scaffolds/post.md 对新文章进行初始化<br>换言之，/scaffolds/post.md 就是新文章的 模板，所以我们可以修改它来适应自己的写作习惯<br>一个简单的示例如下：<br>title: Markdown语法的介绍<br>date: 1552301438923<br>tags:<br>categories: </p><h2 id="2-头部设置"><a href="#2-头部设置" class="headerlink" title="2.头部设置"></a>2.头部设置</h2><p>在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 文章头部<br>文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以为文章添加标签、分类等<br>一个简单的示例如下：<br>title: Title<br>date: YYYY-MM-DD HH:MM:SS<br>tags: [tag1, tag2, …]<br>categories: category<br>注意：属性和属性值之间必须有一个空格，否则会解析错误</p><h2 id="3-首页显示"><a href="#3-首页显示" class="headerlink" title="3.首页显示"></a>3.首页显示</h2><p>在利用 Hexo 框架搭建的博客网站中，首页会显示文章的内容，且默认显示文章的全部内容<br>如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简<br>这时，我们只需在文章中使用 <!--more--> 标志即可，表示只会显示标志前面的内容</p><h1 id="五、部署发布"><a href="#五、部署发布" class="headerlink" title="五、部署发布"></a>五、部署发布</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><p>建议：在使用 hexo g 部署之后，可以先使用 hexo s 运行本地站点，然后在浏览器输入地址 <a href="http://lacolhost:4000/" target="_blank" rel="noopener">http://lacolhost:4000/</a> 查看运行结果，检查无误后再使用 hexo d 发布</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;怎样在网站上书写我们的第一篇博客吧&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://smallpotatody.github.io/2019/03/09/hello-world/"/>
    <id>https://smallpotatody.github.io/2019/03/09/hello-world/</id>
    <published>2019-03-09T10:32:22.000Z</published>
    <updated>2019-04-09T13:43:48.161Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
